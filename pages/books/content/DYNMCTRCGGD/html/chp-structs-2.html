<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="en-US">
<head>
<meta http-equiv="Content-type" content="text/html; charset=iso-8859-1">
<title>Pointers to Structs - Solaris Dynamic Tracing Guide</title>
<meta name="robots" content="index,follow">
<meta name="robots" content="index,follow">
<meta name="date" content="2008-11-01">
<meta name="collection" content="reference">
<link rel="stylesheet" type="text/css" href="css/elements.css">
<link rel="stylesheet" type="text/css" href="css/indiana.css">
</head>

<body>


<div class="Masthead">
   <div class="MastheadLogo">
      <a href="http://www.opensolaris.org"><img border="0" src="graphics/header.png"></img></a>
   </div>
   <div class="Title">Solaris Dynamic Tracing Guide</div>
</div>

<table class="Layout" border="0" cellspacing="0" width="100%">
<tbody>

   <tr valign="top" class="PageControls">
      <td></td>
      <td>
         <table width="100%">
      	   <tr>
      	     <td>
                 <a href="chp-structs-1.html">Previous</a>
             </td>
             <td align="right">
                 <a href="chp-structs-3.html">Next</a>
             </td>
           </tr>
         </table>
      </td>
   </tr>
   
   <tr valign="top">
      <td class="Navigation" width="200px"><p class="toc level1"><a href="docinfo.html">Document Information</a></p>
<p class="toc level1 tocsp"><a href="preface.html">Preface</a></p>
<p class="toc level1 tocsp"><a href="chp-intro.html">1.&nbsp;&nbsp;Introduction</a></p>
<p class="toc level1 tocsp"><a href="chp-typeopexpr.html">2.&nbsp;&nbsp;Types, Operators, and Expressions</a></p>
<p class="toc level1 tocsp"><a href="chp-variables.html">3.&nbsp;&nbsp;Variables</a></p>
<p class="toc level1 tocsp"><a href="chp-prog.html">4.&nbsp;&nbsp;D Program Structure</a></p>
<p class="toc level1 tocsp"><a href="chp-pointers.html">5.&nbsp;&nbsp;Pointers and Arrays</a></p>
<p class="toc level1 tocsp"><a href="chp-strings.html">6.&nbsp;&nbsp;Strings</a></p>
<p class="toc level1 tocsp"><a href="chp-structs.html">7.&nbsp;&nbsp;Structs and Unions</a></p>
<p class="toc level2"><a href="chp-structs-1.html">Structs</a></p>
<div class="onpage">
<p class="toc level2"><a href="">Pointers to Structs</a></p>
</div>
<p class="toc level2"><a href="chp-structs-3.html">Unions</a></p>
<p class="toc level2"><a href="chp-structs-4.html">Member Sizes and Offsets</a></p>
<p class="toc level2"><a href="chp-structs-5.html">Bit-Fields</a></p>
<p class="toc level1 tocsp"><a href="chp-types.html">8.&nbsp;&nbsp;Type and Constant Definitions</a></p>
<p class="toc level1 tocsp"><a href="chp-aggs.html">9.&nbsp;&nbsp;Aggregations</a></p>
<p class="toc level1 tocsp"><a href="chp-actsub.html">10.&nbsp;&nbsp;Actions and Subroutines</a></p>
<p class="toc level1 tocsp"><a href="chp-buf.html">11.&nbsp;&nbsp;Buffers and Buffering</a></p>
<p class="toc level1 tocsp"><a href="chp-fmt.html">12.&nbsp;&nbsp;Output Formatting</a></p>
<p class="toc level1 tocsp"><a href="chp-spec.html">13.&nbsp;&nbsp;Speculative Tracing</a></p>
<p class="toc level1 tocsp"><a href="chp-dtrace1m.html">14.&nbsp;&nbsp;<tt>dtrace</tt>(1M) Utility</a></p>
<p class="toc level1 tocsp"><a href="chp-script.html">15.&nbsp;&nbsp;Scripting</a></p>
<p class="toc level1 tocsp"><a href="chp-opt.html">16.&nbsp;&nbsp;Options and Tunables</a></p>
<p class="toc level1 tocsp"><a href="chp-dtrace.html">17.&nbsp;&nbsp;<tt>dtrace</tt> Provider</a></p>
<p class="toc level1 tocsp"><a href="chp-lockstat.html">18.&nbsp;&nbsp;<tt>lockstat</tt> Provider</a></p>
<p class="toc level1 tocsp"><a href="chp-profile.html">19.&nbsp;&nbsp;<tt>profile</tt> Provider</a></p>
<p class="toc level1 tocsp"><a href="chp-fbt.html">20.&nbsp;&nbsp;<tt>fbt</tt> Provider</a></p>
<p class="toc level1 tocsp"><a href="chp-syscall.html">21.&nbsp;&nbsp;<tt>syscall</tt> Provider</a></p>
<p class="toc level1 tocsp"><a href="chp-sdt.html">22.&nbsp;&nbsp;<tt>sdt</tt> Provider</a></p>
<p class="toc level1 tocsp"><a href="chp-sysinfo.html">23.&nbsp;&nbsp;<tt>sysinfo</tt> Provider</a></p>
<p class="toc level1 tocsp"><a href="chp-vminfo.html">24.&nbsp;&nbsp;<tt>vminfo</tt> Provider</a></p>
<p class="toc level1 tocsp"><a href="chp-proc.html">25.&nbsp;&nbsp;<tt>proc</tt> Provider</a></p>
<p class="toc level1 tocsp"><a href="chp-sched.html">26.&nbsp;&nbsp;<tt>sched</tt> Provider</a></p>
<p class="toc level1 tocsp"><a href="chp-io.html">27.&nbsp;&nbsp;<tt>io</tt> Provider</a></p>
<p class="toc level1 tocsp"><a href="chp-mib.html">28.&nbsp;&nbsp;<tt>mib</tt> Provider</a></p>
<p class="toc level1 tocsp"><a href="chp-fpuinfo.html">29.&nbsp;&nbsp;<tt>fpuinfo</tt> Provider</a></p>
<p class="toc level1 tocsp"><a href="chp-pid.html">30.&nbsp;&nbsp;<tt>pid</tt> Provider</a></p>
<p class="toc level1 tocsp"><a href="chp-plockstat.html">31.&nbsp;&nbsp;<tt>plockstat</tt> Provider</a></p>
<p class="toc level1 tocsp"><a href="chp-fasttrap.html">32.&nbsp;&nbsp;<tt>fasttrap</tt> Provider</a></p>
<p class="toc level1 tocsp"><a href="chp-user.html">33.&nbsp;&nbsp;User Process Tracing</a></p>
<p class="toc level1 tocsp"><a href="chp-usdt.html">34.&nbsp;&nbsp;Statically Defined Tracing for User Applications</a></p>
<p class="toc level1 tocsp"><a href="chp-sec.html">35.&nbsp;&nbsp;Security</a></p>
<p class="toc level1 tocsp"><a href="chp-anon.html">36.&nbsp;&nbsp;Anonymous Tracing</a></p>
<p class="toc level1 tocsp"><a href="chp-post.html">37.&nbsp;&nbsp;Postmortem Tracing</a></p>
<p class="toc level1 tocsp"><a href="chp-perf.html">38.&nbsp;&nbsp;Performance Considerations</a></p>
<p class="toc level1 tocsp"><a href="chp-stab.html">39.&nbsp;&nbsp;Stability</a></p>
<p class="toc level1 tocsp"><a href="chp-xlate.html">40.&nbsp;&nbsp;Translators</a></p>
<p class="toc level1 tocsp"><a href="chp-vers.html">41.&nbsp;&nbsp;Versioning</a></p>
<p class="toc level1 tocsp"><a href="gloss01.html">Glossary</a></p>
<p class="toc level1 tocsp"><a href="idx-1.html">Index</a></p>
</td>
      <td class="ContentPane" width="705px">

	 <div class="MainContent">      	 
             

<a name="chp-structs-2"></a><h3>Pointers to Structs</h3>
<p><a name="indexterm-120"></a><a name="indexterm-121"></a>Referring to structs using pointers is very common in C and D. You
can use the operator <tt>-&gt;</tt> to access struct members through a pointer.
If a <tt>struct s</tt> has a member <tt>m</tt> and you have a pointer
to this struct named <tt>sp</tt> (that is, <tt>sp</tt> is a variable of type <tt>struct s *</tt>),
you can either use the <tt>*</tt> operator to first dereference <tt>sp</tt> pointer in
order to access the member:</p><pre>struct s *sp;

(*sp).m</pre><p>or you can use the <tt>-&gt;</tt> operator as a shorthand for this notation.
The following two D fragments are equivalent in meaning if <tt>sp</tt> is
a pointer to a struct:</p><pre>(*sp).m                sp-&gt;m</pre><p><a name="indexterm-122"></a>DTrace provides several built-in variables which are pointers to structs, including <tt>curpsinfo</tt> and
<tt>curlwpsinfo</tt>. These pointers refer to the structs <tt>psinfo</tt> and <tt>lwpsinfo</tt> respectively, and their content
provides a snapshot of information about the state of the current process and
lightweight process (LWP) associated with the thread that has fired the current probe.
A Solaris LWP is the kernel's representation of a user thread, upon which
the Solaris threads and POSIX threads interfaces are built. For convenience, DTrace exports
this information in the same form as the <tt>/proc</tt> filesystem files <tt>/proc/</tt><i>pid</i><tt>/psinfo</tt> and
<tt>/proc/</tt><i>pid</i><tt>/lwps/</tt><i>lwpid</i><tt>/lwpsinfo</tt>. The <tt>/proc</tt> structures are used by observability and debugging tools such as
<a href="http://docs.sun.com/doc/819-2239/ps-1?a=view"><tt>ps</tt>(1)</a>, <a href="http://docs.sun.com/doc/819-2239/pgrep-1?a=view"><tt>pgrep</tt>(1)</a>, and <a href="http://docs.sun.com/doc/819-2239/truss-1?a=view"><tt>truss</tt>(1)</a>, and are defined in the system header file <tt>&lt;sys/procfs.h&gt;</tt> and
are described in the <tt>proc</tt>(4) man page. Here are few example expressions using <tt>curpsinfo</tt>, their
types, and their meanings:</p><table><col width="25%"><col width="25%"><col width="50%"><tr><td align="left" valign="top" scope="row"><p><tt>curpsinfo-&gt;pr_pid</tt></p></td>
<td align="left" valign="top" scope="row"><p><tt>pid_t</tt></p></td>
<td align="left" valign="top" scope="row"><p>current process ID</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>curpsinfo-&gt;pr_fname</tt></p></td>
<td align="left" valign="top" scope="row"><p><tt>char []</tt></p></td>
<td align="left" valign="top" scope="row"><p>executable file name</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>curpsinfo-&gt;pr_psargs</tt></p></td>
<td align="left" valign="top" scope="row"><p><tt>char []</tt></p></td>
<td align="left" valign="top" scope="row"><p>initial command line arguments</p></td>
</tr>
</table><p><a name="indexterm-123"></a>You should review the complete structure definition later by examining the <tt>&lt;sys/procfs.h&gt;</tt> header
file and the corresponding descriptions in <tt>proc</tt>(4). The next example uses the <tt>pr_psargs</tt>
member to identify a process of interest by matching command-line arguments.</p><p>Structs are used frequently to create complex data structures in C programs, so
the ability to describe and reference structs from D also provides a
powerful capability for observing the inner workings of the Solaris operating system kernel and
its system interfaces. In addition to using the aforementioned <tt>curpsinfo</tt> struct, the
next example examines some kernel structs as well by observing the relationship between
the <tt>ksyms</tt>(7D) driver and <a href="http://docs.sun.com/doc/819-2241/read-2?a=view"><tt>read</tt>(2)</a> requests. The driver makes use of two common
structs, known as <tt>uio</tt>(9S) and <tt>iovec</tt>(9S), to respond to requests to read from
the character device file <tt>/dev/ksyms</tt>.</p><p>The <tt>uio</tt> struct, accessed using the name <tt>struct uio</tt> or type alias <tt>uio_t</tt>,
is described in the <tt>uio</tt>(9S) man page and is used to describe an
I/O request that involves copying data between the kernel and a user
process. The <tt>uio</tt> in turn contains an array of one or more <tt>iovec</tt>(9S)
structures which each describe a piece of the requested I/O, in the event
that multiple chunks are requested using the <a href="http://docs.sun.com/doc/819-2241/readv-2?a=view"><tt>readv</tt>(2)</a> or <a href="http://docs.sun.com/doc/819-2241/writev-2?a=view"><tt>writev</tt>(2)</a> system calls. One
of the kernel device driver interface (DDI) routines that operates on <tt>struct uio</tt> is the
function <tt>uiomove</tt>(9F), which is one of a family of functions kernel drivers use
to respond to user process <a href="http://docs.sun.com/doc/819-2241/read-2?a=view"><tt>read</tt>(2)</a> requests and copy data back to user processes.</p><p>The <tt>ksyms</tt> driver manages a character device file named <tt>/dev/ksyms</tt>, which appears to
be an ELF file containing information about the kernel's symbol table, but is
in fact an illusion created by the driver using the set of modules
that are currently loaded into the kernel. The driver uses the <tt>uiomove</tt>(9F) routine to
respond to <a href="http://docs.sun.com/doc/819-2241/read-2?a=view"><tt>read</tt>(2)</a> requests. The next example illustrates that the arguments and calls
to <a href="http://docs.sun.com/doc/819-2241/read-2?a=view"><tt>read</tt>(2)</a> from <tt>/dev/ksyms</tt> match the calls by the driver to <tt>uiomove</tt>(9F) to copy
the results back into the user address space at the location specified to
<a href="http://docs.sun.com/doc/819-2241/read-2?a=view"><tt>read</tt>(2)</a>.</p><p>We can use the <a href="http://docs.sun.com/doc/819-2239/strings-1?a=view"><tt>strings</tt>(1)</a> utility with the <tt>-a</tt> option to force a
bunch of reads from <tt>/dev/ksyms</tt>. Try running <tt>strings -a /dev/ksyms</tt> in your shell and see
what output it produces. In an editor, type in the first clause of
the example script and save it in a file named <tt>ksyms.d</tt>:</p><pre>syscall::read:entry
/curpsinfo-&gt;pr_psargs == "strings -a /dev/ksyms"/
{
    printf("read %u bytes to user address %x\n", arg2, arg1);
}</pre><p>This first clause uses the expression <tt>curpsinfo-&gt;pr_psargs</tt> to access and match the command-line
arguments of our <a href="http://docs.sun.com/doc/819-2239/strings-1?a=view"><tt>strings</tt>(1)</a> command so that the script selects the correct <a href="http://docs.sun.com/doc/819-2241/read-2?a=view"><tt>read</tt>(2)</a>
requests before tracing the arguments. Notice that by using operator <tt>==</tt> with a left-hand
argument that is an array of <tt>char</tt> and a right-hand argument that is
a string, the D compiler infers that the left-hand argument should be promoted
to a string and a string comparison should be performed. Type in and
execute the command <tt>dtrace -q -s ksyms.d</tt> in one shell, and then type in the command
<tt>strings -a /dev/ksyms</tt> in another shell. As <a href="http://docs.sun.com/doc/819-2239/strings-1?a=view"><tt>strings</tt>(1)</a> executes, you will see output from DTrace similar
to the following example:</p><pre><tt><b># dtrace -q -s ksyms.d</b></tt>
read 8192 bytes to user address 80639fc
read 8192 bytes to user address 80639fc
read 8192 bytes to user address 80639fc
read 8192 bytes to user address 80639fc
...
<tt><b>^C</b></tt>
#</pre><p>This example can be extended using a common D programming technique to follow
a thread from this initial <a href="http://docs.sun.com/doc/819-2241/read-2?a=view"><tt>read</tt>(2)</a> request deeper into the kernel. Upon
entry to the kernel in <tt>syscall::read:entry</tt>, the next script sets a thread-local flag variable
indicating this thread is of interest, and clears this flag on <tt>syscall::read:return</tt>. Once
the flag is set, it can be used as a predicate on other
probes to instrument kernel functions such as <tt>uiomove</tt>(9F). The DTrace function boundary tracing
(<tt>fbt</tt>) provider publishes probes for entry and return to functions defined within the
kernel, including those in the DDI. Type in the following source code which
uses the <tt>fbt</tt> provider to instrument <tt>uiomove</tt>(9F) and again save it in the file
<tt>ksyms.d</tt>:</p><a name="ex-ksyms.d"></a><h6>Example&nbsp;7-2 <tt>ksyms.d</tt>: Trace <tt>read</tt>(2) and <tt>uiomove</tt>(9F) Relationship</h6><pre>/*
 * When our strings(1) invocation starts a read(2), set a watched flag on
 * the current thread.  When the read(2) finishes, clear the watched flag.
 */
syscall::read:entry
/curpsinfo-&gt;pr_psargs == "strings -a /dev/ksyms"/
{
    printf("read %u bytes to user address %x\n", arg2, arg1);
    self-&gt;watched = 1;
}

syscall::read:return
/self-&gt;watched/
{
    self-&gt;watched = 0;
}

/*
 * Instrument uiomove(9F).  The prototype for this function is as follows:
 * int uiomove(caddr_t addr, size_t nbytes, enum uio_rw rwflag, uio_t *uio);
 */
fbt::uiomove:entry
/self-&gt;watched/
{
    this-&gt;iov = args[3]-&gt;uio_iov;

    printf("uiomove %u bytes to %p in pid %d\n",
        this-&gt;iov-&gt;iov_len, this-&gt;iov-&gt;iov_base, pid);
}</pre><p>The final clause of the example uses the thread-local variable <tt>self-&gt;watched</tt> to
identify when a kernel thread of interest enters the DDI routine <tt>uiomove</tt>(9F).
Once there, the script uses the built-in <tt>args</tt> array to access the fourth
argument (<tt>args[3]</tt>) to <tt>uiomove()</tt>, which is a pointer to the <tt>struct uio</tt> representing the
request. The D compiler automatically associates each member of the <tt>args</tt> array with the
type corresponding to the C function prototype for the instrumented kernel routine. The
<tt>uio_iov</tt> member contains a pointer to the <tt>struct iovec</tt> for the request. A copy
of this pointer is saved for use in our clause in the clause-local
variable <tt>this-&gt;iov</tt>. In the final statement, the script dereferences <tt>this-&gt;iov</tt> to access the <tt>iovec</tt>
members <tt>iov_len</tt> and <tt>iov_base</tt>, which represent the length in bytes and destination
base address for <tt>uiomove</tt>(9F), respectively. These values should match the input parameters to the
<a href="http://docs.sun.com/doc/819-2241/read-2?a=view"><tt>read</tt>(2)</a> system call issued on the driver. Go to your shell and run
<tt>dtrace -q -s ksyms.d</tt> and then again enter the command <tt>strings -a /dev/ksyms</tt> in another shell. You should see
output similar to the following example:</p><pre><tt><b># dtrace -q -s ksyms.d</b></tt>
read 8192 bytes at user address 80639fc
uiomove 8192 bytes to 80639fc in pid 101038
read 8192 bytes at user address 80639fc
uiomove 8192 bytes to 80639fc in pid 101038
read 8192 bytes at user address 80639fc
uiomove 8192 bytes to 80639fc in pid 101038
read 8192 bytes at user address 80639fc
uiomove 8192 bytes to 80639fc in pid 101038
...
<tt><b>^C</b></tt>
#</pre><p>The addresses and process IDs will be different in your output, but you
should observe that the input arguments to <a href="http://docs.sun.com/doc/819-2241/read-2?a=view"><tt>read</tt>(2)</a> match the parameters passed
to <tt>uiomove</tt>(9F) by the <tt>ksyms</tt> driver.</p>
         </div>
      </td>
   </tr>

   <tr class="PageControls" valign="top">
      <td></td>
      <td>
         <table width="100%">
      	   <tr>
      	     <td>
                 <a href="chp-structs-1.html">Previous</a>
             </td>
             <td align="right">
                 <a href="chp-structs-3.html">Next</a>
             </td>
           </tr>
         </table>
      </td>
   </tr>
</tbody>
</table>


</body>
</html>

