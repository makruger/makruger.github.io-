<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="en-US">
<head>
<meta http-equiv="Content-type" content="text/html; charset=iso-8859-1">
<title>Probes - Solaris Dynamic Tracing Guide</title>
<meta name="robots" content="index,follow">
<meta name="robots" content="index,follow">
<meta name="date" content="2008-11-01">
<meta name="collection" content="reference">
<link rel="stylesheet" type="text/css" href="css/elements.css">
<link rel="stylesheet" type="text/css" href="css/indiana.css">
</head>

<body>


<div class="Masthead">
   <div class="MastheadLogo">
      <a href="http://www.opensolaris.org"><img border="0" src="graphics/header.png"></img></a>
   </div>
   <div class="Title">Solaris Dynamic Tracing Guide</div>
</div>

<table class="Layout" border="0" cellspacing="0" width="100%">
<tbody>

   <tr valign="top" class="PageControls">
      <td></td>
      <td>
         <table width="100%">
      	   <tr>
      	     <td>
                 <a href="chp-mib.html">Previous</a>
             </td>
             <td align="right">
                 <a href="chp-mib-1.html">Next</a>
             </td>
           </tr>
         </table>
      </td>
   </tr>
   
   <tr valign="top">
      <td class="Navigation" width="200px"><p class="toc level1"><a href="docinfo.html">Document Information</a></p>
<p class="toc level1 tocsp"><a href="preface.html">Preface</a></p>
<p class="toc level1 tocsp"><a href="chp-intro.html">1.&nbsp;&nbsp;Introduction</a></p>
<p class="toc level1 tocsp"><a href="chp-typeopexpr.html">2.&nbsp;&nbsp;Types, Operators, and Expressions</a></p>
<p class="toc level1 tocsp"><a href="chp-variables.html">3.&nbsp;&nbsp;Variables</a></p>
<p class="toc level1 tocsp"><a href="chp-prog.html">4.&nbsp;&nbsp;D Program Structure</a></p>
<p class="toc level1 tocsp"><a href="chp-pointers.html">5.&nbsp;&nbsp;Pointers and Arrays</a></p>
<p class="toc level1 tocsp"><a href="chp-strings.html">6.&nbsp;&nbsp;Strings</a></p>
<p class="toc level1 tocsp"><a href="chp-structs.html">7.&nbsp;&nbsp;Structs and Unions</a></p>
<p class="toc level1 tocsp"><a href="chp-types.html">8.&nbsp;&nbsp;Type and Constant Definitions</a></p>
<p class="toc level1 tocsp"><a href="chp-aggs.html">9.&nbsp;&nbsp;Aggregations</a></p>
<p class="toc level1 tocsp"><a href="chp-actsub.html">10.&nbsp;&nbsp;Actions and Subroutines</a></p>
<p class="toc level1 tocsp"><a href="chp-buf.html">11.&nbsp;&nbsp;Buffers and Buffering</a></p>
<p class="toc level1 tocsp"><a href="chp-fmt.html">12.&nbsp;&nbsp;Output Formatting</a></p>
<p class="toc level1 tocsp"><a href="chp-spec.html">13.&nbsp;&nbsp;Speculative Tracing</a></p>
<p class="toc level1 tocsp"><a href="chp-dtrace1m.html">14.&nbsp;&nbsp;<tt>dtrace</tt>(1M) Utility</a></p>
<p class="toc level1 tocsp"><a href="chp-script.html">15.&nbsp;&nbsp;Scripting</a></p>
<p class="toc level1 tocsp"><a href="chp-opt.html">16.&nbsp;&nbsp;Options and Tunables</a></p>
<p class="toc level1 tocsp"><a href="chp-dtrace.html">17.&nbsp;&nbsp;<tt>dtrace</tt> Provider</a></p>
<p class="toc level1 tocsp"><a href="chp-lockstat.html">18.&nbsp;&nbsp;<tt>lockstat</tt> Provider</a></p>
<p class="toc level1 tocsp"><a href="chp-profile.html">19.&nbsp;&nbsp;<tt>profile</tt> Provider</a></p>
<p class="toc level1 tocsp"><a href="chp-fbt.html">20.&nbsp;&nbsp;<tt>fbt</tt> Provider</a></p>
<p class="toc level1 tocsp"><a href="chp-syscall.html">21.&nbsp;&nbsp;<tt>syscall</tt> Provider</a></p>
<p class="toc level1 tocsp"><a href="chp-sdt.html">22.&nbsp;&nbsp;<tt>sdt</tt> Provider</a></p>
<p class="toc level1 tocsp"><a href="chp-sysinfo.html">23.&nbsp;&nbsp;<tt>sysinfo</tt> Provider</a></p>
<p class="toc level1 tocsp"><a href="chp-vminfo.html">24.&nbsp;&nbsp;<tt>vminfo</tt> Provider</a></p>
<p class="toc level1 tocsp"><a href="chp-proc.html">25.&nbsp;&nbsp;<tt>proc</tt> Provider</a></p>
<p class="toc level1 tocsp"><a href="chp-sched.html">26.&nbsp;&nbsp;<tt>sched</tt> Provider</a></p>
<p class="toc level1 tocsp"><a href="chp-io.html">27.&nbsp;&nbsp;<tt>io</tt> Provider</a></p>
<p class="toc level1 tocsp"><a href="chp-mib.html">28.&nbsp;&nbsp;<tt>mib</tt> Provider</a></p>
<div class="onpage">
<p class="toc level2"><a href="">Probes</a></p>
</div>
<p class="toc level2"><a href="chp-mib-1.html">Arguments</a></p>
<p class="toc level2"><a href="chp-mib-stability.html">Stability</a></p>
<p class="toc level1 tocsp"><a href="chp-fpuinfo.html">29.&nbsp;&nbsp;<tt>fpuinfo</tt> Provider</a></p>
<p class="toc level1 tocsp"><a href="chp-pid.html">30.&nbsp;&nbsp;<tt>pid</tt> Provider</a></p>
<p class="toc level1 tocsp"><a href="chp-plockstat.html">31.&nbsp;&nbsp;<tt>plockstat</tt> Provider</a></p>
<p class="toc level1 tocsp"><a href="chp-fasttrap.html">32.&nbsp;&nbsp;<tt>fasttrap</tt> Provider</a></p>
<p class="toc level1 tocsp"><a href="chp-user.html">33.&nbsp;&nbsp;User Process Tracing</a></p>
<p class="toc level1 tocsp"><a href="chp-usdt.html">34.&nbsp;&nbsp;Statically Defined Tracing for User Applications</a></p>
<p class="toc level1 tocsp"><a href="chp-sec.html">35.&nbsp;&nbsp;Security</a></p>
<p class="toc level1 tocsp"><a href="chp-anon.html">36.&nbsp;&nbsp;Anonymous Tracing</a></p>
<p class="toc level1 tocsp"><a href="chp-post.html">37.&nbsp;&nbsp;Postmortem Tracing</a></p>
<p class="toc level1 tocsp"><a href="chp-perf.html">38.&nbsp;&nbsp;Performance Considerations</a></p>
<p class="toc level1 tocsp"><a href="chp-stab.html">39.&nbsp;&nbsp;Stability</a></p>
<p class="toc level1 tocsp"><a href="chp-xlate.html">40.&nbsp;&nbsp;Translators</a></p>
<p class="toc level1 tocsp"><a href="chp-vers.html">41.&nbsp;&nbsp;Versioning</a></p>
<p class="toc level1 tocsp"><a href="gloss01.html">Glossary</a></p>
<p class="toc level1 tocsp"><a href="idx-1.html">Index</a></p>
</td>
      <td class="ContentPane" width="705px">

	 <div class="MainContent">      	 
             

<a name="chp-mib-probes"></a><h3>Probes</h3>
<p><a name="indexterm-415"></a><a name="indexterm-416"></a>The <tt>mib</tt> provider makes available probes for counters from several MIBs. The
protocols that export MIBs instrumented by the <tt>mib</tt> provider are listed in
<a href="#tbl-mib-mibs">Table&nbsp;28-1</a>. The table includes a reference to documentation that specifies some or
all of the MIB, the name of the kernel statistic that may
be used to access the running counts (using the <a href="http://docs.sun.com/doc/819-2240/kstat-1m?a=view"><tt>kstat</tt>(1M)</a> <tt>-n</tt> <i>statistic</i><tt></tt>
option), and a reference to the table that has a complete definition
of the probes. All MIB counters are also available through the <tt>-s</tt>
option to <a href="http://docs.sun.com/doc/819-2240/netstat-1m?a=view"><tt>netstat</tt>(1M)</a>.</p><a name="tbl-mib-mibs"></a><h6>Table&nbsp;28-1 <tt>mib</tt> probes</h6><table><col width="25%"><col width="25%"><col width="25%"><col width="25%"><tr><th align="left" valign="top" scope="column"><p>Protocol</p></th>
<th align="left" valign="top" scope="column"><p>MIB Description</p></th>
<th align="left" valign="top" scope="column"><p>Kernel Statistic</p></th>
<th align="left" valign="top" scope="column"><p><tt>mib</tt> Probes Table</p></th>
</tr>
<tr><td align="left" valign="top" scope="row"><p>ICMP</p></td>
<td align="left" valign="top" scope="row"><p>RFC 1213</p></td>
<td align="left" valign="top" scope="row"><p><tt>icmp</tt></p></td>
<td align="left" valign="top" scope="row"><p><a href="#tbl-mib-icmp">Table&nbsp;28-2</a></p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p>IP</p></td>
<td align="left" valign="top" scope="row"><p>RFC 1213</p></td>
<td align="left" valign="top" scope="row"><p><tt>ip</tt></p></td>
<td align="left" valign="top" scope="row"><p><a href="#tbl-mib-ip">Table&nbsp;28-3</a></p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p>IPsec</p></td>
<td align="left" valign="top" scope="row"><p>&mdash;</p></td>
<td align="left" valign="top" scope="row"><p><tt>ip</tt></p></td>
<td align="left" valign="top" scope="row"><p><a href="#tbl-mib-ipsec">Table&nbsp;28-4</a></p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p>IPv6</p></td>
<td align="left" valign="top" scope="row"><p>RFC 2465</p></td>
<td align="left" valign="top" scope="row"><p>&mdash;</p></td>
<td align="left" valign="top" scope="row"><p><a href="#tbl-mib-ipv6">Table&nbsp;28-5</a></p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p>SCTP</p></td>
<td align="left" valign="top" scope="row"><p>&ldquo;SCTP MIB&rdquo; (Internet
draft)</p></td>
<td align="left" valign="top" scope="row"><p><tt>sctp</tt></p></td>
<td align="left" valign="top" scope="row"><p><a href="#tbl-mib-sctp">Table&nbsp;28-7</a></p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p>TCP</p></td>
<td align="left" valign="top" scope="row"><p>RFC 1213</p></td>
<td align="left" valign="top" scope="row"><p><tt>tcp</tt></p></td>
<td align="left" valign="top" scope="row"><p><a href="#tbl-mib-tcp">Table&nbsp;28-8</a></p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p>UDP</p></td>
<td align="left" valign="top" scope="row"><p>RFC 1213</p></td>
<td align="left" valign="top" scope="row"><p><tt>udp</tt></p></td>
<td align="left" valign="top" scope="row"><p><a href="#tbl-mib-udp">Table&nbsp;28-9</a></p></td>
</tr>
</table><a name="tbl-mib-icmp"></a><h6>Table&nbsp;28-2 ICMP <tt>mib</tt> Probes</h6><table><col width="25%"><col width="75%"><tr><td align="left" valign="top" scope="row"><p><tt>icmpInAddrMaskReps</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe that fires whenever an ICMP Address Mask Reply message
is received.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>icmpInAddrMasks</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe that fires whenever an ICMP Address Mask Request message is
received.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>icmpInBadRedirects</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe that fires whenever an ICMP Redirect message is received that is
determined to be malformed in some way (unknown ICMP code, sender or
target off-link, and the like).</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>icmpInCksumErrs</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe that fires whenever an ICMP message with
a bad checksum is received.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>icmpInDestUnreachs</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe that fires whenever an ICMP Destination Unreachable
message is received.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>icmpInEchoReps</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe that fires whenever an ICMP Echo Reply message is
received.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>icmpInEchos</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe that fires whenever an ICMP Echo request message is received.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>icmpInErrors</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe that
fires whenever an ICMP message is received that is determined to have
an ICMP-specific error (bad ICMP checksum, bad length, etc.).</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>icmpInFragNeeded</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe that fires whenever
an ICMP Destination Unreachable (Fragmentation Needed) message is received, indicating that a
sent packet was lost because it was larger than some MTU and
the Don't Fragment flag was set.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>icmpInMsgs</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe that fires whenever an ICMP message
is received. Whenever this probe fires, the <tt>icmpInErrors</tt> probe may also fire
if the message is determined to have an ICMP-specific error.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>icmpInOverflows</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe that fires
whenever an ICMP message is received, but the message is subsequently dropped
due to lack of buffer space.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>icmpInParmProbs</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe that fires whenever an ICMP Parameter
Problem message is received.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>icmpInRedirects</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe that fires whenever an ICMP Redirect message is
received.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>icmpInSrcQuenchs</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe that fires whenever an ICMP Source Quench message is received.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>icmpInTimeExcds</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe that
fires whenever an ICMP Time Exceeded message is received.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>icmpInTimestampReps</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe that fires whenever
an ICMP Timestamp Reply message is received.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>icmpInTimestamps</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe that fires whenever an ICMP
Timestamp request message is received.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>icmpInUnknowns</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe that fires whenever an ICMP message of
unknown type is received.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>icmpOutAddrMaskReps</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe that fires whenever an ICMP Address Mask Reply
message is sent.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>icmpOutDestUnreachs</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe that fires whenever an ICMP Destination Unreachable message is
sent.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>icmpOutDrops</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe that fires whenever an outbound ICMP message is dropped for some
reason (such as memory allocation failure, broadcast/multicast source or destination, and the
like).</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>icmpOutEchoReps</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe that fires whenever an ICMP Echo Reply message is sent.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>icmpOutErrors</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe that
fires whenever an ICMP message is not sent due to problems discovered
within ICMP, such as a lack of buffers. This probe will not
fire if errors are discovered outside the ICMP layer, such as the
inability of IP to route the resulting datagram.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>icmpOutFragNeeded</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe that fires whenever an
ICMP Destination Unreachable (Fragmentation Needed) message is sent.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>icmpOutMsgs</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe that fires whenever an
ICMP message is sent. Whenever this probe fires, the <tt>icmpOutErrors</tt> probe might
also fire if the message is determined to have ICMP-specific errors.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>icmpOutParmProbs</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe that
fires whenever an ICMP Parameter Problem message is sent.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>icmpOutRedirects</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe that fires whenever
an ICMP Redirect message is sent. For a host, this probe will
never fire, because hosts do not send redirects.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>icmpOutTimeExcds</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe that fires whenever an
ICMP Time Exceeded message is sent.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>icmpOutTimestampReps</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe that fires whenever an ICMP Timestamp
Reply message is sent.</p></td>
</tr>
</table><a name="tbl-mib-ip"></a><h6>Table&nbsp;28-3 IP <tt>mib</tt> Probes</h6><table><col width="25%"><col width="75%"><tr><td align="left" valign="top" scope="row"><p><tt>ipForwDatagrams</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe that fires whenever a datagram is received that
does not have this machine as its final IP destination, and an
attempt is made to find a route to forward the datagram to
that final destination. On machines that do not act as IP gateways,
this probe will only fire for those packets that are source-routed through
this machine, and for which the source-route option processing was successful.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>ipForwProhibits</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe that
fires whenever a datagram is received that does not have this machine
as its final IP destination, but because the machine is not permitted
to act as a router, no attempt is made to find a
route to forward the datagram to that final destination.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>ipFragCreates</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe that fires whenever
an IP datagram fragment is generated as a result of fragmentation.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>ipFragFails</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe that
fires whenever an IP datagram is discarded because it could not be
fragmented, for example, because fragmentation was required and the Don't Fragment flag
was set.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>ipFragOKs</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe that fires whenever an IP datagram has been successfully fragmented.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>ipInCksumErrs</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe
that fires whenever an input datagram is discarded due to a bad
IP header checksum.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>ipInDelivers</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe that fires whenever an input datagram is successfully delivered
to IP user protocols, including ICMP.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>ipInDiscards</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe that fires whenever an input IP
datagram is discarded for reasons unrelated to the packet (for example, for
lack of buffer space). This probe does not fire for any datagram
discarded while awaiting reassembly.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>ipInHdrErrors</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe that fires whenever an input datagram is discarded
due to an error in its IP header, including a version number
mismatch, a format error, an exceeded time-to-live, an error discovered in processing
IP options, and the like.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>ipInIPv6</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe that fires whenever an IPv6 packet erroneously
arrives on an IPv4 queue.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>ipInReceives</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe that fires whenever a datagram is received
from an interface, even if that datagram is received in error.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>ipInUnknownProtos</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe that
fires whenever a locally addressed datagram is received successfully but subsequently discarded
because of an unknown or unsupported protocol.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>ipOutDiscards</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe that fires whenever an output
IP datagram is discarded for reasons unrelated to the packet (for example,
for lack of buffer space). This probe will fire for a packet
counted in the <tt>ipForwDatagrams</tt> MIB counter if the packet meets such a
(discretionary) discard criterion.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>ipOutIPv6</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe that fires whenever an IPv6 packet is sent over
an IPv4 connection.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>ipOutNoRoutes</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe that fires whenever an IP datagram is discarded because
no route could be found to transmit it to its destination. This
probe will fire for a packet counted in the <tt>ipForwDatagrams</tt> MIB counter
if the packet meets this &ldquo;no-route&rdquo; criterion. This probe will also fire
for any datagrams which cannot be routed because all default gateways are
down.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>ipOutRequests</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe that fires whenever an IP datagram is supplied to IP for
transmission from local IP user protocols (include ICMP). Note that this probe
will not fire for any packet counted in the <tt>ipForwDatagrams</tt> MIB counter.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>ipOutSwitchIPv6</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe
that fires whenever a connection changes from using IPv4 to using IPv6
as its IP protocol.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>ipReasmDuplicates</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe that fires whenever the IP reassembly algorithm determines
that an IP fragment contains <b>only</b> previously received data.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>ipReasmFails</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe that fires whenever
any failure is detected by the IP reassembly algorithm. This probe does
not necessarily fire for every discarded IP fragment because some algorithms, notably
the algorithm in RFC 815, can lose track of fragments by combining
them as they are received.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>ipReasmOKs</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe that fires whenever an IP datagram is
successfully reassembled.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>ipReasmPartDups</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe that fires whenever the IP reassembly algorithm determines that an
IP fragment contains both some previously received data and some new data.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>ipReasmReqds</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe
that fires whenever an IP fragment is received that needs to be
reassembled.</p></td>
</tr>
</table><a name="tbl-mib-ipsec"></a><h6>Table&nbsp;28-4 IPsec <tt>mib</tt> Probes</h6><table><col width="25%"><col width="75%"><tr><td align="left" valign="top" scope="row"><p><tt>ipsecInFailed</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe that fires whenever a received packet is dropped because it fails
to match the specified IPsec policy.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>ipsecInSucceeded</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe that fires whenever a received packet
matches the specified IPsec policy and processing is allowed to continue.</p></td>
</tr>
</table><a name="tbl-mib-ipv6"></a><h6>Table&nbsp;28-5 IPv6 <tt>mib</tt> Probes</h6><table><col width="50%"><col width="50%"><tr><td align="left" valign="top" scope="row"><p><tt>ipv6ForwProhibits</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe that
fires whenever an IPv6 datagram is received that does not have this
machine as its final IPv6 destination, but because the machine is not
permitted to act as a router, no attempt is made to find
a route to forward the datagram to that final destination.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>ipv6IfIcmpBadHoplimit</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe that fires
whenever an ICMPv6 neighbor discovery protocol message is received that is found
to have a Hop Limit less than the defined maximum. Such messages
might not have originated from a neighbor, and are therefore discarded.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>ipv6IfIcmpInAdminProhibs</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe that
fires whenever an ICMPv6 Destination Unreachable (Communication Administratively Prohibited) message is received.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>ipv6IfIcmpInBadNeighborAdvertisements</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe
that fires whenever an ICMPv6 Neighbor Advertisement message is received that is
malformed in some way.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>ipv6IfIcmpInBadNeighborSolicitations</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe that fires whenever an ICMPv6 Neighbor Solicit message
is received that is malformed in some way.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>ipv6IfIcmpInBadRedirects</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe that fires whenever an
ICMPv6 Redirect message is received that is malformed in some way.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>ipv6IfIcmpInDestUnreachs</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe that
fires whenever an ICMPv6 Destination Unreachable message is received.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>ipv6IfIcmpInEchoReplies</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe that fires whenever
an ICMPv6 Echo Reply message is received.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>ipv6IfIcmpInEchos</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe that fires whenever an ICMPv6
Echo request message is received.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>ipv6IfIcmpInErrors</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe that fires whenever an ICMPv6 message is
received that is determined to have an ICMPv6-specific error (such as bad
ICMPv6 checksum, bad length, and the like).</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>ipv6IfIcmpInGroupMembBadQueries</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe that fires whenever an ICMPv6
Group Membership Query message is received that is malformed in some way.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>ipv6IfIcmpInGroupMembBadReports</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe
that fires whenever an ICMPv6 Group Membership Report message is received that
is malformed in some way.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>ipv6IfIcmpInGroupMembOurReports</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe that fires whenever an ICMPv6 Group Membership
Report message is received.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>ipv6IfIcmpInGroupMembQueries</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe that fires whenever an ICMPv6 Group Membership Query
message is received.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>ipv6IfIcmpInGroupMembReductions</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe that fires whenever an ICMPv6 Group Membership Reduction message
is received.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>ipv6IfIcmpInGroupMembResponses</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe that fires whenever an ICMPv6 Group Membership Response message is
received.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>ipv6IfIcmpInGroupMembTotal</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe that fires whenever an ICMPv6 multicast listener discovery message is received.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>ipv6IfIcmpInMsgs</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe
that fires whenever an ICMPv6 message is received. When this probe fires,
the <tt>ipv6IfIcmpInErrors</tt> probe might also fire if the message has an ICMPv6-specific
error.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>ipv6IfIcmpInNeighborAdvertisements</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe that fires whenever an ICMPv6 Neighbor Advertisement message is received.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>ipv6IfIcmpInNeighborSolicits</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe that
fires whenever an ICMPv6 Neighbor Solicit message is received.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>ipv6IfIcmpInOverflows</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe that fires whenever
an ICMPv6 message is received, but that message is subsequently dropped due
to lack of buffer space.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>ipv6IfIcmpInParmProblems</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe that fires whenever an ICMPv6 Parameter Problem
message is received.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>ipv6IfIcmpInRedirects</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe that fires whenever an ICMPv6 Redirect message is received.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>ipv6IfIcmpInRouterAdvertisements</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe
that fires whenever an ICMPv6 Router Advertisement message is received.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>ipv6IfIcmpInRouterSolicits</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe that fires
whenever an ICMPv6 Router Solicit message is received.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>ipv6IfIcmpInTimeExcds</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe that fires whenever an
ICMPv6 Time Exceeded message is received.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>ipv6IfIcmpOutAdminProhibs</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe that fires whenever an ICMPv6 Destination
Unreachable (Communication Administratively Prohibited) message is sent.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>ipv6IfIcmpOutDestUnreachs</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe that fires whenever an ICMPv6
Destination Unreachable message is sent.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>ipv6IfIcmpOutEchoReplies</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe that fires whenever an ICMPv6 Echo Reply
message is sent.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>ipv6IfIcmpOutEchos</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe that fires whenever an ICMPv6 Echo message is sent.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>ipv6IfIcmpOutErrors</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe
that fires whenever an ICMPv6 message is not sent due to problems
discovered within ICMPv6, such as a lack of buffers. This probe will
not fire if errors are discovered outside the ICMPv6 layer, such as
the inability of IPv6 to route the resulting datagram.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>ipv6IfIcmpOutGroupMembQueries</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe that fires whenever
an ICMPv6 Group Membership Query message is sent.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>ipv6IfIcmpOutGroupMembReductions</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe that fires whenever an
ICMPv6 Group Membership Reduction message is sent.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>ipv6IfIcmpOutGroupMembResponses</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe that fires whenever an ICMPv6
Group Membership Response message is sent.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>ipv6IfIcmpOutMsgs</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe that fires whenever an ICMPv6 message
is sent. When this probe fires, the <tt>ipv6IfIcmpOutErrors</tt> probe might also fire
if the message has ICMPv6-specific errors.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>ipv6IfIcmpOutNeighborAdvertisements</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe that fires whenever an ICMPv6 Neighbor
Advertisement message is sent.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>ipv6IfIcmpOutNeighborSolicits</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe that fires whenever an ICMPv6 Neighbor Solicitation message
is sent.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>ipv6IfIcmpOutParmProblems</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe that fires whenever an ICMPv6 Parameter Problem message is sent.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>ipv6IfIcmpOutPktTooBigs</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe
that fires whenever an ICMPv6 Packet Too Big message is sent.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>ipv6IfIcmpOutRedirects</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe that
fires whenever an ICMPv6 Redirect message is sent. For a host, this
probe will never fire, because hosts do not send redirects.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>ipv6IfIcmpOutRouterAdvertisements</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe that fires
whenever an ICMPv6 Router Advertisement message is sent.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>ipv6IfIcmpOutRouterSolicits</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe that fires whenever an
ICMPv6 Router Solicit message is sent.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>ipv6IfIcmpOutTimeExcds</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe that fires whenever an ICMPv6 Time
Exceeded message is sent.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>ipv6InAddrErrors</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe that fires whenever an input datagram is discarded
because the IPv6 address in their IPv6 header's destination field is not
a valid address to be received by this entity. This probe will
fire for invalid addresses (for example, ::0) and for unsupported addresses (for
example, addresses with unallocated prefixes). For machines that are not configured to
act as IPv6 routers and therefore do not forward datagrams, this probe
will fire for datagrams discarded because the destination address was not a
local address.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>ipv6InDelivers</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe that fires whenever an input datagram is successfully delivered to
IPv6 user-protocols (including ICMPv6).</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>ipv6InDiscards</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe that fires whenever an input IPv6 datagram is
discarded for reasons unrelated to the packet (for example, for lack of
buffer space). This probe does not fire for any datagram discarded while
awaiting reassembly.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>ipv6InHdrErrors</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe that fires whenever an input datagram is discarded due to
an error in its IPv6 header, including a version number mismatch, a
format error, an exceeded hop count, an error discovered in processing IPv6
options, and the like.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>ipv6InIPv4</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe that fires whenever an IPv4 packet erroneously arrives
on an IPv6 queue.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>ipv6InMcastPkts</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe that fires whenever a multicast IPv6 packet is
received.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>ipv6InNoRoutes</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe that fires whenever a routed IPv6 datagram is discarded because no
route could be found to transmit it to its destination. This probe
will <b>only</b> fire for packets that have originated externally.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>ipv6InReceives</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe that fires whenever
an IPv6 datagram is received from an interface, even if that datagram
is received in error.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>ipv6InTooBigErrors</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe that fires whenever a fragment is received that
is larger than the maximum fragment size.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>ipv6InTruncatedPkts</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe that fires whenever an input
datagram is discarded because the datagram frame didn't carry enough data.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>ipv6InUnknownProtos</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe that
fires whenever a locally-addressed IPv6 datagram is received successfully but subsequently discarded
because of an unknown or unsupported protocol.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>ipv6OutDiscards</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe that fires whenever an output
IPv6 datagram is discarded for reasons unrelated to the packet (for example,
for lack of buffer space). This probe will fire for a packet
counted in the <tt>ipv6OutForwDatagrams</tt> MIB counter if the packet meets such a
(discretionary) discard criterion.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>ipv6OutForwDatagrams</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe that fires whenever a datagram is received that does
not have this machine as its final IPv6 destination, and an attempt
is made to find a route to forward the datagram to that
final destination. On a machine that does not act as an IPv6
router, this probe will only fire for those packets that are source-routed
through the machine, and for which the source-route option processing was successful.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>ipv6OutFragCreates</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe
that fires whenever an IPv6 datagram fragment is generated as a result
of fragmentation.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>ipv6OutFragFails</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe that fires whenever an IPv6 datagram is discarded because it
could not be fragmented, for example, because its Don't Fragment flag was
set.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>ipv6OutFragOKs</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe that fires whenever an IPv6 datagrams has been successfully fragmented.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>ipv6OutIPv4</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe that
fires whenever an IPv6 packet is sent over an IPv4 connection.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>ipv6OutMcastPkts</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe that
fires whenever a multicast packet is sent.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>ipv6OutNoRoutes</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe that fires whenever an IPv6
datagram is discarded because no route could be found to transmit it
to its destination. This probe will <b>not</b> fire for packets that have
originated externally.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>ipv6OutRequests</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe that fires whenever an IPv6 datagram is supplied to IPv6
for transmission from local IPv6 user protocols (including ICMPv6). This probe will
not fire for any packet counted in the <tt>ipv6ForwDatagrams</tt> MIB counter.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>ipv6OutSwitchIPv4</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe that
fires whenever a connection changes from using IPv6 to using IPv4 as
its IP protocol.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>ipv6ReasmDuplicates</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe that fires whenever the IPv6 reassembly algorithm determines that
an IPv6 fragment contains <b>only</b> previously received data.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>ipv6ReasmFails</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe that fires whenever a
failure is detected by the IPv6 reassembly algorithm. This probe does not
necessarily fire for every discarded IPv6 fragment since some algorithms can lose
track of fragments by combining them as they are received.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>ipv6ReasmOKs</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe that fires
whenever an IPv6 datagram is successfully reassembled.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>ipv6ReasmPartDups</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe that fires whenever the IPv6
reassembly algorithm determines that an IPv6 fragment contains both some previously received
data and some new data.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>ipv6ReasmReqds</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe that fires whenever an IPv6 fragment is
received that needs to be reassembled.</p></td>
</tr>
</table><a name="tbl-mib-rawip"></a><h6>Table&nbsp;28-6 Raw IP <tt>mib</tt> Probes</h6><table><col width="25%"><col width="75%"><tr><td align="left" valign="top" scope="row"><p><tt>rawipInCksumErrs</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe that fires whenever a raw IP
packet is received that has a bad IP checksum.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>rawipInDatagrams</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe that fires whenever
a raw IP packet is received.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>rawipInErrors</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe that fires whenever a raw IP
packet is received that is malformed in some way.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>rawipInOverflows</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe that fires whenever
a raw IP packet is received, but that packet is subsequently dropped
due to lack of buffer space.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>rawipOutDatagrams</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe that fires whenever a raw IP
packet is sent.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>rawipOutErrors</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe that fires whenever a raw IP packet is not
sent due to some error condition, typically because the raw IP packet
was malformed in some way.</p></td>
</tr>
</table><a name="tbl-mib-sctp"></a><h6>Table&nbsp;28-7 SCTP <tt>mib</tt> Probes</h6><table><col width="25%"><col width="75%"><tr><td align="left" valign="top" scope="row"><p><tt>sctpAborted</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe that fires whenever an SCTP association has
made a direct transition to the CLOSED state from any state using
the ABORT primitive, denoting ungraceful termination of the association.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>sctpActiveEstab</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe that fires whenever
an SCTP association has made a direct transition to the ESTABLISHED state
from the COOKIE-ECHOED state, denoting that the upper layer has initiated the
association attempt.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>sctpChecksumError</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe that fires whenever an SCTP packet is received from peers
with an invalid checksum.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>sctpCurrEstab</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe that fires whenever an SCTP association is tallied
as a part of reading the <tt>sctpCurrEstab</tt> MIB counter. An SCTP association
is tallied if its current state is ESTABLISHED, SHUTDOWN-RECEIVED, or SHUTDOWN-PENDING.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>sctpFragUsrMsgs</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe that
fires whenever a user message has to be fragmented because of the
MTU.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>sctpInClosed</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe that fires whenever data is received on a closed SCTP association.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>sctpInCtrlChunks</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe
that fires whenever the <tt>sctpInCtrlChunks</tt> MIB counter is updated, either because the
MIB counter is explicitly queried or because an SCTP connection is closed.
The value by which the MIB counter is to be increased is
in <tt>args[0]</tt>.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>sctpInDupAck</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe that fires whenever a duplicate ACK is received.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>sctpInInvalidCookie</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe that fires
whenever an invalid cookie is received.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>sctpInOrderChunks</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe that fires whenever the <tt>sctpInOrderChunks</tt> MIB
counter is updated, either because the MIB counter is explicitly queried or
because an SCTP connection is closed. The value by which the MIB
counter is to be increased is in <tt>args[0]</tt>.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>sctpInSCTPPkts</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe that fires whenever the
<tt>sctpInSCTPPkts</tt> MIB counter is updated, either because the MIB counter is explicitly
queried or because an SCTP connection is closed. The value by which
the MIB counter is to be increased is in <tt>args[0]</tt>.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>sctpInUnorderChunks</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe that fires
whenever the <tt>sctpInUnorderChunks</tt> MIB counter is updated, either because the MIB counter
is explicitly queried or because an SCTP connection is closed. The value
by which the MIB counter is to be increased is in <tt>args[0]</tt>.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>sctpListenDrop</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe
that fires whenever an incoming connection is dropped for any reason.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>sctpOutAck</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe that
fires whenever a selective acknowledgement is sent.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>sctpOutAckDelayed</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe that fires whenever delayed acknowledgement
processing is performed for an SCTP association. Any acknowledgements sent as a
part of delayed acknowledgement processing will cause the <tt>sctpOutAck</tt> probe to fire.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>sctpOutCtrlChunks</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe
that fires whenever the <tt>sctpOutCtrlChunks</tt> MIB counter is updated, either because the
MIB counter is explicitly queried or because an SCTP connection is closed.
The value by which the MIB counter is to be increased is
in <tt>args[0]</tt>.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>sctpOutOfBlue</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe that fires whenever an otherwise correct SCTP packet is received
for which the receiver is not able to identify the association to
which the packet belongs.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>sctpOutOrderChunks</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe that fires whenever the <tt>sctpOutOrderChunks</tt> MIB counter is
updated, either because the MIB counter is explicitly queried or because an
SCTP connection is closed. The value by which the MIB counter is
to be increased is in <tt>args[0]</tt>.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>sctpOutSCTPPkts</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe that fires whenever the <tt>sctpOutSCTPPkts</tt> MIB
counter is updated, either because the MIB counter is explicitly queried or
because an SCTP connection is closed. The value by which the MIB
counter is to be increased is in <tt>args[0]</tt>.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>sctpOutUnorderChunks</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe that fires whenever the
<tt>sctpOutUnorderChunks</tt> MIB counter is updated, either because the MIB counter is explicitly
queried or because an SCTP connection is closed. The value by which
the MIB counter is to be increased is in <tt>args[0]</tt>.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>sctpOutWinProbe</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe that fires
whenever a window probe is sent.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>sctpOutWinUpdate</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe that fires whenever a window update
is sent.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>sctpPassiveEstab</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe that fires whenever SCTP associations have made a direct transition
to the ESTABLISHED state from the CLOSED state. The remote endpoint has
initiated the association attempt.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>sctpReasmUsrMsgs</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe that fires whenever the <tt>sctpReasmUsrMsgs</tt> MIB counter is
updated, either because the MIB counter is explicitly queried or because an
SCTP connection is closed. The value by which the MIB counter is
to be increased is in <tt>args[0]</tt>.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>sctpRetransChunks</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe that fires whenever the <tt>sctpRetransChunks</tt> MIB
counter is updated, either because the MIB counter is explicitly queried or
because an SCTP connection is closed. The value by which the MIB
counter is to be increased is in <tt>args[0]</tt>.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>sctpShutdowns</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe that fires whenever an
SCTP association makes the direct transition to the CLOSED state from either
the SHUTDOWN-SENT state or the SHUTDOWN-ACK-SENT state, denoting graceful termination of the
association.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>sctpTimHeartBeatDrop</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe that fires whenever an SCTP association is aborted due to failure
to receive a heartbeat acknowledgement.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>sctpTimHeartBeatProbe</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe that fires whenever an SCTP heartbeat is
sent.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>sctpTimRetrans</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe that fires whenever timer-based retransmit processing is performed on an association.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>sctpTimRetransDrop</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe
that fires whenever prolonged failure to perform timer-based retransmission results in the
association being aborted.</p></td>
</tr>
</table><a name="tbl-mib-tcp"></a><h6>Table&nbsp;28-8 TCP <tt>mib</tt> Probes</h6><table><col width="25%"><col width="75%"><tr><td align="left" valign="top" scope="row"><p><tt>tcpActiveOpens</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe that fires whenever a TCP connection makes a direct
transition from the CLOSED state to the SYN_SENT state.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>tcpAttemptFails</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe that fires whenever
a TCP connection makes a direct transition to the CLOSED state from
either the SYN_SENT state or the SYN_RCVD state and whenever a TCP
connection makes a direct transition to the LISTEN state from the SYN_RCVD
state.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>tcpCurrEstab</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe that fires whenever a TCP connection is tallied as a part
of reading the <tt>tcpCurrEstab</tt> MIB counter. A TCP connection is tallied if
its current state is either ESTABLISHED or CLOSE_WAIT.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>tcpEstabResets</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe that fires whenever a
TCP connection makes the direct transition to the CLOSED state from either
the ESTABLISHED state or the CLOSE_WAIT state.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>tcpHalfOpenDrop</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe that fires whenever a connection
is dropped due to a full queue of connections in the SYN_RCVD
state.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>tcpInAckBytes</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe that fires whenever an ACK is received for previously sent data.
The number of bytes acknowledged is passed in <tt>args[0]</tt>.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>tcpInAckSegs</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe that fires whenever
an ACK is received for a previously sent segment.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>tcpInAckUnsent</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe that fires whenever
an ACK is received for an unsent segment.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>tcpInClosed</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe that fires whenever data
was received for a connection in a closing state.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>tcpInDataDupBytes</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe that fires whenever
a segment is received such that all data in the segment has
been previously received. The number of bytes in the duplicated segment is
passed in <tt>args[0]</tt>.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>tcpInDataDupSegs</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe that fires whenever a segment is received such that
all data in the segment has been previously received. The number of
bytes in the duplicated segment is passed in <tt>args[0]</tt>.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>tcpInDataInorderBytes</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe that fires whenever
data is received such that <b>all</b> data prior to the new data's
sequence number has been previously received. The number of bytes received in-order
is passed in <tt>args[0]</tt>.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>tcpInDataInorderSegs</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe that fires whenever a segment is received such
that <b>all</b> data prior to the new segment's sequence number has been
previously received.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>tcpInDataPartDupBytes</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe that fires whenever a segment is received such that some
of the data in the segment has been previously received, but some
of the data in the segment is new. The number of duplicate
bytes is passed in <tt>args[0]</tt>.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>tcpInDataPartDupSegs</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe that fires whenever a segment is received
such that some of the data in the segment has been previously
received, but some of the data in the segment is new. The
number of duplicate bytes is passed in <tt>args[0]</tt>.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>tcpInDataPastWinBytes</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe that fires whenever data
is received that lies past the current receive window. The number of
bytes is in <tt>args[0]</tt>.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>tcpInDataPastWinSegs</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe that fires whenever a segment is received that
lies past the current receive window.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>tcpInDataUnorderBytes</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe that fires whenever data is received
such that some data prior to the new data's sequence number is
missing. The number of bytes received unordered is passed in <tt>args[0]</tt>.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>tcpInDataUnorderSegs</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe that
fires whenever a segment is received such that some data prior to
the new data's sequence number is missing.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>tcpInDupAck</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe that fires whenever a duplicate
ACK is received.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>tcpInErrs</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe that fires whenever a TCP error (for example, a
bad TCP checksum) is found on a received segment.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>tcpInSegs</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe that fires whenever
a segment is received, even if that segment is later found to
have an error that prevents further processing.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>tcpInWinProbe</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe that fires whenever a window
probe is received.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>tcpInWinUpdate</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe that fires whenever a window update is received.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>tcpListenDrop</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe that
fires whenever an incoming connection is dropped due to a full listen
queue.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>tcpListenDropQ0</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe that fires whenever a connection is dropped due to a full
queue of connections in the SYN_RCVD state.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>tcpOutAck</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe that fires whenever an ACK
is sent.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>tcpOutAckDelayed</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe that fires whenever an ACK is sent after having been
initially delayed.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>tcpOutControl</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe that fires whenever a SYN, FIN, or RST is sent.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>tcpOutDataBytes</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe
that fires whenever data is sent. The number of bytes sent is
in <tt>args[0]</tt>.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>tcpOutDataSegs</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe that fires whenever a segment is sent.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>tcpOutFastRetrans</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probes that fires whenever
a segment is retransmitted as part of the fast retransmit algorithm.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>tcpOutRsts</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe that
fires whenever a segment is sent with the RST flag set.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>tcpOutSackRetransSegs</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe that
fires whenever a segment is retransmitted on a connection that has selective
acknowledgement enabled.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>tcpOutSegs</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe that fires whenever a segment is sent that contains at
least one non-retransmitted byte.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>tcpOutUrg</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe that fires whenever a segment is sent with
the URG flag set, and with a valid urgent pointer.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>tcpOutWinProbe</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe that fires
whenever a window probe is sent.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>tcpOutWinUpdate</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe that fires whenever a window update
is sent.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>tcpPassiveOpens</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe that fires whenever a TCP connections have made a direct
transition to the SYN_RCVD state from the LISTEN state.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>tcpRetransBytes</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe that fires whenever
data is retransmitted. The number of bytes retransmitted is in <tt>args[0]</tt>.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>tcpRetransSegs</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe that
fires whenever a segment is sent that contains one or more retransmitted
bytes.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>tcpRttNoUpdate</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe that fires whenever data was received, but there was no timestamp
information available with which to update the RTT.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>tcpRttUpdate</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe that fires whenever data
was received containing the timestamp information necessary to update the RTT.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>tcpTimKeepalive</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe that
fires whenever timer-based keep-alive processing is performed on a connection.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>tcpTimKeepaliveDrop</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe that fires
whenever keep-alive processing results in termination of a connection.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>tcpTimKeepaliveProbe</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe that fires whenever
a keep-alive probe is sent out as a part of keep-alive processing.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>tcpTimRetrans</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe
that fires whenever timer-based retransmit processing is performed on a connection.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>tcpTimRetransDrop</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe that
fires whenever prolonged failure to perform timer-based retransmission results in termination of
the connection.</p></td>
</tr>
</table><a name="tbl-mib-udp"></a><h6>Table&nbsp;28-9 UDP <tt>mib</tt> Probes</h6><table><col width="25%"><col width="75%"><tr><td align="left" valign="top" scope="row"><p><tt>udpInCksumErrs</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe that fires whenever a datagram is discarded due to a
bad UDP checksum.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>udpInDatagrams</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe that fires whenever a UDP datagram is received.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>udpInErrors</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe that
fires whenever a UDP datagram is received, but is discarded due to
either a malformed packet header or the failure to allocate an internal
buffer.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>udpInOverflows</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe that fires whenever a UDP datagram is received, but subsequently dropped
due to lack of buffer space.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>udpNoPorts</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe that fires whenever a UDP datagram
is received on a port to which no socket is bound.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>udpOutDatagrams</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe that
fires whenever a UDP datagram is sent.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>udpOutErrors</tt></p></td>
<td align="left" valign="top" scope="row"><p>Probe that fires whenever a UDP
datagram is not sent due to some error condition, typically because the
datagram was malformed in some way.</p></td>
</tr>
</table>
         </div>
      </td>
   </tr>

   <tr class="PageControls" valign="top">
      <td></td>
      <td>
         <table width="100%">
      	   <tr>
      	     <td>
                 <a href="chp-mib.html">Previous</a>
             </td>
             <td align="right">
                 <a href="chp-mib-1.html">Next</a>
             </td>
           </tr>
         </table>
      </td>
   </tr>
</tbody>
</table>


</body>
</html>

