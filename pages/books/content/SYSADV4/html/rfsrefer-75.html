<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-type" content="text/html; charset=iso-8859-1">
<title>How Autofs Works - System Administration Guide: Network Services</title>
<meta name="robots" content="index,follow">
<meta name="robots" content="index,follow">
<meta name="date" content="2007-02-01">
<meta name="collection" content="reference">
<link rel="stylesheet" type="text/css" href="css/elements.css">
<link rel="stylesheet" type="text/css" href="css/indiana.css">
</head>

<body>


<div class="Masthead">
   <div class="MastheadLogo"></div>
   <div class="Title">System Administration Guide: Network Services</div>
</div>

<table class="Layout" border="0" cellspacing="0" width="100%">
<tbody>

   <tr valign="top" class="PageControls">
      <td></td>
      <td>
         <table width="100%">
      	   <tr>
      	     <td>
                 <a href="rfsrefer-66.html">Previous</a>
             </td>
             <td align="right">
                 <a href="rfsrefer-98.html">Next</a>
             </td>
           </tr>
         </table>
      </td>
   </tr>
   
   <tr valign="top">
      <td class="Navigation" width="200px"><p class="toc level1"><a href="docinfo.html">Document Information</a></p>
<p class="toc level1 tocsp"><a href="preface-1.html">Preface</a></p>
<p class="toc level1 tocsp"><a href="netservices-1.html">Part&nbsp;I&nbsp;Network Services Topics</a></p>
<p class="toc level2"><a href="nsov-1.html">1.&nbsp;&nbsp;Network Service (Overview)</a></p>
<p class="toc level2"><a href="nca-1.html">2.&nbsp;&nbsp;Managing Web Cache Servers</a></p>
<p class="toc level2"><a href="time-1.html">3.&nbsp;&nbsp;Time-Related Services</a></p>
<p class="toc level1 tocsp"><a href="rfstm-1.html">Part&nbsp;II&nbsp;Accessing Network File Systems Topics</a></p>
<p class="toc level2"><a href="rfsintro-2.html">4.&nbsp;&nbsp;Managing Network File Systems (Overview)</a></p>
<p class="toc level2"><a href="rfsadmin-8.html">5.&nbsp;&nbsp;Network File System Administration (Tasks)</a></p>
<p class="toc level2"><a href="rfsrefer-1.html">6.&nbsp;&nbsp;Accessing Network File Systems (Reference)</a></p>
<p class="toc level3"><a href="rfsrefer-6.html">NFS Files</a></p>
<p class="toc level3"><a href="rfsrefer-8.html">NFS Daemons</a></p>
<p class="toc level3"><a href="rfsrefer-13.html">NFS Commands</a></p>
<p class="toc level3"><a href="rfsrefer-37.html">Commands for Troubleshooting NFS Problems</a></p>
<p class="toc level3"><a href="rfsrefer-154.html">NFS Over RDMA</a></p>
<p class="toc level3"><a href="rfsrefer-45.html">How the NFS Service Works</a></p>
<p class="toc level3"><a href="rfsrefer-66.html">Autofs Maps</a></p>
<div class="onpage">
<p class="toc level3"><a href="">How Autofs Works</a></p>
</div>
<p class="toc level3"><a href="rfsrefer-98.html">Autofs Reference</a></p>
<p class="toc level1 tocsp"><a href="slptm.html">Part&nbsp;III&nbsp;SLP Topics</a></p>
<p class="toc level2"><a href="slparch-16.html">7.&nbsp;&nbsp;SLP (Overview)</a></p>
<p class="toc level2"><a href="slp.setup-10.html">8.&nbsp;&nbsp;Planning and Enabling SLP (Tasks)</a></p>
<p class="toc level2"><a href="ch.configuration-6.html">9.&nbsp;&nbsp;Administering SLP (Tasks)</a></p>
<p class="toc level2"><a href="legacy-7.html">10.&nbsp;&nbsp;Incorporating Legacy Services</a></p>
<p class="toc level2"><a href="slpreference.html">11.&nbsp;&nbsp;SLP (Reference)</a></p>
<p class="toc level1 tocsp"><a href="mailtm-1.html">Part&nbsp;IV&nbsp;Mail Services Topics</a></p>
<p class="toc level2"><a href="mailintro-1.html">12.&nbsp;&nbsp;Mail Services (Overview)</a></p>
<p class="toc level2"><a href="mailadmin-1.html">13.&nbsp;&nbsp;Mail Services (Tasks)</a></p>
<p class="toc level2"><a href="mailrefer-1.html">14.&nbsp;&nbsp;Mail Services (Reference)</a></p>
<p class="toc level1 tocsp"><a href="modemtm-1.html">Part&nbsp;V&nbsp;Serial Networking Topics</a></p>
<p class="toc level2"><a href="pppsvrconfig.intro-1.html">15.&nbsp;&nbsp;Solaris PPP 4.0 (Overview)</a></p>
<p class="toc level2"><a href="pppsvrconfig.p2plink-1.html">16.&nbsp;&nbsp;Planning for the PPP Link (Tasks)</a></p>
<p class="toc level2"><a href="pppsvrconfig.dialin-1.html">17.&nbsp;&nbsp;Setting Up a Dial-up PPP Link (Tasks)</a></p>
<p class="toc level2"><a href="pppsvrconfig.leased-1.html">18.&nbsp;&nbsp;Setting Up a Leased-Line PPP Link (Tasks)</a></p>
<p class="toc level2"><a href="pppsvrconfig.auth-1.html">19.&nbsp;&nbsp;Setting Up PPP Authentication (Tasks)</a></p>
<p class="toc level2"><a href="ppp.pppoe-1.html">20.&nbsp;&nbsp;Setting Up a PPPoE Tunnel (Tasks)</a></p>
<p class="toc level2"><a href="pppsvrconfig.troubleshoot-1.html">21.&nbsp;&nbsp;Fixing Common PPP Problems (Tasks)</a></p>
<p class="toc level2"><a href="pppsvrconfig.reference-1.html">22.&nbsp;&nbsp;Solaris PPP 4.0 (Reference)</a></p>
<p class="toc level2"><a href="pppsvrconfig.convert.app-1.html">23.&nbsp;&nbsp;Migrating From Asynchronous Solaris PPP to Solaris PPP 4.0 (Tasks)</a></p>
<p class="toc level2"><a href="uucpov-1.html">24.&nbsp;&nbsp;UUCP (Overview)</a></p>
<p class="toc level2"><a href="uucptasks-1.html">25.&nbsp;&nbsp;Administering UUCP (Tasks)</a></p>
<p class="toc level2"><a href="uucpref-1.html">26.&nbsp;&nbsp;UUCP (Reference)</a></p>
<p class="toc level1 tocsp"><a href="wwrstm.html">Part&nbsp;VI&nbsp;Working With Remote Systems Topics</a></p>
<p class="toc level2"><a href="wwrsov.html">27.&nbsp;&nbsp;Working With Remote Systems (Overview)</a></p>
<p class="toc level2"><a href="wuftp-17.html">28.&nbsp;&nbsp;Administering the FTP Server (Tasks)</a></p>
<p class="toc level2"><a href="remotehowtoaccess-99941.html">29.&nbsp;&nbsp;Accessing Remote Systems (Tasks)</a></p>
<p class="toc level1 tocsp"><a href="netmonitortm-1.html">Part&nbsp;VII&nbsp;Monitoring Network Services Topics</a></p>
<p class="toc level2"><a href="netmonitor-1.html">30.&nbsp;&nbsp;Monitoring Network Performance (Tasks)</a></p>
<p class="toc level1 tocsp"><a href="glossary-1.html">Glossary</a></p>
<p class="toc level1 tocsp"><a href="idx-1.html">Index</a></p>
</td>
      <td class="ContentPane" width="705px">

	 <div class="MainContent">      	 
             

<a name="rfsrefer-75"></a><h3>How Autofs Works</h3>
<p><a name="indexterm-854"></a><a name="indexterm-855"></a>Autofs is a client-side service that automatically mounts the appropriate file system. The
components that work together to accomplish automatic mounting are the following:</p>
<ul><li><p>The <tt>automount</tt> command</p></li>
<li><p>The <tt>autofs</tt> file system</p></li>
<li><p>The <tt>automountd</tt> daemon</p></li></ul>
<p><a name="indexterm-856"></a>The automount service, <tt>svc:/system/filesystem/autofs</tt>, which is called at system startup time, reads the
master map file <tt>auto_master</tt> to create the initial set of autofs mounts.
These autofs mounts are not automatically mounted at startup time. These mounts are
points under which file systems are mounted in the future. These points are
also known as trigger nodes.</p><p><a name="indexterm-857"></a><a name="indexterm-858"></a>After the autofs mounts are set up, these mounts can trigger file systems
to be mounted under them. For example, when autofs receives a request to
access a file system that is not currently mounted, autofs calls <tt>automountd</tt>,
which actually mounts the requested file system. </p><p><a name="indexterm-859"></a><a name="indexterm-860"></a><a name="indexterm-861"></a>After initially mounting autofs mounts, the <tt>automount</tt> command is used to update autofs
mounts as necessary. The command compares the list of mounts in the <tt>auto_master</tt>
map with the list of mounted file systems in the mount table file
<tt>/etc/mnttab</tt> (formerly <tt>/etc/mtab</tt>). <tt>automount</tt> then makes the appropriate changes. This process allows system
administrators to change mount information within <tt>auto_master</tt> and have those changes used by
the autofs processes without stopping and restarting the autofs daemon. After the file system
is mounted, further access does not require any action from <tt>automountd</tt> until
the file system is automatically unmounted. </p><p><a name="indexterm-862"></a><a name="indexterm-863"></a>Unlike <tt>mount</tt>, <tt>automount</tt> does not read the <tt>/etc/vfstab</tt> file (which is specific to
each computer) for a list of file systems to mount. The <tt>automount</tt> command is
controlled within a domain and on computers through the namespace or local files.
</p><p>The following is a simplified overview of how autofs works. </p><p>The automount daemon <tt>automountd</tt> is started at boot time by the service <tt>svc:/system/filesystem/autofs</tt>.
See <a href="#rfsrefer-fig-76">Figure&nbsp;6-3</a>. This service also runs the <tt>automount</tt> command, which reads the master
map and installs autofs mount points. See <a href="#rfsrefer-79">How Autofs Starts the Navigation Process (Master Map)</a> for more information.</p><a name="rfsrefer-fig-76"></a><h6>Figure&nbsp;6-3 <tt>svc:/system/filesystem/autofs</tt> Service Starts <tt>automount</tt></h6><img src="figures/5368.gif" alt="The context describes the graphic."></img><p>Autofs is a kernel file system that supports automatic mounting and unmounting. </p><p>When a request is made to access a file system at an
autofs mount point, the following occurs:</p>
<ol><li><p>Autofs intercepts the request. </p></li>
<li><p>Autofs sends a message to the <tt>automountd</tt> for the requested file system to be mounted.</p></li>
<li><p><tt>automountd</tt> locates the file system information in a map, creates the trigger nodes, and performs the mount. </p></li>
<li><p>Autofs allows the intercepted request to proceed.</p></li>
<li><p>Autofs unmounts the file system after a period of inactivity.</p></li></ol>

<hr><p><b>Note - </b>Mounts that are managed through the autofs service should not be manually mounted
or unmounted. Even if the operation is successful, the autofs service does not
check that the object has been unmounted, resulting in possible inconsistencies. A reboot
clears all the autofs mount points.</p>
<hr>


<a name="rfsrefer-78"></a><h4>How Autofs Navigates Through the Network (Maps)</h4>
<p><a name="indexterm-864"></a><a name="indexterm-865"></a><a name="indexterm-866"></a>Autofs searches a series of maps to navigate through the network. Maps are
files that contain information such as the password entries of all users on
a network or the names of all host computers on a network.
Effectively, the maps contain network-wide equivalents of UNIX administration files. Maps are available locally
or through a network name service such as NIS or NIS+. You create
maps to meet the needs of your environment by using the Solaris Management
Console tools. See <a href="#rfsrefer-94">Modifying How Autofs Navigates the Network (Modifying Maps)</a>. </p>

<a name="rfsrefer-79"></a><h4>How Autofs Starts the Navigation Process (Master Map)</h4>
<p><a name="indexterm-867"></a><a name="indexterm-868"></a><a name="indexterm-869"></a>The <tt>automount</tt> command reads the master map at system startup. Each entry in
the master map is a direct map name or an indirect map name,
its path, and its mount options, as shown in <a href="#rfsrefer-fig-80">Figure&nbsp;6-4</a>. The specific
order of the entries is not important. <tt>automount</tt> compares entries in the master map
with entries in the mount table to generate a current list. </p><a name="rfsrefer-fig-80"></a><h6>Figure&nbsp;6-4 Navigation Through the Master Map</h6><img src="figures/5369.gif" alt="The context describes the graphic."></img>

<a name="rfsrefer-82"></a><h4>Autofs Mount Process</h4>
<p><a name="indexterm-870"></a>What the autofs service does when a mount request is triggered depends on
how the automounter maps are configured. The mount process is generally the same
for all mounts. However, the final result changes with the mount point that
is specified and the complexity of the maps. Starting with the Solaris 2.6
release, the mount process has also been changed to include the creation of
the trigger nodes.</p>

<a name="rfsrefer-83"></a><h5>Simple Autofs Mount</h5>
<p>To help explain the autofs mount process, assume that the following files are
installed.</p><pre>$ <tt><b>cat /etc/auto_master</b></tt>
# Master map for automounter
#
+auto_master
/net        -hosts        -nosuid,nobrowse
/home       auto_home     -nobrowse
/share      auto_share
$ <tt><b>cat /etc/auto_share</b></tt>
# share directory map for automounter
#
ws          gumbo:/export/share/ws</pre><p>When the <tt>/share</tt> directory is accessed, the autofs service creates a trigger node
for <tt>/share/ws</tt>, which is an entry in <tt>/etc/mnttab</tt> that resembles the following entry:</p><pre>-hosts  /share/ws     autofs  nosuid,nobrowse,ignore,nest,dev=###</pre><p>When the <tt>/share/ws</tt> directory is accessed, the autofs service completes the process with
these steps:</p>
<ol><li><p>Checks the availability of the server's mount service.</p></li>
<li><p>Mounts the requested file system under <tt>/share</tt>. Now the <tt>/etc/mnttab</tt> file contains the following entries.</p><pre>-hosts  /share/ws     autofs  nosuid,nobrowse,ignore,nest,dev=###
gumbo:/export/share/ws /share/ws   nfs   nosuid,dev=####    #####</pre></li></ol>


<a name="rfsrefer-84"></a><h5>Hierarchical Mounting</h5>
<p><a name="indexterm-871"></a><a name="indexterm-872"></a>When multiple layers are defined in the automounter files, the mount process becomes
more complex. Suppose that you expand the <tt>/etc/auto_shared</tt> file from the previous
example to contain the following: </p><pre># share directory map for automounter
#
ws       /       gumbo:/export/share/ws
         /usr    gumbo:/export/share/ws/usr</pre><p><a name="indexterm-873"></a><a name="indexterm-874"></a>The mount process is basically the same as the previous example when the
<tt>/share/ws</tt> mount point is accessed. In addition, a trigger node to the next
level (<tt>/usr</tt>) is created in the <tt>/share/ws</tt> file system so that the
next level can be mounted if it is accessed. In this example, <tt>/export/share/ws/usr</tt>
must exist on the NFS server for the trigger node to be created.</p>
<hr><p><b>Caution - </b>Do not use the <tt>-soft</tt> option when specifying hierarchical layers. Refer to <a href="#rfsrefer-85">Autofs Unmounting</a>
for an explanation of this limitation.</p>
<hr>


<a name="rfsrefer-85"></a><h5>Autofs Unmounting</h5>
<p><a name="indexterm-875"></a><a name="indexterm-876"></a>The unmounting that occurs after a certain amount of idle time is from
the bottom up (reverse order of mounting). If one of the directories at
a higher level in the hierarchy is busy, only file systems below
that directory are unmounted. During the unmounting process, any trigger nodes are removed and
then the file system is unmounted. If the file system is busy,
the unmount fails and the trigger nodes are reinstalled.</p>
<hr><p><b>Caution - </b>Do not use the <tt>-soft</tt> option when specifying hierarchical layers. If the <tt>-soft</tt>
option is used, requests to reinstall the trigger nodes can time out. The
failure to reinstall the trigger nodes leaves no access to the next level
of mounts. The only way to clear this problem is to have the
automounter unmount all of the components in the hierarchy. The automounter can complete
the unmounting either by waiting for the file systems to be automatically unmounted
or by rebooting the system.</p>
<hr>


<a name="rfsrefer-86"></a><h4>How Autofs Selects the Nearest Read-Only Files for Clients (Multiple Locations)</h4>
<p><a name="indexterm-877"></a><a name="indexterm-878"></a><a name="indexterm-879"></a><a name="indexterm-880"></a><a name="indexterm-881"></a>The example direct map contains the following:</p><pre>/usr/local          -ro \
   /bin                   ivy:/export/local/sun4\
   /share                 ivy:/export/local/share\
   /src                   ivy:/export/local/src
/usr/man            -ro   oak:/usr/man \
                          rose:/usr/man \
                          willow:/usr/man
/usr/games          -ro   peach:/usr/games
/usr/spool/news     -ro   pine:/usr/spool/news \
                          willow:/var/spool/news </pre><p>The mount points <tt>/usr/man</tt> and <tt>/usr/spool/news</tt> list more than one location, three
locations for the first mount point, two locations for the second mount point.
Any of the replicated locations can provide the same service to any user.
This procedure is sensible only when you mount a file system that is
read-only, as you must have some control over the locations of files that
you write or modify. You want to avoid modifying files on one server
on one occasion and, minutes later, modifying the &ldquo;same&rdquo; file on another server.
The benefit is that the best available server is used automatically without any
effort that is required by the user.</p><p>If the file systems are configured as replicas (see <a href="rfsrefer-45.html#rfsrefer-53">What Is a Replicated File System?</a>), the clients have
the advantage of using failover. Not only is the best server automatically determined,
but if that server becomes unavailable, the client automatically uses the next-best server.
Failover was first implemented in the Solaris 2.6 release. </p><p>An example of a good file system to configure as a replica
is man pages. In a large network, more than one server can export
the current set of man pages. Which server you mount the man pages
from does not matter if the server is running and exporting its file
systems. In the previous example, multiple mount locations are expressed as a list
of mount locations in the map entry. </p><pre>/usr/man -ro oak:/usr/man rose:/usr/man willow:/usr/man </pre><p>In this example, you can mount the man pages from the servers
<tt>oak</tt>, <tt>rose</tt>, or <tt>willow</tt>. Which server is best depends on a number of
factors, including the following:</p>
<ul><li><p>The number of servers that support a particular NFS protocol level</p></li>
<li><p>The proximity of the server</p></li>
<li><p>The weighting</p></li></ul>
<p>During the sorting process, a count is taken of the number of
servers that support each version of the NFS protocol. Whichever version of the
protocol is supported on the most servers becomes the protocol that is used
by default. This selection provides the client with the maximum number of servers
to depend on.</p><p>After the largest subset of servers with the same version of the
protocol is found, that server list is sorted by proximity. To determine proximity IPv4
addresses are inspected. The IPv4 addresses show which servers are in each subnet.
Servers on a local subnet are given preference over servers on a remote
subnet. Preference for the closest server reduces latency and network traffic.</p>
<hr><p><b>Note - </b>Proximity cannot be determined for replicas that are using IPv6 addresses.</p>
<hr>
<p><a href="#rfsrefer-fig-87">Figure&nbsp;6-5</a> illustrates server proximity.</p><a name="rfsrefer-fig-87"></a><h6>Figure&nbsp;6-5 Server Proximity</h6><img src="figures/5366.gif" alt="The context describes the graphic."></img><p>If several servers that support the same protocol are on the local
subnet, the time to connect to each server is determined and the fastest
server is used. The sorting can also be influenced by using weighting (see
<a href="#egcoc">Autofs and Weighting</a>).</p><p>For example, if version 4 servers are more abundant, version 4 becomes the
protocol that is used by default. However, now the sorting process is more
complex. Here are some examples of how the sorting process works:</p>
<ul><li><p>Servers on the local subnet are given preference over servers on a remote subnet. So, if a version 3 server is on the local subnet and the closest version 4 server is on a remote subnet, the version 3 server is given preference. Likewise, if the local subnet consists of version 2 servers, they are given preference over remote subnets with version 3 and version 4 servers.</p></li>
<li><p>If the local subnet consists of a varied number of version 2, version 3, and version 4 servers, more sorting is required. The automounter prefers the highest version on the local subnet. In this instance, version 4 is the highest version. However, if the local subnet has more version 3 or version 2 servers than version 4 servers, the automounter &ldquo;bids down&rdquo; from the highest version on the local subnet by one version. For example, if the local subnet has three servers with version 4, three servers with version 3, and ten servers with version 2, a version 3 server is selected.</p></li>
<li><p>Similarly, if the local subnet consists of a varied number of version 2 and version 3 servers, the automounter first looks at the which version represents the highest version on the local subnet. Next, the automounter counts the number of servers that run each version. If the highest version on the local subnet also represents the most servers, the highest version is selected. If a lower version has more servers, the automounter bids down from the highest version on the local subnet by one version. For example, if more version 2 servers are on the local subnet than version 3 servers, a version 2 server is selected.</p></li></ul>

<hr><p><b>Note - </b>Weighting is also influenced by keyword values in the  <tt>/etc/default/nfs</tt> file.
Specifically, values for NFS_SERVER_VERSMIN, NFS_CLIENT_VERSMIN, NFS_SERVER_VERSMAX, and NFS_CLIENT_VERSMAX can make some versions be
excluded from the sorting process. For more information about these keywords, see <a href="rfsrefer-6.html#rfsrefer-133">Keywords for the <tt>/etc/default/nfs</tt> File</a>.</p>
<hr>
<p>With failover, the sorting is checked at mount time when a server
is selected. Multiple locations are useful in an  environment where individual servers might
not export their  file systems temporarily.</p><p><a name="indexterm-882"></a><a name="indexterm-883"></a><a name="indexterm-884"></a><a name="indexterm-885"></a><a name="indexterm-886"></a>Failover is particularly useful in a large network with many subnets. Autofs chooses
the appropriate server and is able to confine NFS network traffic to a
segment of the local network. If a server has multiple network interfaces, you
can list the host name that is associated with each network interface as
if the interface were a separate server. Autofs selects the nearest interface to
the client.</p>
<hr><p><b>Note - </b>No weighting and no proximity checks are performed with manual mounts. The <tt>mount</tt>
command prioritizes the servers that are listed from left to right.</p>
<hr>
<p>For more information, see <a href="http://docs.sun.com/doc/819-2240/automount-1m?a=view"><tt>automount</tt>(1M)</a> man page.</p>

<a name="egcoc"></a><h4>Autofs and Weighting</h4>
<p>You can influence the selection of servers at the same proximity level by
adding a weighting value to the autofs map. For example:</p><pre>/usr/man -ro oak,rose(1),willow(2):/usr/man</pre><p><a name="indexterm-887"></a><a name="indexterm-888"></a>The numbers in parentheses indicate a weighting. Servers without a weighting have a
value of zero and, therefore, are most likely to be selected. The higher
the weighting value, the lower the chance that the server is selected.
</p>
<hr><p><b>Note - </b>All other server selection factors are more important than weighting. Weighting is only
considered when selecting between servers with the same network proximity.</p>
<hr>


<a name="rfsrefer-90"></a><h4>Variables in a Map Entry</h4>
<p><a name="indexterm-889"></a><a name="indexterm-890"></a><a name="indexterm-891"></a>You can create a client-specific variable by prefixing a dollar sign (<tt>$</tt>) to
its name. The variable helps you to accommodate different architecture types that are
accessing the same file-system location. You can also use curly braces to delimit
the name of the variable from appended letters or digits. <a href="#rfsrefer-tbl-91">Table&nbsp;6-7</a> shows the predefined
map variables. </p><a name="rfsrefer-tbl-91"></a><h6>Table&nbsp;6-7 Predefined Map Variables</h6><table><col width="2*"><col width="3*"><col width="2*"><col width="2*"><tr><th align="left" valign="top" scope="column"><p>Variable</p></th>
<th align="left" valign="top" scope="column"><p>Meaning</p></th>
<th align="left" valign="top" scope="column"><p>Derived From</p></th>
<th align="left" valign="top" scope="column"><p>Example</p></th>
</tr>
<tr><td align="left" valign="top" scope="row"><p><a name="indexterm-892"></a><tt>ARCH</tt> </p></td>
<td align="left" valign="top" scope="row"><p>Architecture type</p></td>
<td align="left" valign="top" scope="row"><p><tt>uname -m</tt></p></td>
<td align="left" valign="top" scope="row"><p><tt>sun4</tt></p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><a name="indexterm-893"></a><a name="indexterm-894"></a><tt>CPU</tt>  </p></td>
<td align="left" valign="top" scope="row"><p>Processor type</p></td>
<td align="left" valign="top" scope="row"><p><tt>uname -p</tt></p></td>
<td align="left" valign="top" scope="row"><p><tt>sparc</tt></p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><a name="indexterm-895"></a><tt>HOST</tt> </p></td>
<td align="left" valign="top" scope="row"><p>Host name</p></td>
<td align="left" valign="top" scope="row"><p><tt>uname -n</tt></p></td>
<td align="left" valign="top" scope="row"><p><tt>dinky</tt></p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><a name="indexterm-896"></a><a name="indexterm-897"></a><tt>OSNAME</tt> 
</p></td>
<td align="left" valign="top" scope="row"><p>Operating system name</p></td>
<td align="left" valign="top" scope="row"><p><tt>uname -s</tt></p></td>
<td align="left" valign="top" scope="row"><p><tt>SunOS</tt></p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><a name="indexterm-898"></a><tt>OSREL</tt> </p></td>
<td align="left" valign="top" scope="row"><p>Operating system release</p></td>
<td align="left" valign="top" scope="row"><p><tt>uname -r</tt></p></td>
<td align="left" valign="top" scope="row"><p><tt>5.8</tt></p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><a name="indexterm-899"></a><tt>OSVERS</tt> </p></td>
<td align="left" valign="top" scope="row"><p>Operating system version (version of the
release)</p></td>
<td align="left" valign="top" scope="row"><p><tt>uname -v</tt></p></td>
<td align="left" valign="top" scope="row"><p><tt>GENERIC</tt></p></td>
</tr>
</table><p>You can use variables anywhere in an entry line except as a
key. For instance, suppose that you have a file server that exports binaries
for SPARC and x86 architectures from <tt>/usr/local/bin/sparc</tt> and <tt>/usr/local/bin/x86</tt> respectively. The clients can
mount through a map entry such as the following: </p><pre>/usr/local/bin       -ro    <i>server</i>:/usr/local/bin/$CPU</pre><p><a name="indexterm-900"></a><a name="indexterm-901"></a><a name="indexterm-902"></a>Now the same entry for all clients applies to all architectures.  
</p>
<hr><p><b>Note - </b>Most applications that are written for any of the sun4 architectures can run
on all sun4 platforms. The <tt>-ARCH</tt> variable is hard-coded to <tt>sun4</tt>.</p>
<hr>


<a name="rfsrefer-92"></a><h4>Maps That Refer to Other Maps</h4>
<p><a name="indexterm-903"></a><a name="indexterm-904"></a><a name="indexterm-905"></a><a name="indexterm-906"></a><a name="indexterm-907"></a><a name="indexterm-908"></a>A map entry +<i>mapname</i> that is used in a file map causes automount
to read the specified map as if it were included in the current
file. If <i>mapname</i> is not preceded by a slash, autofs treats the map
name as a string of characters and uses the name-service switch policy to
find the map name. If the path name is an absolute path name,
<tt>automount</tt> checks a local map of that name. If the map name starts
with a dash (<tt>-</tt>), <tt>automount</tt> consults the appropriate built-in map, such as
<tt>hosts</tt>. </p><p>This name-service switch file contains an entry for autofs that is labeled as
<tt>automount</tt>, which contains the order in which the name services are searched. The
following file is an example of a name-service switch file.</p><pre>#
# /etc/nsswitch.nis:
#
# An example file that could be copied over to /etc/nsswitch.conf;
# it uses NIS (YP) in conjunction with files.
#
# "hosts:" and "services:" in this file are used only if the /etc/netconfig
# file contains "switch.so" as a nametoaddr library for "inet" transports.
# the following two lines obviate the "+" entry in /etc/passwd and /etc/group.
passwd:         files nis
group:          files nis

# consult /etc "files" only if nis is down.
hosts:          nis [NOTFOUND=return] files
networks:       nis [NOTFOUND=return] files
protocols:      nis [NOTFOUND=return] files
rpc:            nis [NOTFOUND=return] files
ethers:         nis [NOTFOUND=return] files
netmasks:       nis [NOTFOUND=return] files
bootparams:     nis [NOTFOUND=return] files
publickey:      nis [NOTFOUND=return] files
netgroup:       nis
automount:      files nis
aliases:        files nis
# for efficient getservbyname() avoid nis
services:       files nis </pre><p>In this example, the local maps are searched before the NIS maps.
Therefore,  you can have a few entries in your local <tt>/etc/auto_home</tt> map for
the most commonly accessed home directories. You can then use the switch to
fall back to the NIS map for other entries. </p><pre>bill               cs.csc.edu:/export/home/bill
bonny              cs.csc.edu:/export/home/bonny</pre><p>After consulting the included map, if no match is found, <tt>automount</tt> continues
scanning the current map. Therefore, you can add more entries after a <tt>+</tt>
entry. </p><pre>bill               cs.csc.edu:/export/home/bill
bonny              cs.csc.edu:/export/home/bonny
+auto_home </pre><p>The map that is included can be a local file or a
built-in map. Remember, only local files can contain <tt>+</tt> entries. </p><pre>+auto_home_finance      # NIS+ map
+auto_home_sales        # NIS+ map
+auto_home_engineering  # NIS+ map
+/etc/auto_mystuff      # local map
+auto_home              # NIS+ map
+-hosts                 # built-in hosts map </pre>
<hr><p><b>Note - </b><a name="indexterm-909"></a><a name="indexterm-910"></a><a name="indexterm-911"></a><a name="indexterm-912"></a>You cannot use <tt>+</tt> entries in NIS+ or NIS maps.   
</p>
<hr>


<a name="rfsrefer-93"></a><h4>Executable Autofs Maps</h4>
<p><a name="indexterm-913"></a><a name="indexterm-914"></a>You can create an autofs map that executes some commands to generate the
autofs mount points. You could benefit from using an executable autofs map if
you need to be able to create the autofs structure from a
database or a flat file. The disadvantage to using an executable map is
that the map needs to be installed on each host. An executable map
cannot be included in either the NIS or the NIS+ name service.</p><p>The executable map must have an entry in the <tt>auto_master</tt> file.</p><pre>/execute    auto_execute</pre><p>Here is an example of an executable map:</p><pre>#!/bin/ksh
#
# executable map for autofs
#

case $1 in
             src)  echo '-nosuid,hard bee:/export1' ;;
esac</pre><p>For this example to work, the file must be installed as <tt>/etc/auto_execute</tt>
and must have the executable bit set. Set permissions to <tt>744</tt>. Under these
circumstances, running the following command causes the <tt>/export1</tt> file system from <tt>bee</tt>
to be mounted:</p><pre>% ls /execute/src</pre>

<a name="rfsrefer-94"></a><h4>Modifying How Autofs Navigates the Network (Modifying Maps)</h4>
<p>You can modify, delete, or add entries to maps to meet the
needs of your environment. As applications and other file systems that users require change
their location, the maps must reflect those changes. You can modify autofs maps
at any time. Whether your modifications are effective the next time <tt>automountd</tt> mounts
a file system depends on which map you modify and what kind of
modification you make. </p>

<a name="rfsrefer-95"></a><h4>Default Autofs Behavior With Name Services</h4>
<p>At boot time autofs is invoked by the service <tt>svc:/system/filesystem/autofs</tt> and autofs
checks for the master <tt>auto_master</tt> map. Autofs is subject to the rules that
are discussed subsequently. </p><p>Autofs uses the name service that is specified in the automount entry of
the <tt>/etc/nsswitch.conf</tt> file. If NIS+ is specified, as opposed to local files or
NIS, all map names are used as is. If NIS is selected and
autofs cannot find a map that autofs needs, but finds a map
name that contains one or more underscores, the underscores are changed to dots. This
change allows the old NIS file names to work. Then autofs checks
the map again, as shown in <a href="#rfsrefer-fig-96">Figure&nbsp;6-6</a>. </p><a name="rfsrefer-fig-96"></a><h6>Figure&nbsp;6-6 How Autofs Uses the Name Service</h6><img src="figures/5365.gif" alt="The context describes the graphic."></img><p>The screen activity for this session would resemble the following example. </p><pre>$ <tt><b>grep /home /etc/auto_master</b></tt>
/home           auto_home

$ <tt><b>ypmatch brent auto_home</b></tt>
Can't match key brent in map auto_home.  Reason: no such map in
server's domain.

$ <tt><b>ypmatch brent auto.home</b></tt>
diskus:/export/home/diskus1/&amp;</pre><p>If &ldquo;files&rdquo; is selected as the name service, all maps are assumed to
be local files in the <tt>/etc</tt> directory. Autofs interprets a map name that
begins with a slash (<tt>/</tt>) as local regardless of which name service autofs
uses.     </p>
         </div>
      </td>
   </tr>

   <tr class="PageControls" valign="top">
      <td></td>
      <td>
         <table width="100%">
      	   <tr>
      	     <td>
                 <a href="rfsrefer-66.html">Previous</a>
             </td>
             <td align="right">
                 <a href="rfsrefer-98.html">Next</a>
             </td>
           </tr>
         </table>
      </td>
   </tr>
</tbody>
</table>


</body>
</html>

