<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-type" content="text/html; charset=iso-8859-1">
<title>How the NFS Service Works - System Administration Guide: Network Services</title>
<meta name="robots" content="index,follow">
<meta name="robots" content="index,follow">
<meta name="date" content="2007-02-01">
<meta name="collection" content="reference">
<link rel="stylesheet" type="text/css" href="css/elements.css">
<link rel="stylesheet" type="text/css" href="css/indiana.css">
</head>

<body>


<div class="Masthead">
   <div class="MastheadLogo"></div>
   <div class="Title">System Administration Guide: Network Services</div>
</div>

<table class="Layout" border="0" cellspacing="0" width="100%">
<tbody>

   <tr valign="top" class="PageControls">
      <td></td>
      <td>
         <table width="100%">
      	   <tr>
      	     <td>
                 <a href="rfsrefer-154.html">Previous</a>
             </td>
             <td align="right">
                 <a href="rfsrefer-66.html">Next</a>
             </td>
           </tr>
         </table>
      </td>
   </tr>
   
   <tr valign="top">
      <td class="Navigation" width="200px"><p class="toc level1"><a href="docinfo.html">Document Information</a></p>
<p class="toc level1 tocsp"><a href="preface-1.html">Preface</a></p>
<p class="toc level1 tocsp"><a href="netservices-1.html">Part&nbsp;I&nbsp;Network Services Topics</a></p>
<p class="toc level2"><a href="nsov-1.html">1.&nbsp;&nbsp;Network Service (Overview)</a></p>
<p class="toc level2"><a href="nca-1.html">2.&nbsp;&nbsp;Managing Web Cache Servers</a></p>
<p class="toc level2"><a href="time-1.html">3.&nbsp;&nbsp;Time-Related Services</a></p>
<p class="toc level1 tocsp"><a href="rfstm-1.html">Part&nbsp;II&nbsp;Accessing Network File Systems Topics</a></p>
<p class="toc level2"><a href="rfsintro-2.html">4.&nbsp;&nbsp;Managing Network File Systems (Overview)</a></p>
<p class="toc level2"><a href="rfsadmin-8.html">5.&nbsp;&nbsp;Network File System Administration (Tasks)</a></p>
<p class="toc level2"><a href="rfsrefer-1.html">6.&nbsp;&nbsp;Accessing Network File Systems (Reference)</a></p>
<p class="toc level3"><a href="rfsrefer-6.html">NFS Files</a></p>
<p class="toc level3"><a href="rfsrefer-8.html">NFS Daemons</a></p>
<p class="toc level3"><a href="rfsrefer-13.html">NFS Commands</a></p>
<p class="toc level3"><a href="rfsrefer-37.html">Commands for Troubleshooting NFS Problems</a></p>
<p class="toc level3"><a href="rfsrefer-154.html">NFS Over RDMA</a></p>
<div class="onpage">
<p class="toc level3"><a href="">How the NFS Service Works</a></p>
</div>
<p class="toc level3"><a href="rfsrefer-66.html">Autofs Maps</a></p>
<p class="toc level3"><a href="rfsrefer-75.html">How Autofs Works</a></p>
<p class="toc level3"><a href="rfsrefer-98.html">Autofs Reference</a></p>
<p class="toc level1 tocsp"><a href="slptm.html">Part&nbsp;III&nbsp;SLP Topics</a></p>
<p class="toc level2"><a href="slparch-16.html">7.&nbsp;&nbsp;SLP (Overview)</a></p>
<p class="toc level2"><a href="slp.setup-10.html">8.&nbsp;&nbsp;Planning and Enabling SLP (Tasks)</a></p>
<p class="toc level2"><a href="ch.configuration-6.html">9.&nbsp;&nbsp;Administering SLP (Tasks)</a></p>
<p class="toc level2"><a href="legacy-7.html">10.&nbsp;&nbsp;Incorporating Legacy Services</a></p>
<p class="toc level2"><a href="slpreference.html">11.&nbsp;&nbsp;SLP (Reference)</a></p>
<p class="toc level1 tocsp"><a href="mailtm-1.html">Part&nbsp;IV&nbsp;Mail Services Topics</a></p>
<p class="toc level2"><a href="mailintro-1.html">12.&nbsp;&nbsp;Mail Services (Overview)</a></p>
<p class="toc level2"><a href="mailadmin-1.html">13.&nbsp;&nbsp;Mail Services (Tasks)</a></p>
<p class="toc level2"><a href="mailrefer-1.html">14.&nbsp;&nbsp;Mail Services (Reference)</a></p>
<p class="toc level1 tocsp"><a href="modemtm-1.html">Part&nbsp;V&nbsp;Serial Networking Topics</a></p>
<p class="toc level2"><a href="pppsvrconfig.intro-1.html">15.&nbsp;&nbsp;Solaris PPP 4.0 (Overview)</a></p>
<p class="toc level2"><a href="pppsvrconfig.p2plink-1.html">16.&nbsp;&nbsp;Planning for the PPP Link (Tasks)</a></p>
<p class="toc level2"><a href="pppsvrconfig.dialin-1.html">17.&nbsp;&nbsp;Setting Up a Dial-up PPP Link (Tasks)</a></p>
<p class="toc level2"><a href="pppsvrconfig.leased-1.html">18.&nbsp;&nbsp;Setting Up a Leased-Line PPP Link (Tasks)</a></p>
<p class="toc level2"><a href="pppsvrconfig.auth-1.html">19.&nbsp;&nbsp;Setting Up PPP Authentication (Tasks)</a></p>
<p class="toc level2"><a href="ppp.pppoe-1.html">20.&nbsp;&nbsp;Setting Up a PPPoE Tunnel (Tasks)</a></p>
<p class="toc level2"><a href="pppsvrconfig.troubleshoot-1.html">21.&nbsp;&nbsp;Fixing Common PPP Problems (Tasks)</a></p>
<p class="toc level2"><a href="pppsvrconfig.reference-1.html">22.&nbsp;&nbsp;Solaris PPP 4.0 (Reference)</a></p>
<p class="toc level2"><a href="pppsvrconfig.convert.app-1.html">23.&nbsp;&nbsp;Migrating From Asynchronous Solaris PPP to Solaris PPP 4.0 (Tasks)</a></p>
<p class="toc level2"><a href="uucpov-1.html">24.&nbsp;&nbsp;UUCP (Overview)</a></p>
<p class="toc level2"><a href="uucptasks-1.html">25.&nbsp;&nbsp;Administering UUCP (Tasks)</a></p>
<p class="toc level2"><a href="uucpref-1.html">26.&nbsp;&nbsp;UUCP (Reference)</a></p>
<p class="toc level1 tocsp"><a href="wwrstm.html">Part&nbsp;VI&nbsp;Working With Remote Systems Topics</a></p>
<p class="toc level2"><a href="wwrsov.html">27.&nbsp;&nbsp;Working With Remote Systems (Overview)</a></p>
<p class="toc level2"><a href="wuftp-17.html">28.&nbsp;&nbsp;Administering the FTP Server (Tasks)</a></p>
<p class="toc level2"><a href="remotehowtoaccess-99941.html">29.&nbsp;&nbsp;Accessing Remote Systems (Tasks)</a></p>
<p class="toc level1 tocsp"><a href="netmonitortm-1.html">Part&nbsp;VII&nbsp;Monitoring Network Services Topics</a></p>
<p class="toc level2"><a href="netmonitor-1.html">30.&nbsp;&nbsp;Monitoring Network Performance (Tasks)</a></p>
<p class="toc level1 tocsp"><a href="glossary-1.html">Glossary</a></p>
<p class="toc level1 tocsp"><a href="idx-1.html">Index</a></p>
</td>
      <td class="ContentPane" width="705px">

	 <div class="MainContent">      	 
             

<a name="rfsrefer-45"></a><h3>How the NFS Service Works</h3>
<p>The following sections describe some of the complex functions of the NFS software.
Note that some of the feature descriptions in this section are exclusive to
NFS version 4.</p>
<ul><li><p><a href="#rfsrefer-147">Version Negotiation in NFS</a></p></li>
<li><p><a href="#rfsrefer-134">Features in NFS Version 4</a></p></li>
<li><p><a href="#rfsrefer-47">UDP and TCP Negotiation</a></p></li>
<li><p><a href="#rfsrefer-48">File Transfer Size Negotiation</a></p></li>
<li><p><a href="#rfsrefer-49">How File Systems Are Mounted</a></p></li>
<li><p><a href="#rfsrefer-50">Effects of the <tt>-public</tt> Option and NFS URLs When Mounting</a></p></li>
<li><p><a href="#rfsrefer-51">Client-Side Failover</a></p></li>
<li><p><a href="#rfsrefer-55">Large Files</a></p></li>
<li><p><a href="#rfsrefer-105">How NFS Server Logging Works</a></p></li>
<li><p><a href="#rfsrefer-56">How the WebNFS Service Works</a></p></li>
<li><p><a href="#rfsrefer-57">WebNFS Limitations With Web Browser Use</a></p></li>
<li><p><a href="#rfsrefer-58">Secure NFS System</a></p></li>
<li><p><a href="#rfsrefer-59">Secure RPC</a></p></li></ul>

<hr><p><b>Note - </b>If your system has zones enabled and you want to use this
feature in a non-global zone, see <a href="http://docs.sun.com/doc/819-2450"><i>System Administration Guide: Solaris Containers-Resource Management and Solaris Zones</i></a> for more information.</p>
<hr>


<a name="rfsrefer-147"></a><h4>Version Negotiation in NFS</h4>
<a name="indexterm-672"></a><a name="indexterm-673"></a><a name="indexterm-674"></a><p>The NFS initiation process includes negotiating the protocol levels for servers and clients.
 If you do not specify the version level, then the best level
is selected by default. For example, if both the client and the server
can support version 3, then version 3 is used. If the client
or the server can only support version 2, then version 2 is used.</p><p>Starting in the Solaris 10 release, you can set the keywords NFS_CLIENT_VERSMIN, NFS_CLIENT_VERSMAX,
NFS_SERVER_VERSMIN, NFS_SERVER_VERSMAX in the <tt>/etc/default/nfs</tt> file. Your specified minimum and maximum values
for the server and the client would replace the default values for these
keywords. For both the client and the server the default minimum value is
2 and the default maximum value is 4.  See <a href="rfsrefer-6.html#rfsrefer-133">Keywords for the <tt>/etc/default/nfs</tt> File</a>. To find
the version supported by the server, the NFS client begins with the setting
for NFS_CLIENT_VERSMAX and continues to try each version until reaching the version setting
for NFS_CLIENT_VERSMIN.  As soon as the supported version is found, the process
terminates.  For example, if NFS_CLIENT_VERSMAX=4 and NFS_CLIENT_VERSMIN=2, then the client attempts version
4 first, then version 3, and finally version 2. If NFS_CLIENT_VERSMIN and NFS_CLIENT_VERSMAX
are set to the same value, then the client always uses this version
and does not attempt any other version.  If the server does not
offer this version, the mount fails.</p>
<hr><p><b>Note - </b>You can override the values that are determined by the negotiation by using
the <tt>vers</tt> option with the <tt>mount</tt> command.  See the <a href="http://docs.sun.com/doc/819-2240/mount-nfs-1m?a=view"><tt>mount_nfs</tt>(1M)</a> man page.</p>
<hr>
<p>For procedural information, refer to <a href="rfsadmin-68.html">Setting Up NFS Services</a>.</p>

<a name="rfsrefer-134"></a><h4>Features in NFS Version 4</h4>
<a name="indexterm-675"></a><p>Many changes have been made to NFS in version 4. This section
provides descriptions of these new features.</p>
<ul><li><p><a href="#rfsrefer-148">Unsharing and Resharing a File System in NFS Version 4</a></p></li>
<li><p><a href="#rfsrefer-136">File-System Namespace in NFS Version 4</a></p></li>
<li><p><a href="#rfsrefer-137">Volatile File Handles in NFS Version 4</a></p></li>
<li><p><a href="#rfsrefer-138">Client Recovery in NFS Version 4</a></p></li>
<li><p><a href="#rfsrefer-139"><tt>OPEN</tt> Share Support in NFS Version 4</a></p></li>
<li><p><a href="#rfsrefer-140">Delegation in NFS Version 4</a></p></li>
<li><p><a href="#gande">ACLs and <tt>nfsmapid</tt> in NFS Version 4</a></p></li>
<li><p><a href="#rfsrefer-111">Client-Side Failover in NFS Version 4</a></p></li></ul>

<hr><p><b>Note - </b>Starting in the Solaris 10 release, NFS version 4 does not support the
LIPKEY/SPKM security flavor. Also, NFS version 4 does not use the <tt>mountd</tt>,
<tt>nfslogd</tt>, and <tt>statd</tt> daemons.</p>
<hr>
<p>For procedural information related to using NFS version 4, refer to <a href="rfsadmin-68.html">Setting Up NFS Services</a>.</p>

<a name="rfsrefer-148"></a><h5>Unsharing and Resharing a File System in NFS Version 4</h5>
<a name="indexterm-676"></a><p>With both NFS version 3 and version 4, if a client attempts
to access a file system that has been unshared, the server responds with
an error code. However, with NFS version 3 the server maintains any locks
that the clients had obtained before the file system was unshared.  Thus,
when the file system is reshared, NFS version 3 clients can access the
file system as though that file system had never been unshared.</p><p>With NFS version 4, when a file system is unshared, all the
state for any open files or file locks in that file system is
destroyed. If the client attempts to access these files or locks, the client
receives an error. This error is usually reported as an <tt>I/O</tt> error to
the application. Note, however, that resharing a currently shared file system to change
options does not destroy any of the state on the server.</p><p>For related information, refer to <a href="#rfsrefer-138">Client Recovery in NFS Version 4</a> or see the <a href="http://docs.sun.com/doc/819-2240/unshare-nfs-1m?a=view"><tt>unshare_nfs</tt>(1M)</a> man page.</p>

<a name="rfsrefer-136"></a><h5>File-System Namespace in NFS Version 4</h5>
<a name="indexterm-677"></a><p>NFS version 4 servers create and maintain a pseudo-file system, which provides clients
with seamless access to all exported objects on the server. Prior to NFS
version 4, the pseudo-file system did not exist. Clients were forced to mount
each shared server file system for access. Consider the following example.</p><a name="rfsrefer-fig-131"></a><h6>Figure&nbsp;6-2 Views of the Server File System and the Client File System</h6><img src="figures/servr-client-views.gif" alt="The context describes the graphic."></img><p>Note that the client cannot see the <tt>payroll</tt> directory and the <tt>nfs4x</tt> directory,
because these directories are not exported and do not lead to exported directories.
However, the <tt>local</tt> directory is visible to the client, because <tt>local</tt> is an
exported directory. The <tt>projects</tt> directory is visible to the client, because <tt>projects</tt> leads
to the exported directory, <tt>nfs4</tt>. Thus, portions of the server namespace that are not
explicitly exported are bridged with a pseudo-file system that views only the exported
directories and those directories that lead to server exports.</p><p>A pseudo-file system is a structure that contains only directories and is created
by the server.  The pseudo-file system permits a client to browse the
hierarchy of exported file systems.  Thus, the client's view of the
pseudo-file system is limited to paths that lead to exported file systems.</p><p>Previous versions of NFS did not permit a client to traverse server file
systems without mounting each file system.  However, in NFS version 4, the
server namespace does the following:</p>
<ul><li><p>Restricts the client's file-system view to directories that lead to server exports.</p></li>
<li><p>Provides clients with seamless access to server exports without requiring that the client mount each underlying file system. See the previous example. Note, however, that different operating systems might require the client to mount each server file system.</p></li></ul>
<p>For POSIX-related reasons, the Solaris NFS version 4 client does not cross server
file-system boundaries. When such attempts are made, the client makes the directory appear
to be empty. To remedy this situation, you must perform a mount for
each of the server's file systems.</p>

<a name="rfsrefer-137"></a><h5>Volatile File Handles in NFS Version 4</h5>
<a name="indexterm-678"></a><p>File handles are created on the server and contain information that uniquely identifies
files and directories. In NFS versions 2 and 3 the server returned persistent
file handles. Thus, the client could guarantee that the server would generate a
file handle that always referred to the same file. For example:</p>
<ul><li><p>If a file was deleted and replaced with a file of the same name, the server would generate a new file handle for the new file. If the client used the old file handle, the server would return an error that the file handle was stale.</p></li>
<li><p>If a file was renamed, the file handle would remain the same.</p></li>
<li><p>If you had to reboot the server, the file handles would remain the same.</p></li></ul>
<p>Thus, when the server received a request from a client that included a
file handle, the resolution was straightforward and the file handle always referred to
the correct file.</p><p>This method of identifying files and directories for NFS operations was fine for
most UNIX-based servers. However, the method could not be implemented on servers that
relied on other methods of identification, such as a file's path name. To
resolve this problem, the NFS version 4 protocol permits a server to declare
that its file handles are volatile. Thus, a file handle could change. If
the file handle does change, the client must find the new file
handle.</p><p>Like NFS versions 2 and 3, the Solaris NFS version 4 server
always provides persistent file handles. However, Solaris NFS version 4 clients that access non-Solaris
NFS version 4 servers must support volatile file handles if the server uses
them. Specifically, when the server tells the client that the file handle is
volatile, the client must cache the mapping between path name and file handle.
The client uses the volatile file handle until it expires. On expiration, the
client does the following:</p>
<ul><li><p>Flushes the cached information that refers to that file handle</p></li>
<li><p>Searches for that file's new file handle</p></li>
<li><p>Retries the operation</p></li></ul>

<hr><p><b>Note - </b>The server always tells the client which file handles are persistent and which
file handles are volatile.</p>
<hr>
<p>Volatile file handles might expire for any of these reasons:</p>
<ul><li><p>When you close a file</p></li>
<li><p>When the filehandle's file system migrates</p></li>
<li><p>When a client renames a file</p></li>
<li><p>When the server reboots</p></li></ul>
<p>Note that if the client is unable to find the new file
handle, an error message is put in the <tt>syslog</tt> file. Further attempts to access
this file fail with an <tt>I/O</tt> error.</p>

<a name="rfsrefer-138"></a><h5>Client Recovery in NFS Version 4</h5>
<a name="indexterm-679"></a><p>The NFS version 4 protocol is a stateful protocol. A protocol is
stateful when both the client and the server maintain current information about the following.</p>
<ul><li><p>Open files</p></li>
<li><p>File locks</p></li></ul>
<p>When a failure occurs, such as a server crash, the client and
the server work together to reestablish the open and lock states that existed
prior to the failure.</p><p>When a server crashes and is rebooted, the server loses its state.
The client detects that the server has rebooted and begins the process of
helping the server rebuild its state. This process is known as client recovery,
because the client directs the process.</p><p>When the client discovers that the server has rebooted, the client immediately suspends
its current activity and begins the process of client recovery.  When the
recovery process starts, a message, such as the following, is displayed in the
system error log <tt>/var/adm/messages</tt>.</p><pre>NOTICE: Starting recovery server <i>basil.example.company.com</i></pre><p>During the recovery process, the client sends the server information about the client's
previous state.  Note, however, that during this period the client does not
send any new requests to the server.  Any new requests to open
files or set file locks must wait for the server to complete
its recovery period before proceeding.</p><p>When the client recovery process is complete, the following message is displayed in
the system error log <tt>/var/adm/messages</tt>.</p><pre>NOTICE: Recovery done for server <i>basil.example.company.com</i></pre><p>Now the client has successfully completed sending its state information to the server.
 However, even though the client has completed this process, other clients might
not have completed their process of sending state information to the server. 
Therefore, for a period of time, the server does not accept any open
or lock requests. This period of time, which is known as the
grace period, is designated to permit all the clients to complete their recovery.</p><p>During the grace period, if the client attempts to open any new
files or establish any new locks, the server denies the request with the
<tt>GRACE</tt> error code. On receiving this error, the client must wait for
the grace period to end and then resend the request to the server.
 During the grace period the following message is displayed.</p><pre>NFS server recovering</pre><p>Note that during the grace period the commands that do not open
files or set file locks can proceed.   For example, the commands
<tt>ls</tt> and <tt>cd</tt> do not open a file or set a file
lock. Thus, these commands are not  suspended. However, a command such as
<tt>cat</tt>, which opens a file, would be suspended until the grace period ends.</p><p>When the grace period has ended, the following message is displayed.</p><pre>NFS server recovery ok.</pre><p>The client can now send new open and lock requests to 
the server.</p><p>Client recovery can fail for a variety of reasons. For example, if
a network partition exists after the server reboots, the client might not be able
to reestablish its state with the server before the grace period ends. 
When the grace period has ended, the server does not permit the
client to reestablish its state because new state operations could create conflicts.  For
example, a new file lock might conflict with an old file lock
that the client is trying to recover.  When such situations occur, the
server returns the <tt>NO_GRACE</tt> error code to the client.</p><p>If the recovery of an open operation for a particular file fails,
the client marks the file as unusable and the following message is displayed.</p><pre>WARNING: The following NFS file could not be recovered and was marked dead 
(can't reopen:  NFS status 70):  file :  <i>filename</i></pre><p>Note that the number <tt>70</tt> is only an example.</p><p>If reestablishing a file lock during recovery fails, the following error message is
posted.</p><pre>NOTICE: nfs4_send_siglost:  pid <i>PROCESS-ID</i> lost
lock on server <i>SERVER-NAME</i></pre><p>In this situation, the <tt>SIGLOST</tt> signal is posted to the process. The default
action for the <tt>SIGLOST</tt> signal is to terminate the process.</p><p>For you to recover from this state, you must restart any applications that
had files open at the time of  the failure. Note that
the following can occur.</p>
<ul><li><p>Some processes that did not reopen the file could receive <tt>I/O</tt> errors.</p></li>
<li><p>Other processes that did reopen the file, or performed the open operation after the recovery failure, are able to access the file without any problems.</p></li></ul>
<p>Thus, some processes can access a particular file while other processes cannot.</p>

<a name="rfsrefer-139"></a><h5><tt>OPEN</tt> Share Support in NFS Version 4</h5>
<a name="indexterm-680"></a><p>The NFS version 4 protocol provides several file-sharing modes that the client can
use to control file access by other clients. A client can specify the
following:</p>
<ul><li><p><tt>DENY_NONE</tt> mode permits other clients read and write access to a file.</p></li>
<li><p><tt>DENY_READ</tt> mode denies other clients read access to a file.</p></li>
<li><p><tt>DENY_WRITE</tt> mode denies other clients write access to a file.</p></li>
<li><p><tt>DENY_BOTH</tt> mode denies other clients read and write access to a file.</p></li></ul>
<p>The Solaris NFS version 4 server fully implements these file-sharing modes. Therefore, if
a client attempts to open a file in a way that conflicts with
the current share mode, the server denies the attempt by failing the operation.
When such attempts fail with the initiation of the open or create operations,
the Solaris NFS version 4 client receives a protocol error. This error is
mapped to the application error <tt>EACCES</tt>.</p><p>Even though the protocol provides several sharing modes, currently the open operation in
Solaris does not offer multiple sharing modes. When opening a file, a Solaris
NFS version 4 client can only use the <tt>DENY_NONE</tt> mode.</p><p>Also, even though the Solaris <tt>fcntl</tt> system call has an <tt>F_SHARE</tt> command to
control file sharing, the <tt>fcntl</tt> commands cannot be implemented correctly with NFS
version 4.  If you use these <tt>fcntl</tt> commands on an NFS version
4 client, the client returns the <tt>EAGAIN</tt> error to the application.</p>

<a name="rfsrefer-140"></a><h5>Delegation in NFS Version 4</h5>
<a name="indexterm-681"></a><p>NFS version 4 provides both client support and server support for delegation. Delegation
is a technique by which the server delegates the management of a file
to a client. For example, the server could grant either a read
delegation or a write delegation to a client. Read delegations can be granted
to multiple clients at the same time, because these read delegations do not
conflict with each other. A write delegation can be granted to only one
client, because a write delegation conflicts with any file access by any other
client.  While holding a write delegation, the client would not send various
operations to the server because the client is guaranteed exclusive access to a
file. Similarly, the client would not send various operations to the server while
holding a read delegation. The reason is that the server guarantees that no
client can open the file in write mode. The effect of delegation is
to greatly reduce the interactions between the server and the client for delegated
files. Therefore, network traffic is reduced, and performance on the client and the
server is improved. Note, however, that the degree of performance improvement depends on the
kind of file interaction used by an application and the amount of
network and server congestion.</p><p>The decision about whether to grant a delegation is made entirely by the
server. A client does not request a delegation. The server makes decisions about
whether to grant a delegation, based on the access patterns for the file.
If a file has been recently accessed in write mode by several
different clients, the server might not grant a delegation. The reason is that
this access pattern indicates the potential for future conflicts.</p><p>A conflict occurs when a client accesses a file in a manner
that is inconsistent with the delegations that are currently granted for that file. For
example, if a client holds a write delegation on a file and
a second client opens that file for read or write access, the server
recalls the first client's write delegation. Similarly, if a client holds a read
delegation and another client opens the same file for writing, the server recalls
the read delegation. Note that in both situations, the second client is not
granted a delegation because a conflict now exists. When a conflict occurs, the
server uses a callback mechanism to contact the client that currently holds the
delegation. On receiving this callback, the client sends the file's updated state to
the server and returns the delegation. If the client fails to respond to
the recall, the server revokes the delegation. In such instances, the server rejects
all operations from the client for this file, and the client reports the
requested operations as failures. Generally, these failures are reported to the application as
<tt>I/O</tt> errors.  To recover from these errors, the file must be
closed and then reopened. Failures from revoked delegations can occur when a network partition
exists between the client and the server while the client holds a delegation.</p><p>Note that one server does not resolve access conflicts for a file
that is stored on another server.  Thus, an NFS server only resolves
conflicts for files that it stores. Furthermore, in response to conflicts that are
caused by clients that are running various versions of NFS, an NFS server
can only initiate recalls to the client that is running NFS version 4.
 An NFS server cannot initiate recalls for clients that are running earlier
versions of NFS.</p><p>The process for detecting conflicts varies. For example, unlike NFS version 4, because
version 2 and version 3 do not have an open procedure, the conflict
is detected only after the client attempts to read, write, or lock a
file. The server's response to these conflicts varies also.  For example:</p>
<ul><li><p>For NFS version 3, the server returns the <tt>JUKEBOX</tt> error, which causes the client to halt the access request and try again later. The client prints the message <tt>File unavailable</tt>.</p></li>
<li><p>For NFS version 2, because an equivalent of the <tt>JUKEBOX</tt> error does not exist, the server makes no response, which causes the client to wait and then try again. The client prints the message <tt>NFS server not responding</tt>.</p></li></ul>
<p>These conditions clear when the delegation conflict has been resolved.</p><p>By default, server delegation is enabled. You can disable delegation by modifying the
<tt>/etc/default/nfs</tt> file. For procedural information, refer to <a href="rfsadmin-68.html#rfsadmin-965">How to Select Different Versions of NFS on a Server</a>.</p><p>No keywords are required for client delegation. The NFS version 4 callback daemon,
<tt>nfs4cbd</tt>, provides the callback service on the client. This daemon is started automatically
whenever a mount for NFS version 4 is enabled. By default, the client
provides the necessary callback information to the server for all Internet transports that
are listed in the <tt>/etc/netconfig</tt> system file. Note that if the client
is enabled for IPv6 and if the IPv6 address for the client's name
can be determined, then the callback daemon accepts IPv6 connections.</p><p>The callback daemon uses a transient program number and a dynamically assigned port
number.  This information is provided to the server, and the server tests
the callback path before granting any delegations. If the callback path does not
test successfully, the server does not grant delegations, which is the only externally
visible behavior.</p><p>Note that because callback information is embedded within an NFS version 4 request,
the server is unable to contact the client through a device that uses
Network Address Translation (NAT).  Also, the callback daemon uses a dynamic port
number. Therefore, the server might not be able to traverse a firewall, even
if that firewall enables normal NFS traffic on port 2049.  In such
situations, the server does not grant delegations.</p>

<a name="gande"></a><h5>ACLs and <tt>nfsmapid</tt> in NFS Version 4</h5>
<a name="indexterm-682"></a><a name="indexterm-683"></a><a name="indexterm-684"></a><a name="indexterm-685"></a><p><a name="indexterm-686"></a>An access control list (ACL) provides better file security by enabling the owner
of a file to define file permissions for the file owner, the group,
and other specific users and groups. ACLs are set on the server and
the client by using the <tt>setfacl</tt> command. See the <a href="http://docs.sun.com/doc/819-2239/setfacl-1?a=view"><tt>setfacl</tt>(1)</a> man page.
In NFS version 4, the ID mapper, <tt>nfsmapid</tt>, is used to map user
or group IDs in ACL entries on a server to user or group
IDs in ACL entries on a client. The reverse is also true. The
user and group IDs in the ACL entries must exist on both the
client and the server.</p>

<a name="gandx"></a><h5>Reasons for ID Mapping to Fail</h5>
<a name="indexterm-687"></a><p>The following situations can cause ID mapping to fail:</p>
<ul><li><p>If the user or group that exists in an ACL entry on the server cannot be mapped to a valid user or group on the client, the user is not allowed to read the ACL on the client.</p><p><a name="indexterm-688"></a>For example, when you issue the <tt>ls</tt> <tt>-l</tt> command, you receive the error message, <tt>Permission denied</tt>, for the files with user or group ID ACL entities that cannot be mapped from the server to the client. The ID mapper was unable to map a user or group in the ACL. If the ID mapper had been able to map the user or group, a plus (+) sign would have appeared after the permissions in the files list that is produced by <tt>ls</tt> <tt>-l</tt>. For example:</p><pre>% ls -l
-rw-r--rw-+   1 luis    staff      11968 Aug 12  2005 foobar</pre><p><a name="indexterm-689"></a>Similarly, the <tt>getfacl</tt> command can return the <tt>Permission denied</tt> error message for the same reason. For more information about this command, see the <a href="http://docs.sun.com/doc/819-2239/getfacl-1?a=view"><tt>getfacl</tt>(1)</a> man page.</p></li>
<li><p>If the user or group ID in any ACL entry that is set on the client cannot be mapped to a valid user or group ID on the server, the <tt>setfacl</tt> command can fail and return the <tt>Permission denied</tt> error message.</p></li>
<li><p><a name="indexterm-690"></a>If the client and server have mismatched NFSMAPID_DOMAIN values, ID mapping fails. For more information, see <a href="rfsrefer-6.html#rfsrefer-133">Keywords for the <tt>/etc/default/nfs</tt> File</a>.</p></li></ul>


<a name="ganeh"></a><h5>Avoiding ID Mapping Problems With ACLs</h5>
<a name="indexterm-691"></a><a name="indexterm-692"></a><p>To avoid ID mapping problems, do the following:</p>
<ul><li><p>Make sure that the value for NFSMAPID_DOMAIN is set correctly in the <tt>/etc/default/nfs</tt> file.</p></li>
<li><p>Make sure that all user and group IDs in the ACL entries exist on both the NFS version 4 client and server.</p></li></ul>


<a name="gandj"></a><h5>Checking for Unmapped User or Group IDs</h5>
<a name="indexterm-693"></a><a name="indexterm-694"></a><p>To determine if any user or group cannot be mapped on the
server or client, use the following script:</p><pre>#! /usr/sbin/dtrace -Fs

sdt:::nfs4-acl-nobody
{
     printf("validate_idmapping: (%s) in the ACL could not be mapped!", 
stringof(arg0));
}</pre>
<hr><p><b>Note - </b>The probe name that is used in this script is an interface
that could change in the future. For more information, see <a href="http://docs.sun.com/doc/819-3620/chp-stab-1?a=view">Stability Levels in <i>Solaris Dynamic Tracing Guide</i></a>.</p>
<hr>


<a name="gandn"></a><h5>Additional Information About ACLs or <tt>nfsmapid</tt></h5>
<p>See the following:</p>
<ul><li><p><a href="http://docs.sun.com/doc/819-3321/secfile-30?a=view">Protecting Files With ACLs (Task Map) in <i>System Administration Guide: Security Services</i></a></p></li>
<li><p><a href="rfsrefer-8.html#rfsrefer-118"><tt>nfsmapid</tt> Daemon</a></p></li></ul>


<a name="rfsrefer-47"></a><h4>UDP and TCP Negotiation</h4>
<p>During initiation, the transport protocol is also negotiated. By default, the first connection-oriented
transport that is supported on both the client and the server is selected.
If this selection does not succeed, the first available connectionless transport protocol is
used. The transport protocols that are supported on a system are listed in
<tt>/etc/netconfig</tt>. TCP is the connection-oriented transport protocol that is supported by the release. UDP
is the connectionless transport protocol.</p><p>When both the NFS protocol version and the transport protocol are determined by
negotiation, the NFS protocol version is given precedence over the transport protocol. The
NFS version 3 protocol that uses UDP is given higher precedence than the
NFS version 2 protocol that is using TCP. You can manually select both
the NFS protocol version and the transport protocol with the <tt>mount</tt> command. See
the <a href="http://docs.sun.com/doc/819-2240/mount-nfs-1m?a=view"><tt>mount_nfs</tt>(1M)</a> man page. Under most conditions, allow the negotiation to select the
best options.</p>

<a name="rfsrefer-48"></a><h4>File Transfer Size Negotiation</h4>
<a name="indexterm-695"></a><a name="indexterm-696"></a><p>The file transfer size establishes the size of the buffers that are used
when transferring data between the client and the server. In general, larger transfer
sizes are better. The NFS version 3 protocol has an unlimited transfer size.
However, starting with the Solaris 2.6 release, the software bids a default buffer
size of 32 Kbytes. The client can bid a smaller transfer size at
mount time if needed, but under most conditions this bid is not
necessary.</p><p>The transfer size is not negotiated with systems that use the NFS
version 2 protocol. Under this condition, the maximum transfer size is set to
8 Kbytes.</p><p>You can use the <tt>-rsize</tt> and <tt>-wsize</tt> options to set the transfer size
manually with the <tt>mount</tt> command. You might need to reduce the transfer size
for some PC clients. Also, you can increase the transfer size if the
NFS server is configured to use larger transfer sizes.</p>
<hr><p><b>Note - </b>Starting in the Solaris 10 release, restrictions on wire transfer sizes have been
relaxed.  The transfer size is based on the capabilities of the underlying
transport.  For example, the NFS transfer limit for UDP is still 32
Kbytes.  However, because TCP is a streaming protocol without the datagram limits
of UDP, maximum transfer sizes over TCP have been increased to 1 Mbyte.</p>
<hr>


<a name="rfsrefer-49"></a><h4>How File Systems Are Mounted</h4>
<a name="indexterm-697"></a><a name="indexterm-698"></a><a name="indexterm-699"></a><a name="indexterm-700"></a><p>The following description applies to NFS version 3 mounts. The NFS version 4
mount process does not include the portmap service nor does it include
the <tt>MOUNT</tt> protocol.</p><p>When a client needs to mount a file system from a server,
the client must obtain a file handle from the server. The file handle
must correspond to the file system. This process requires that several transactions occur between
the client and the server. In this example, the client is attempting to
mount <tt>/home/terry</tt> from the server. A <tt>snoop</tt> trace for this transaction follows.</p><pre>client -> server PORTMAP C GETPORT prog=100005 (MOUNT) vers=3 proto=UDP
server -> client PORTMAP R GETPORT port=33492
client -> server MOUNT3 C Null
server -> client MOUNT3 R Null 
client -> server MOUNT3 C Mount /export/home9/terry
server -> client MOUNT3 R Mount OK FH=9000 Auth=unix
client -> server PORTMAP C GETPORT prog=100003 (NFS) vers=3 proto=TCP
server -> client PORTMAP R GETPORT port=2049
client -> server NFS C NULL3
server -> client NFS R NULL3 
client -> server NFS C FSINFO3 FH=9000
server -> client NFS R FSINFO3 OK
client -> server NFS C GETATTR3 FH=9000
server -> client NFS R GETATTR3 OK</pre><p>In this trace, the client first requests the mount port number from the
portmap service on the NFS server. After the client receives the mount port
number (<tt>33492</tt>), that number is used to test the availability of the service
on the server. After the client has determined that a service is running
on that port number, the client then makes a mount request. When the
server responds to this request, the server includes the file handle for the
file system (<tt>9000</tt>) being mounted. The client then sends a request for the
NFS port number. When the client receives the number from the server, the
client tests the availability of the NFS service (<tt>nfsd</tt>). Also, the client requests
NFS information about the file system that uses the file handle.</p><p><a name="indexterm-701"></a><a name="indexterm-702"></a>In the following trace, the client is mounting the file system with the
<tt>public</tt> option.</p><pre>client -> server NFS C LOOKUP3 FH=0000 /export/home9/terry
server -> client NFS R LOOKUP3 OK FH=9000
client -> server NFS C FSINFO3 FH=9000
server -> client NFS R FSINFO3 OK
client -> server NFS C GETATTR3 FH=9000
server -> client NFS R GETATTR3 OK</pre><p>By using the default public file handle (which is <tt>0000</tt>), all the transactions
to obtain information from the portmap service and to determine the NFS port
number are skipped.</p>
<hr><p><b>Note - </b>NFS version 4 provides support for volatile file handles. For more information, refer
to <a href="#rfsrefer-137">Volatile File Handles in NFS Version 4</a>.</p>
<hr>


<a name="rfsrefer-50"></a><h4>Effects of the <tt>-public</tt> Option and NFS URLs When Mounting</h4>
<p>Using the <tt>-public</tt> option can create conditions that cause a mount to fail.
Adding an NFS URL can also confuse the situation. The following list describes
the specifics of how a file system is mounted when you use these
options.</p>
<ul><li><p><b>Public option with NFS URL</b> &ndash; Forces the use of the public file handle. The mount fails if the public file handle is not supported.</p></li>
<li><p><b>Public option with regular path</b> &ndash; Forces the use of the public file handle. The mount fails if the public file handle is not supported.</p></li>
<li><p><b>NFS URL only</b> &ndash; Use the public file handle if this file handle is enabled on the NFS server. If the mount fails when using the public file handle, then try the mount with the <tt>MOUNT</tt> protocol.</p></li>
<li><p><b>Regular path only</b> &ndash; Do not use the public file handle. The <tt>MOUNT</tt> protocol is used.</p></li></ul>


<a name="rfsrefer-51"></a><h4>Client-Side Failover</h4>
<a name="indexterm-703"></a><p>By using client-side failover, an NFS client can be aware of multiple servers
that are making the same data available and can switch to an
alternate server when the current server is unavailable. The file system can become unavailable
if one of the following occurs. </p>
<ul><li><p>If the file system is connected to a server that crashes</p></li>
<li><p>If the server is overloaded</p></li>
<li><p>If a network fault occurs</p></li></ul>
<p>The failover, under these conditions, is normally transparent to the user. Thus, the
failover can occur at any time without disrupting the processes that are running
on the client.</p><p>Failover requires that the file system be mounted read-only. The file systems must
be identical for the failover to occur successfully. See <a href="#rfsrefer-53">What Is a Replicated File System?</a> for a
description of what makes a file system identical. A static file system or
a file system that is not changed often is the best candidate for
failover. </p><p>You cannot use CacheFS and client-side failover on the same NFS mount. Extra
information is stored for each CacheFS file system. This information cannot be updated
during failover, so only one of these two features can be used when
mounting a file system.</p><p>The number of replicas that need to be established for every file
system depends on many factors. Ideally, you should have a minimum of two
servers. Each server should support multiple subnets. This setup is better than having a
unique server on each subnet. The process requires that each listed server be
checked.  Therefore, if more servers are listed, each mount is slower.</p>

<a name="rfsrefer-52"></a><h5>Failover Terminology</h5>
<a name="indexterm-704"></a><p>To fully comprehend the process, you need to understand two terms.</p>
<ul><li><p><b>failover</b> &ndash; The process of selecting a server from a list of servers that support a replicated file system. Normally, the next server in the sorted list is used, unless it fails to respond.</p></li>
<li><p><b>remap</b> &ndash; To use a new server. Through normal use, the clients store the path name for each active file on the remote file system. During the remap, these path names are evaluated to locate the files on the new server.</p></li></ul>


<a name="rfsrefer-53"></a><h5>What Is a Replicated File System?</h5>
<a name="indexterm-705"></a><a name="indexterm-706"></a><p>For the purposes of failover, a file system can be called a
<b>replica</b> when each file is the same size and has the same
file size or file type as the original file system. Permissions, creation dates,
and other file attributes are not considered. If the file size or file
types are different, the remap fails and the process hangs until the old
server becomes available. In NFS version 4, the behavior is different. See <a href="#rfsrefer-111">Client-Side Failover in NFS Version 4</a>.</p><p>You can maintain a replicated file system by using <tt>rdist</tt>, <tt>cpio</tt>, or
another file transfer mechanism. Because updating the replicated file systems causes inconsistency, for
best results consider these precautions:</p>
<ul><li><p>Renaming the old version of the file before installing a new version of the file</p></li>
<li><p>Running the updates at night when client usage is low</p></li>
<li><p>Keeping the updates small</p></li>
<li><p>Minimizing the number of copies</p></li></ul>


<a name="rfsrefer-54"></a><h5>Failover and NFS Locking</h5>
<a name="indexterm-707"></a><a name="indexterm-708"></a><p>Some software packages require read locks on files. To prevent these products from
breaking, read locks on read-only file systems are allowed but are visible to
the client side only. The locks persist through a remap because the server
does not &ldquo;know&rdquo; about the locks. Because the files should not change, you
do not need to lock the file on the server side.</p>

<a name="rfsrefer-111"></a><h5>Client-Side Failover in NFS Version 4</h5>
<a name="indexterm-709"></a><p>In NFS version 4, if a replica cannot be established because the
file sizes are different or the file types are not the same, then
the following happens.</p>
<ul><li><p>The file is marked dead.</p></li>
<li><p>A warning is printed.</p></li>
<li><p>The application receives a system call failure.</p></li></ul>

<hr><p><b>Note - </b>If you restart the application and try again to access the file, you
should be successful.</p>
<hr>
<p>In NFS version 4, you no longer receive replication errors for directories of
different sizes. In prior versions of NFS,  this condition was treated as
an error and would impede the remapping process.</p><p>Furthermore, in NFS version 4, if a directory read operation is unsuccessful, the
operation is performed by the next listed server. In previous versions of NFS,
unsuccessful read operations would cause the remap to fail and the process to
hang until the original server was available.</p>

<a name="rfsrefer-55"></a><h4>Large Files</h4>
<a name="indexterm-710"></a><p>Starting with the Solaris 2.6 release, the Solaris OS supports files that are
over 2 Gbytes. By default, UFS file systems are mounted with the
<tt>-largefiles</tt> option to support the new capability. Previous releases cannot handle files of
this size. See <a href="rfsadmin-61.html#rfsadmin-75">How to Disable Large Files on an NFS Server</a> for instructions.</p><p>If the server's file system is mounted with the <tt>-largefiles</tt> option, a Solaris
2.6 NFS client can access large files without the need for changes. However,
not all Solaris 2.6 commands can handle these large files. See <a href="http://docs.sun.com/doc/819-2252/largefile-5?a=view"><tt>largefile</tt>(5)</a>
for a list of the commands that can handle the large files. Clients
that cannot support the NFS version 3 protocol with the large file extensions
cannot access any large files. Although clients that run the Solaris 2.5 release
can use the NFS version 3 protocol, large file support was not included
in that release.</p>

<a name="rfsrefer-105"></a><h4>How NFS Server Logging Works</h4>
<p>NFS server logging provides records of NFS reads and writes, as well as
operations that modify the file system. This data can be used to
track access to information. In addition, the records can provide a quantitative way to
measure interest in the information.</p><p>When a file system with logging enabled is accessed, the kernel writes raw
data into a buffer file. This data includes the following:</p>
<ul><li><p>A timestamp</p></li>
<li><p>The client IP address</p></li>
<li><p>The UID of the requester</p></li>
<li><p>The file handle of the file or directory object that is being accessed</p></li>
<li><p>The type of operation that occurred</p></li></ul>
<p>The <tt>nfslogd</tt> daemon converts this raw data into ASCII records that are stored
in log files. During the conversion, the IP addresses are modified to host
names and the UIDs are modified to logins if the name service that
is enabled can find matches. The file handles are also converted into path
names. To accomplish the conversion, the daemon tracks the file handles and stores
information in a separate file handle-to-path table. That way, the path does not
have to be identified again each time a file handle is accessed. Because
no changes to the mappings are made in the file handle-to-path table if
<tt>nfslogd</tt> is turned off, you must keep the daemon running.</p>
<hr><p><b>Note - </b>Server logging is not supported in NFS version 4.</p>
<hr>


<a name="rfsrefer-56"></a><h4>How the WebNFS Service Works</h4>
<a name="indexterm-711"></a><p>The WebNFS service makes files in a directory available to clients by using
a public file handle. A file handle is an address that is
generated by the kernel that identifies a file for NFS clients. The <b>public file handle</b>
has a predefined value, so the server does not need to generate a
file handle for the client. The ability to use this predefined file handle
reduces network traffic by eliminating the <tt>MOUNT</tt> protocol. This ability should also accelerate
processes for the clients.</p><p>By default, the public file handle on an NFS server is established
on the root file system. This default provides WebNFS access to any clients
that already have mount privileges on the server. You can change the public
file handle to point to any file system by using the <tt>share</tt> command.</p><p>When the client has the file handle for the file system, a
<tt>LOOKUP</tt> is run to determine the file handle for the file to be
accessed. The NFS protocol allows the evaluation of only one path name component
at a time. Each additional level of directory hierarchy requires another <tt>LOOKUP</tt>. A WebNFS
server can evaluate an entire path name with a single multi-component lookup transaction
when the <tt>LOOKUP</tt> is relative to the public file handle. Multi-component lookup enables
the WebNFS server to deliver the file handle to the desired file without
exchanging the file handles for each directory level in the path name.</p><p>In addition, an NFS client can initiate concurrent downloads over a single TCP
connection. This connection provides quick access without the additional load on the server
that is caused by setting up multiple connections. Although web browser applications support
concurrent downloading of multiple files, each file has its own connection. By using
one connection, the WebNFS software reduces the overhead on the server.</p><p>If the final component in the path name is a symbolic link
to another file system, the client can access the file if the client
already has access through normal NFS activities.</p><p>Normally, an NFS URL is evaluated relative to the public file handle. The
evaluation can be changed to be relative to the server's root file
system by adding an additional slash to the beginning of the path. In
this example, these two NFS URLs are equivalent if the public file handle
has been established on the <tt>/export/ftp</tt> file system.</p><pre>nfs://server/junk
nfs://server//export/ftp/junk</pre>
<hr><p><b>Note - </b>The NFS version 4 protocol is preferred over the WebNFS service. NFS version
4 fully integrates all the security negotiation that was added to the MOUNT
protocol and the WebNFS service.</p>
<hr>


<a name="egcod"></a><h4>How WebNFS Security Negotiation Works</h4>
<p>The Solaris 8 release includes a new protocol that enables a WebNFS client
to negotiate a selected security mechanism with a WebNFS server.  The new
protocol uses security negotiation multi-component lookup, which is an extension to the multi-component
lookup that was used in earlier versions of the WebNFS protocol.</p><p>The WebNFS client initiates the process by making a regular multi&ndash;component lookup request
by using the public file handle. Because the client has no knowledge of
how the path is protected by the server, the default security mechanism is
used. If the default security mechanism is not sufficient, the server replies with
an <tt>AUTH_TOOWEAK</tt> error. This reply indicates that the default mechanism is not valid.
The client needs to use a stronger default mechanism.</p><p>When the client receives the <tt>AUTH_TOOWEAK</tt> error, the client sends a request to
the server to determine which security mechanisms are required. If the request succeeds,
the server responds with an array of security mechanisms that are required for
the specified path. Depending on the size of the array of security mechanisms,
the client might have to make more requests to obtain the complete array.
If the server does not support WebNFS security negotiation, the request fails.</p><p>After a successful request, the WebNFS client selects the first security mechanism from
the array that the client supports. The client then issues a regular multi-component
lookup request by using the selected security mechanism to acquire the file handle.
All subsequent NFS requests are made by using the selected security mechanism and
the file handle.</p>
<hr><p><b>Note - </b>The NFS version 4 protocol is preferred over the WebNFS service. NFS version
4 fully integrates all the security negotiation that was added to the MOUNT
protocol and the WebNFS service.</p>
<hr>


<a name="rfsrefer-57"></a><h4>WebNFS Limitations With Web Browser Use</h4>
<p>Several functions that a web site that uses HTTP can provide are
not supported by the WebNFS software. These differences stem from the fact that the
NFS server only sends the file, so any special processing must be
done on the client. If you need to have one web site configured
for both WebNFS and HTTP access, consider the following issues:</p>
<ul><li><p>NFS browsing does not run CGI scripts. So, a file system with an active web site that uses many CGI scripts might not be appropriate for NFS browsing.</p></li>
<li><p>The browser might start different viewers to handle files in different file formats. Accessing these files through an NFS URL starts an external viewer if the file type can be determined by the file name. The browser should recognize any file name extension for a standard MIME type when an NFS URL is used. The WebNFS software does not check inside the file to determine the file type. So, the only way to determine a file type is by the file name extension.</p></li>
<li><p>NFS browsing cannot utilize server-side image maps (clickable images). However, NFS browsing can utilize client-side image maps (clickable images) because the URLs are defined with the location. No additional response is required from the document server.</p></li></ul>


<a name="rfsrefer-58"></a><h4>Secure NFS System</h4>
<p><a name="indexterm-712"></a><a name="indexterm-713"></a><a name="indexterm-714"></a><a name="indexterm-715"></a><a name="indexterm-716"></a><a name="indexterm-717"></a><a name="indexterm-718"></a><a name="indexterm-719"></a><a name="indexterm-720"></a>The NFS environment is a powerful way and convenient way to share file
systems on a network of different computer architectures and operating systems. However, the
same features that make sharing file systems through NFS operation convenient also pose
some security problems. Historically, most NFS implementations have used UNIX (or AUTH_SYS) authentication,
but stronger authentication methods such as AUTH_DH have also been available. When using UNIX
authentication, an NFS server authenticates a file request by authenticating the computer that
makes the request, but not the user. Therefore, a client user can run
<tt>su</tt> and impersonate the owner of a file. If DH authentication is used,
the NFS server authenticates the user, making this sort of impersonation much harder.</p><p>With root access and knowledge of network programming, anyone can introduce arbitrary data
into the network and extract any data from the network. The most dangerous
attacks are those attacks that involve the introduction of data. An example is
the impersonation of a user by generating the right packets or by recording
&ldquo;conversations&rdquo; and replaying them later. These attacks affect data integrity. Attacks that involve
passive eavesdropping, which is merely listening to network traffic without impersonating anybody, are not
as dangerous, because data integrity is not compromised. Users can protect the privacy
of sensitive information by encrypting data that is sent over the network. </p><p>A common approach to network security problems is to leave the solution to
each application. A better approach is to implement a standard authentication system at
a level that covers all applications. </p><p>The Solaris operating system includes an authentication system at the level of the
remote procedure call (RPC), which is the mechanism on which the NFS operation
is built. This system, known as Secure RPC, greatly improves the security of
network environments and provides additional security to services such as the NFS system.
When the NFS system uses the facilities that are provided by Secure RPC,
it is known as a Secure NFS system. </p>

<a name="rfsrefer-59"></a><h4>Secure RPC</h4>
<p><a name="indexterm-721"></a><a name="indexterm-722"></a><a name="indexterm-723"></a><a name="indexterm-724"></a><a name="indexterm-725"></a><a name="indexterm-726"></a><a name="indexterm-727"></a>Secure RPC is fundamental to the Secure NFS system.  The goal of
Secure RPC is to build a system that is at minimum as
secure as a time-sharing system.  In a time-sharing system all users share
a single computer. A time-sharing system authenticates a user through a login password.
With Data Encryption Standard (DES) authentication, the same authentication process is completed. Users can
log in on any remote computer just as users can log in
on a local terminal. The users' login passwords are their assurance of network
security. In a time-sharing environment, the system administrator has an ethical obligation not to
change a password to impersonate someone. In Secure RPC, the network administrator is
trusted not to alter entries in a database that stores <b>public keys</b>.</p><p><a name="indexterm-728"></a><a name="indexterm-729"></a>You need to be familiar with two terms to understand an RPC
authentication system: credentials and verifiers. Using ID badges as an example, the credential is
what identifies a person: a name, address, and birthday. The verifier is the
photo that is attached to the badge. You can be sure that
the badge has not been stolen by checking the photo on the badge
against the person who is carrying the badge. In RPC, the client process
sends both a credential and a verifier to the server with each RPC
request. The server sends back only a verifier because the client already &ldquo;knows&rdquo;
the server's credentials. </p><p><a name="indexterm-730"></a><a name="indexterm-731"></a>RPC's authentication is open ended, which means that a variety of authentication systems
can be plugged into it, such as UNIX, DH, and KERB. </p><p><a name="indexterm-732"></a><a name="indexterm-733"></a><a name="indexterm-734"></a><a name="indexterm-735"></a>When UNIX authentication is used by a network service, the credentials contain the
client's host name, UID, GID, and group-access list. However, the verifier contains nothing.
Because no verifier exists, a superuser could falsify appropriate credentials by using commands
such as <tt>su</tt>. Another problem with UNIX authentication is that UNIX authentication assumes all
computers on a network are UNIX computers. UNIX authentication breaks down when applied
to other operating systems in a heterogeneous network. </p><p><a name="indexterm-736"></a><a name="indexterm-737"></a><a name="indexterm-738"></a><a name="indexterm-739"></a><a name="indexterm-740"></a>To overcome the problems of UNIX authentication, Secure RPC uses DH authentication. 
   </p>

<a name="rfsrefer-60"></a><h5>DH Authentication</h5>
<p><a name="indexterm-741"></a><a name="indexterm-742"></a><a name="indexterm-743"></a><a name="indexterm-744"></a><a name="indexterm-745"></a><a name="indexterm-746"></a><a name="indexterm-747"></a><a name="indexterm-748"></a>DH authentication uses the Data Encryption Standard (DES) and Diffie-Hellman public-key cryptography to
authenticate both users and computers in the network. DES is a standard encryption
mechanism. Diffie-Hellman public-key cryptography is a cipher system that involves two keys: one
public and one secret. The public keys and secret keys are stored in
the namespace. NIS stores the keys in the public-key map. These maps contain
the public key and secret key for all potential users. See the <a href="http://docs.sun.com/doc/819-3194"><i>System Administration Guide: Naming and Directory Services (DNS, NIS, and LDAP)</i></a>
 for more information about how to set up the maps. </p><p>The security of DH authentication is based on a sender's ability to encrypt
the current time, which the receiver can then decrypt and check against its
own clock. The timestamp is encrypted with DES. The requirements for this scheme
to work are as follows:</p>
<ul><li><p>The two agents must agree on the current time.</p></li>
<li><p>The sender and receiver must be using the same encryption key.</p></li></ul>
<p><a name="indexterm-749"></a><a name="indexterm-750"></a><a name="indexterm-751"></a>If a network runs a time-synchronization program, the time on the client and
the server is synchronized automatically. If a time-synchronization program is not available, timestamps
can be computed by using the server's time instead of the network time.
The client asks the server for the time before starting the RPC session,
then computes the time difference between its own clock and the server's. This
difference is used to offset the client's clock when computing timestamps. If the
client and server clocks become unsynchronized the server begins to reject the client's
requests. The DH authentication system on the client resynchronizes with the server. </p><p><a name="indexterm-752"></a><a name="indexterm-753"></a><a name="indexterm-754"></a><a name="indexterm-755"></a><a name="indexterm-756"></a><a name="indexterm-757"></a><a name="indexterm-758"></a>The client and server arrive at the same encryption key by generating a
random <b>conversation key</b>, also known as the <b>session key</b>, and by using public-key cryptography
to deduce a <b>common key</b>. The common key is a key that only
the client and server are capable of deducing. The conversation key is used
to encrypt and decrypt the client's timestamp. The common key is used to
encrypt and decrypt the conversation key. </p>

<a name="rfsrefer-61"></a><h5>KERB Authentication</h5>
<p>Kerberos is an authentication system that was developed at MIT. Kerberos offers a
variety of encryption types, including DES. Kerberos support is no longer supplied as
part of Secure RPC, but starting in the Solaris 9 release a server-side
and client-side implementation is included. See <a href="http://docs.sun.com/doc/819-3321/intro-1?a=view">Chapter 20, Introduction to the Kerberos Service, in <i>System Administration Guide: Security Services</i></a> for more information about the implementation
of Kerberos authentication.</p>

<a name="rfsrefer-62"></a><h5>Using Secure RPC With NFS</h5>
<p><a name="indexterm-759"></a><a name="indexterm-760"></a><a name="indexterm-761"></a>Be aware of the following points if you plan to use Secure
RPC:   </p>
<ul><li><p><a name="indexterm-762"></a><a name="indexterm-763"></a><a name="indexterm-764"></a><a name="indexterm-765"></a><a name="indexterm-766"></a><a name="indexterm-767"></a>If a server crashes when no one is around (after a power failure, for example), all the secret keys that are stored on the system are deleted. Now no process can access secure network services or mount an NFS file system. The important processes during a reboot are usually run as <tt>root</tt>. Therefore, these processes would work if root's secret key were stored away, but nobody is available to type the password that decrypts it. <tt>keylogin -r</tt> allows <tt>root</tt> to store the clear secret key in <tt>/etc/.rootkey</tt>, which <tt>keyserv</tt> reads. </p></li>
<li><p><a name="indexterm-768"></a>Some systems boot in single-user mode, with a root login shell on the console and no password prompt. Physical security is imperative in such cases. </p></li>
<li><p><a name="indexterm-769"></a><a name="indexterm-770"></a>Diskless computer booting is not totally secure. Somebody could impersonate the boot server and boot a devious kernel that, for example, makes a record of your secret key on a remote computer. The Secure NFS system provides protection only after the kernel and the key server are running. Otherwise, no way exists to authenticate the replies that are given by the boot server. This limitation could be a serious problem, but the limitation requires a sophisticated attack, using kernel source code. Also, the crime would leave evidence. If you polled the network for boot servers, you would discover the devious boot server's location. </p></li>
<li><p><a name="indexterm-771"></a>Most setuid programs are owned by <tt>root</tt>. If the secret key for <tt>root</tt> is stored in <tt>/etc/.rootkey</tt>, these programs behave as they always have. If a setuid program is owned by a user, however, the setuid program might not always work. For example, suppose that a setuid program is owned by <tt>dave</tt> and <tt>dave</tt> has not logged into the computer since it booted. The program would not be able to access secure network services. </p></li>
<li><p><a name="indexterm-772"></a><a name="indexterm-773"></a><a name="indexterm-774"></a><a name="indexterm-775"></a><a name="indexterm-776"></a>If you log in to a remote computer (using <tt>login</tt>, <tt>rlogin</tt>, or <tt>telnet</tt>) and use <tt>keylogin</tt> to gain access, you give access to your account. The reason is that your secret key is passed to that computer's key server, which then stores your secret key. This process is only a concern if you do not trust the remote computer. If you have doubts, however, do not log in to a remote computer if the remote computer requires a password. Instead, use the NFS environment to mount file systems that are shared by the remote computer. As an alternative, you can use <tt>keylogout</tt> to delete the secret key from the key server.</p></li>
<li><p><a name="indexterm-777"></a><a name="indexterm-778"></a><a name="indexterm-779"></a>If a home directory is shared with the <tt>-o sec=dh</tt> option, remote logins can be a problem. If the <tt>/etc/hosts.equiv</tt> or <tt>~/.rhosts</tt> files are not set to prompt for a password, the login succeeds. However, the users cannot access their home directories because no authentication has occurred locally. If the user is prompted for a password, the user has access to his or her home directory if the password matches the network password. </p></li></ul>

         </div>
      </td>
   </tr>

   <tr class="PageControls" valign="top">
      <td></td>
      <td>
         <table width="100%">
      	   <tr>
      	     <td>
                 <a href="rfsrefer-154.html">Previous</a>
             </td>
             <td align="right">
                 <a href="rfsrefer-66.html">Next</a>
             </td>
           </tr>
         </table>
      </td>
   </tr>
</tbody>
</table>


</body>
</html>

