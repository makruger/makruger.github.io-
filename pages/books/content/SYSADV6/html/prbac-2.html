<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="en-US">
<head>
<meta http-equiv="Content-type" content="text/html; charset=iso-8859-1">
<title>Privileges (Overview) - System Administration Guide: Security Services</title>
<meta name="robots" content="index,follow">
<meta name="robots" content="index,follow">
<meta name="date" content="2008-08-01">
<meta name="collection" content="reference">
<link rel="stylesheet" type="text/css" href="css/elements.css">
<link rel="stylesheet" type="text/css" href="css/indiana.css">
</head>

<body>


<div class="Masthead">
   <div class="MastheadLogo">
      <a href="http://www.opensolaris.org"><img border="0" src="graphics/header.png"></img></a>
   </div>
   <div class="Title">System Administration Guide: Security Services</div>
</div>

<table class="Layout" border="0" cellspacing="0" width="100%">
<tbody>

   <tr valign="top" class="PageControls">
      <td></td>
      <td>
         <table width="100%">
      	   <tr>
      	     <td>
                 <a href="rbac-1.html">Previous</a>
             </td>
             <td align="right">
                 <a href="rbactask-1.html">Next</a>
             </td>
           </tr>
         </table>
      </td>
   </tr>
   
   <tr valign="top">
      <td class="Navigation" width="200px"><p class="toc level1"><a href="docinfo.html">Document Information</a></p>
<p class="toc level1 tocsp"><a href="preface-1.html">Preface</a></p>
<p class="toc level1 tocsp"><a href="oview-1.html">Part&nbsp;I&nbsp;Security Overview</a></p>
<p class="toc level2"><a href="secov-1.html">1.&nbsp;&nbsp;Security Services (Overview)</a></p>
<p class="toc level1 tocsp"><a href="sectm-1.html">Part&nbsp;II&nbsp;System, File, and Device Security</a></p>
<p class="toc level2"><a href="concept-1.html">2.&nbsp;&nbsp;Managing Machine Security (Overview)</a></p>
<p class="toc level2"><a href="secsys-1.html">3.&nbsp;&nbsp;Controlling Access to Systems (Tasks)</a></p>
<p class="toc level2"><a href="vscan-1.html">4.&nbsp;&nbsp;Virus Scanning Service (Tasks)</a></p>
<p class="toc level2"><a href="devtask-1.html">5.&nbsp;&nbsp;Controlling Access to Devices (Tasks)</a></p>
<p class="toc level2"><a href="bart-1.html">6.&nbsp;&nbsp;Using the Basic Audit Reporting Tool (Tasks)</a></p>
<p class="toc level2"><a href="secfile-1.html">7.&nbsp;&nbsp;Controlling Access to Files (Tasks)</a></p>
<p class="toc level1 tocsp"><a href="prbactm-1.html">Part&nbsp;III&nbsp;Roles, Rights Profiles, and Privileges</a></p>
<p class="toc level2"><a href="prbac-1.html">8.&nbsp;&nbsp;Using Roles and Privileges (Overview)</a></p>
<p class="toc level3"><a href="rbac-1.html">Role-Based Access Control (Overview)</a></p>
<div class="onpage">
<p class="toc level3"><a href="">Privileges (Overview)</a></p>
</div>
<p class="toc level2 tocsp"><a href="rbactask-1.html">9.&nbsp;&nbsp;Using Role-Based Access Control (Tasks)</a></p>
<p class="toc level2"><a href="rbacref-1.html">10.&nbsp;&nbsp;Role-Based Access Control (Reference)</a></p>
<p class="toc level2"><a href="privtask-1.html">11.&nbsp;&nbsp;Privileges (Tasks)</a></p>
<p class="toc level2"><a href="privref-1.html">12.&nbsp;&nbsp;Privileges (Reference)</a></p>
<p class="toc level1 tocsp"><a href="scftm-1.html">Part&nbsp;IV&nbsp;Solaris Cryptographic Services</a></p>
<p class="toc level2"><a href="scf-1.html">13.&nbsp;&nbsp;Solaris Cryptographic Framework (Overview)</a></p>
<p class="toc level2"><a href="scftask-1.html">14.&nbsp;&nbsp;Solaris Cryptographic Framework (Tasks)</a></p>
<p class="toc level2"><a href="kmf-1.html">15.&nbsp;&nbsp;Solaris Key Management Framework</a></p>
<p class="toc level1 tocsp"><a href="authtm-1.html">Part&nbsp;V&nbsp;Authentication Services and Secure Communication</a></p>
<p class="toc level2"><a href="auth-1.html">16.&nbsp;&nbsp;Using Authentication Services (Tasks)</a></p>
<p class="toc level2"><a href="pam-1.html">17.&nbsp;&nbsp;Using PAM</a></p>
<p class="toc level2"><a href="sasl-1.html">18.&nbsp;&nbsp;Using SASL</a></p>
<p class="toc level2"><a href="sshuser-1.html">19.&nbsp;&nbsp;Using Solaris Secure Shell (Tasks)</a></p>
<p class="toc level2"><a href="sshref-1.html">20.&nbsp;&nbsp;Solaris Secure Shell (Reference)</a></p>
<p class="toc level1 tocsp"><a href="seamtm-1.html">Part&nbsp;VI&nbsp;Kerberos Service</a></p>
<p class="toc level2"><a href="intro-1.html">21.&nbsp;&nbsp;Introduction to the Kerberos Service</a></p>
<p class="toc level2"><a href="seamplan-1.html">22.&nbsp;&nbsp;Planning for the Kerberos Service</a></p>
<p class="toc level2"><a href="setup-8.html">23.&nbsp;&nbsp;Configuring the Kerberos Service (Tasks)</a></p>
<p class="toc level2"><a href="trouble-1.html">24.&nbsp;&nbsp;Kerberos Error Messages and Troubleshooting</a></p>
<p class="toc level2"><a href="aadmin-1.html">25.&nbsp;&nbsp;Administering Kerberos Principals and Policies (Tasks)</a></p>
<p class="toc level2"><a href="user-7.html">26.&nbsp;&nbsp;Using Kerberos Applications (Tasks)</a></p>
<p class="toc level2"><a href="refer-1.html">27.&nbsp;&nbsp;The Kerberos Service (Reference)</a></p>
<p class="toc level1 tocsp"><a href="audittm-1.html">Part&nbsp;VII&nbsp;Solaris Auditing</a></p>
<p class="toc level2"><a href="auditov-1.html">28.&nbsp;&nbsp;Solaris Auditing (Overview)</a></p>
<p class="toc level2"><a href="auditplan-1.html">29.&nbsp;&nbsp;Planning for Solaris Auditing</a></p>
<p class="toc level2"><a href="audittask-1.html">30.&nbsp;&nbsp;Managing Solaris Auditing (Tasks)</a></p>
<p class="toc level2"><a href="auditref-1.html">31.&nbsp;&nbsp;Solaris Auditing (Reference)</a></p>
<p class="toc level1 tocsp"><a href="glossary-2.html">Glossary</a></p>
<p class="toc level1 tocsp"><a href="idx-1.html">Index</a></p>
</td>
      <td class="ContentPane" width="705px">

	 <div class="MainContent">      	 
             

<a name="prbac-2"></a><h3>Privileges (Overview)</h3>
<a name="indexterm-1061"></a><a name="indexterm-1062"></a><a name="indexterm-1063"></a><a name="indexterm-1064"></a><a name="indexterm-1065"></a><p>Process rights management enables processes to be restricted at the command, user, role,
or system level. The Solaris OS implements process rights management through <b>privileges</b>. Privileges
decrease the security risk that is associated with one user or one process
having full superuser capabilities on a system. Privileges and RBAC provide a compelling alternative
model to the traditional superuser model.</p>
<ul><li><p>For information on RBAC, see <a href="rbac-1.html">Role-Based Access Control (Overview)</a>.</p></li>
<li><p>For information on how to administer privileges, see <a href="privtask-1.html">Chapter&nbsp;11, Privileges (Tasks)</a>.</p></li>
<li><p>For reference information on privileges, see <a href="privref-1.html">Chapter&nbsp;12, Privileges (Reference)</a>.</p></li></ul>


<a name="prbac-10"></a><h4>Privileges Protect Kernel Processes</h4>
<p><a name="indexterm-1066"></a>A privilege is a discrete right that a process requires to perform an
operation. The right is enforced in the kernel. A program that operates within
the bounds of the Solaris <b>basic set</b> of privileges operates within the bounds of
the system security policy. <tt>setuid</tt> programs are examples of programs that operate
outside the bounds of the system security policy. By using privileges, programs eliminate
the need for calls to <tt>setuid</tt>.</p><p>Privileges discretely enumerate the kinds of operations that are possible on a system.
Programs can be run with the exact privileges that enable the program to
succeed. For example, a program that sets the date and writes the date
to an administrative file might require the <tt>file_dac_write</tt> and <tt>sys_time</tt> privileges. This
capability eliminates the need to run any program as <tt>root</tt>.</p><p>Historically, systems have not followed the privilege model. Rather, systems used the superuser
model.  In the superuser model, processes run as <tt>root</tt> or as
a user. User processes were limited to acting on the user's directories and
files. <tt>root</tt> processes could create directories and files anywhere on the system. A
process that required creation of a directory outside the user's directory would run
with a <tt>UID=0</tt>, that is, as <tt>root</tt>. Security policy relied on DAC, discretionary access
control, to protect system files. Device nodes were protected by DAC. For example,
devices owned by group <tt>sys</tt> could be opened only by members of group
<tt>sys</tt>.</p><p>However, <tt>setuid</tt> programs, file permissions, and administrative accounts are vulnerable to misuse. The
actions that a <tt>setuid</tt> process is permitted are more numerous than the process
requires to complete its operation. A <tt>setuid</tt> program can be compromised by an
intruder who then runs as the all-powerful <tt>root</tt> user. Similarly, any user with access
to the <tt>root</tt> password can compromise the entire system.</p><p>In contrast, a system that enforces policy with privileges allows a gradation between
user capabilities and <tt>root</tt> capabilities. A user can be granted privileges to perform
activities that are beyond the capabilities of ordinary users, and <tt>root</tt> can be
limited to fewer privileges than <tt>root</tt> currently possesses. With RBAC, a command that runs
with privileges can be isolated in a rights profile and assigned to one
user or role. <a href="rbac-1.html#rbac-tbl-7">Table&nbsp;8-1</a> summarizes the gradation between user capabilities and root
capabilities that the RBAC plus privileges model provides.</p><p>The privilege model provides greater security than the superuser model. Privileges that have
been removed from a process cannot be exploited. Process privileges prevent a program
or administrative account from gaining access to all capabilities. Process privileges can provide
an additional safeguard for sensitive files, where DAC protections alone can be exploited
to gain access.</p><p><a name="indexterm-1067"></a><a name="indexterm-1068"></a>Privileges, then, can restrict programs and processes to just the capabilities that the
program requires. This capability is called the <b>principle of least privilege</b>. On a system that
implements least privilege, an intruder who captures a process has access to only
those privileges that the process has. The rest of the system cannot be
compromised.</p>

<a name="prbac-14"></a><h4>Privilege Descriptions</h4>
<p><a name="indexterm-1069"></a><a name="indexterm-1070"></a>Privileges are logically grouped on the basis of the area of the privilege.</p>
<ul><li><p><a name="indexterm-1071"></a><a name="indexterm-1072"></a><tt>FILE</tt> <b>privileges &ndash;</b> Privileges that begin with the string <tt>file</tt> operate on file system objects. For example, the <tt>file_dac_write</tt> privilege overrides discretionary access control when writing to files.</p></li>
<li><p><a name="indexterm-1073"></a><a name="indexterm-1074"></a><tt>IPC</tt> <b>privileges &ndash;</b> Privileges that begin with the string <tt>ipc</tt> override IPC object access controls. For example, the <tt>ipc_dac_read</tt> privilege enables a process to read remote shared memory that is protected by DAC.</p></li>
<li><p><a name="indexterm-1075"></a><a name="indexterm-1076"></a><tt>NET</tt> <b>privileges &ndash;</b> Privileges that begin with the string <tt>net</tt> give access to specific network functionality. For example, the <tt>net_rawaccess</tt> privilege enables a device to connect to the network.</p></li>
<li><p><a name="indexterm-1077"></a><a name="indexterm-1078"></a><tt>PROC</tt> <b>privileges &ndash;</b> Privileges that begin with the string <tt>proc</tt> allow processes to modify restricted properties of the process itself. <tt>PROC</tt> privileges include privileges that have a very limited effect. For example, the <tt>proc_clock_highres</tt> privilege enables a process to use high resolution timers.</p></li>
<li><p><a name="indexterm-1079"></a><a name="indexterm-1080"></a><tt>SYS</tt> <b>privileges &ndash;</b> Privileges that begin with the string <tt>sys</tt> give processes unrestricted access to various system properties. For example, the <tt>sys_linkdir</tt> privilege enables a process to make and break hard links to directories.</p></li></ul>
<p>Some privileges have a limited effect on the system, and some have
a broad effect. The definition of the <tt>proc_taskid</tt> privilege indicates its limited effect:</p><pre>proc_taskid
        Allows a process to assign a new task ID to the calling process.</pre><p>The definition of the <tt>file_setid</tt> privilege indicates its broad effect:</p><pre>net_rawaccess
        Allow a process to have direct access to  the  network layer.</pre><p><a name="indexterm-1081"></a>The <a href="http://docs.sun.com/doc/819-2252/privileges-5?a=view"><tt>privileges</tt>(5)</a> man page provides descriptions of every privilege. The command <tt>ppriv -lv</tt> prints
a description of every privilege to standard out.</p>

<a name="prbac-16"></a><h4>Administrative Differences on a System With Privileges</h4>
<p><a name="indexterm-1082"></a><a name="indexterm-1083"></a><a name="indexterm-1084"></a>A system that has privileges has several visible differences from a system that
does not have privileges. The following table lists some of the differences.</p><a name="prbac-tbl-1"></a><h6>Table&nbsp;8-2 Visible Differences Between a System With Privileges and a System Without Privileges</h6><table><col width="13%"><col width="34%"><col width="52%"><tr><th align="left" valign="top" scope="column"><p>Feature</p></th>
<th align="left" valign="top" scope="column"><p>No Privileges</p></th>
<th align="left" valign="top" scope="column"><p>Privileges</p></th>
</tr>
<tr><td align="left" valign="top" scope="row"><p>Daemons</p></td>
<td align="left" valign="top" scope="row"><p>Daemons
run as <tt>root</tt>.</p></td>
<td align="left" valign="top" scope="row"><p><a name="indexterm-1085"></a>Daemons run as the user <tt>daemon</tt>.</p><p>For example, the following daemons
have been assigned appropriate privileges and run as <tt>daemon</tt>: <tt>lockd</tt>, <tt>mountd</tt>, <tt>nfsd</tt>, and
<tt>rpcbind</tt>.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p>Log File Ownership</p></td>
<td align="left" valign="top" scope="row"><p>Log files are owned by <tt>root</tt>.</p></td>
<td align="left" valign="top" scope="row"><p>Log files are now owned
by <tt>daemon</tt>, who created the log file. The <tt>root</tt> user does not own
the file.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p>Error Messages</p></td>
<td align="left" valign="top" scope="row"><p>Error messages refer to superuser.</p><p>For example, <tt>chroot: not superuser</tt>.</p></td>
<td align="left" valign="top" scope="row"><p>Error messages reflect the
use of privileges.</p><p>For example, the equivalent error message for <tt>chroot</tt> failure is <tt>chroot: exec failed</tt>.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>setuid</tt>
Programs</p></td>
<td align="left" valign="top" scope="row"><p>Programs use <tt>setuid</tt> to complete tasks that ordinary users are not allowed to
perform.</p></td>
<td align="left" valign="top" scope="row"><p>Many <tt>setuid</tt> programs have been changed to run with privileges.</p><p>For example, the following
utilities use privileges: <tt>ufsdump</tt>, <tt>ufsrestore</tt>, <tt>rsh</tt>, <tt>rlogin</tt>, <tt>rcp</tt>, <tt>rdist</tt>, <tt>ping</tt>, <tt>traceroute</tt>, and
<tt>newtask</tt>.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p>File Permissions</p></td>
<td align="left" valign="top" scope="row"><p>Device permissions are controlled by DAC. For example, members of the group
<tt>sys</tt> can open <tt>/dev/ip</tt>.</p></td>
<td align="left" valign="top" scope="row"><p>File permissions (DAC) do not predict who can open
a device. Devices are protected with DAC <b>and</b> device policy.</p><p>For example, the <tt>/dev/ip</tt>
file has <tt>666</tt> permissions, but the device can only be opened by a
process with the appropriate privileges. Raw sockets are still protected by DAC.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p>Audit Events</p></td>
<td align="left" valign="top" scope="row"><p>Auditing
the use of the <tt>su</tt> command covers many administrative functions.</p></td>
<td align="left" valign="top" scope="row"><p>Auditing the use of
privileges covers most administrative functions. The <tt>pm</tt> and <tt>as</tt> audit classes include audit events
that configure device policy and audit events that set privileges.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p>Processes</p></td>
<td align="left" valign="top" scope="row"><p>Processes are protected
by who owns the process.</p></td>
<td align="left" valign="top" scope="row"><p>Processes are protected by privileges. Process privileges and
process flags are visible as a new entry in the <tt>/proc/&lt;pid&gt;</tt> directory, <tt>priv</tt>.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p>Debugging</p></td>
<td align="left" valign="top" scope="row"><p>No
reference to privileges in core dumps.</p></td>
<td align="left" valign="top" scope="row"><p>The ELF note section of core dumps
includes information about process privileges and flags in the <tt>NT_PRPRIV</tt> and <tt>NT_PRPRIVINFO</tt> notes.</p><p>The
<tt>ppriv</tt> utility and other utilities show the proper number of properly sized sets.
The utilities correctly map the bits in the bit sets to privilege names.</p></td>
</tr>
</table>

<a name="prbac-24"></a><h4>Privileges and System Resources</h4>
<a name="indexterm-1086"></a><a name="indexterm-1087"></a><a name="indexterm-1088"></a><a name="indexterm-1089"></a><a name="indexterm-1090"></a><a name="indexterm-1091"></a><a name="indexterm-1092"></a><p>In the Solaris Express Community Edition, the <tt>project.max-locked-memory</tt> and <tt>zone.max-locked-memory</tt> resource controls can
be used to limit the memory consumption of processes that are assigned the
<tt>PRIV_PROC_LOCK_MEMORY</tt> privilege. This privilege allows a process to lock pages in physical memory.</p><p>If you assign the <tt>PRIV_PROC_LOCK_MEMORY</tt> privilege to a rights profile, you can give
the processes that have this privilege the ability to lock all memory. As
a safeguard, set a resource control to prevent the user of the privilege
from locking all memory. For privileged processes that run in a non-global zone,
set the <tt>zone.max-locked-memory</tt> resource control. For privileged processes that run on a system,
create a project and set the <tt>project.max-locked-memory</tt> resource control. For information about these resource
controls, see <a href="http://docs.sun.com/doc/819-2450/rmctrls-1?a=view">Chapter 6, Resource Controls (Overview), in <i>System Administration Guide: Virtualization Using the Solaris Operating System</i></a> and <a href="http://docs.sun.com/doc/819-2450/z.config.ov-1?a=view">Chapter 17, Non-Global Zone Configuration (Overview), in <i>System Administration Guide: Virtualization Using the Solaris Operating System</i></a>.</p>

<a name="prbac-17"></a><h4>How Privileges Are Implemented</h4>
<p><a name="indexterm-1093"></a>Every process has four sets of privileges that determine whether a process can
use a particular privilege. The kernel automatically calculates the <b>effective set</b> of privileges. You
can modify the initial <b>inheritable set</b> of privileges. A program that is coded to use
privileges can reduce the program's <b>permitted set</b> of privileges. You can shrink the <b>limit set</b>
of privileges.</p>
<ul><li><p><a name="indexterm-1094"></a><a name="indexterm-1095"></a><b>Effective privilege set, or E &ndash;</b> Is the set of privileges that is currently in effect. A process can add privileges that are in the permitted set to the effective set. A process can also remove privileges from E.</p></li>
<li><p><a name="indexterm-1096"></a><a name="indexterm-1097"></a><b>Permitted privilege set, or P &ndash;</b> Is the set of privileges that is available for use. Privileges can be available to a program from inheritance or through assignment. An execution profile is one way to assign privileges to a program. The <tt>setuid</tt> command assigns all privileges that <tt>root</tt> has to a program. Privileges can be removed from the permitted set, but privileges cannot be added to the set. Privileges that are removed from P are automatically removed from E.</p><p><a name="indexterm-1098"></a>A <b>privilege-aware</b> program removes the privileges that a program never uses from the program's permitted set. In this way, unnecessary privileges cannot be exploited by the program or a malicious process. For more information on privilege-aware programs, see <a href="http://docs.sun.com/doc/819-2145/ch3priv-18281?a=view">Chapter 2, Developing Privileged Applications, in <i>Solaris Security for Developers Guide</i></a>.</p></li>
<li><p><a name="indexterm-1099"></a><a name="indexterm-1100"></a><b>Inheritable privilege set, or I &ndash;</b> Is the set of privileges that a process can inherit across a call to <tt>exec</tt>. After the call to <tt>exec</tt>, the permitted and the effective sets are equal, except in the special case of a <tt>setuid</tt> program.</p><p>For a <tt>setuid</tt> program, after the call to <tt>exec</tt>, the inheritable set is first restricted by the limit set. Then, the set of privileges that were inherited (I), minus any privileges that were in the limit set (L), are assigned to P and E for that process.</p></li>
<li><p><a name="indexterm-1101"></a><a name="indexterm-1102"></a><b>Limit privilege set, or L &ndash;</b> Is the outside limit of what privileges are available to a process and its children. By default, the limit set is all privileges. Processes can shrink the limit set but can never extend the limit set. L is used to restrict I. Consequently, L restricts P and E at the time of <tt>exec</tt>.</p><p>If a user has been assigned a profile that includes a program that has been assigned privileges, the user can usually run that program. On an unmodified system, the program's assigned privileges are within the user's limit set. The privileges that have been assigned to the program become part of the user's permitted set. To run the program that has been assigned privileges, the user must run the program from a profile shell.</p></li></ul>
<p><a name="indexterm-1103"></a><a name="indexterm-1104"></a><a name="indexterm-1105"></a>The kernel recognizes a <b>basic privilege set</b>. On an unmodified system, each user's initial inheritable
set equals the basic set at login. You can modify the user's initial
inheritable set. You cannot modify the basic set.</p><p><a name="indexterm-1106"></a><a name="indexterm-1107"></a><a name="indexterm-1108"></a>On an unmodified system, a user's privilege sets at login would appear similar
to the following:</p><pre>E (Effective): basic
I (Inheritable): basic
P (Permitted): basic
L (Limit): all</pre><p>Therefore, at login, all users have the basic set in their inheritable set,
their permitted set, and their effective set. A user's limit set contains all
privileges. To put more privileges in the user's effective set, you must assign
a rights profile to the user. The rights profile would include commands to
which you have added privileges. You can also assign privileges directly to the
user or role, though such privilege assignment can be risky. For a discussion
of the risks, see <a href="rbac-1.html#rbac-10">Security Considerations When Directly Assigning Security Attributes</a>.</p>

<a name="prbac-19"></a><h4>How Processes Get Privileges</h4>
<p><a name="indexterm-1109"></a><a name="indexterm-1110"></a>Processes can inherit privileges. Or, processes can be assigned privileges. A process inherits
privileges from its parent process. At login, the user's initial inheritable set of
privileges determines what privileges are available to the user's processes. All child processes
of the user's initial login inherit that set.</p><p><a name="indexterm-1111"></a>You can also directly assign privileges to programs, users, and roles. When a
program requires privileges, you assign the privileges to the program's executable in a
rights profile. Users or roles that are permitted to run the program are
assigned the profile that includes the program. At login or when a profile
shell is entered, the program runs with privilege when the program's executable is
typed in the profile shell. For example, a role that includes the Object
Access Management profile is able to run the <tt>chmod</tt> command with the <tt>file_chown</tt>
privilege.</p><p>When a role or user runs a program that has been directly
assigned an additional privilege, the assigned privilege is added to the role or
user's inheritable set. Child processes of the program that was assigned privileges inherit the
privileges of the parent. If the child process requires more privileges than the
parent process, the child process must be directly assigned those privileges.</p><p><a name="indexterm-1112"></a><a name="indexterm-1113"></a>Programs that are coded to use privileges are called privilege-aware programs. A privilege-aware
program turns on the use of privilege and turns off the use of
privilege during program execution. To succeed in a production environment, the program must
be assigned the privileges that the program turns on and off.</p><p>For examples of privilege-aware code, see <a href="http://docs.sun.com/doc/819-2145/ch3priv-18281?a=view">Chapter 2, Developing Privileged Applications, in <i>Solaris Security for Developers Guide</i></a>. To assign privileges to a
program that requires privileges, see <a href="privtask-10.html#privtask-7">How to Add Privileges to a Command</a>.</p>

<a name="prbac-21"></a><h4>Assigning Privileges</h4>
<p><a name="indexterm-1114"></a><a name="indexterm-1115"></a><a name="indexterm-1116"></a>You, in your capacity as system administrator, are responsible for assigning privileges. Typically,
you assign the privilege to a command in a rights profile. The rights
profile is then assigned to a role or to a user. The Solaris
Management Console provides the graphical user interface (GUI) to assign privileges. Privileges can
also be assigned by using commands such as <tt>smuser</tt> and <tt>smrole</tt>. For more information
on how to use the GUI to assign privileges, see <a href="rbactask-1.html">Chapter&nbsp;9, Using Role-Based Access Control (Tasks)</a>.</p><p><a name="indexterm-1117"></a>Privileges can also be assigned directly to a user. If you trust a
subset of users to use a privilege responsibly throughout their sessions, you can
assign the privilege directly. Good candidates for direct assignment are privileges that have
a limited effect, such as <tt>proc_clock_highres</tt>. Poor candidates for direct assignment are privileges
that have far-reaching effects, such as <tt>file_dac_write</tt>.</p><p>Privileges can also be denied to a user or to a system.
Care must be taken when removing privileges from the initial inheritable set or
the limit set of a user or a system.</p>

<a name="prbac-11"></a><h5>Expanding a User or Role's Privileges</h5>
<p>Users and roles have an inheritable set of privileges, and a limit
set of privileges. The limit set cannot be expanded, since the limit set
is initially all privileges. The initial inheritable set can be expanded for users,
roles, and systems. A privilege that is not in the inheritable set can
also be assigned to a process.</p><p>The assignment of privileges per process is the most precise way to add
privileges. You can expand the number of privileged operations that a user can
perform by enabling the user to assume a role. The role would
be assigned profiles that include commands with added privileges. When the user assumes the
role, the user gets the role's profile shell. By typing in the role's
shell, the commands in the role's profiles execute with the added privileges.</p><p><a name="indexterm-1118"></a>You can also assign a profile to the user rather than to a
role that the user assumes. The profile would include commands with added privileges.
When the user opens a profile shell, such as <tt>pfksh</tt>, the user can
execute the commands in the user's profile with privilege. In a regular shell,
the commands do not execute with privilege. The privileged process can only execute
in a privileged shell.</p><p><a name="indexterm-1119"></a>To expand the initial inheritable set of privileges for users, roles, or systems
is a riskier way to assign privileges. All privileges in the inheritable set
are in the permitted and effective sets. All commands that the user or
role types in a shell can use the directly assigned privileges. Directly assigned
privileges enable a user or role to easily perform operations that can be
outside the bounds of their administrative responsiblities.</p><p>When you add to the initial inheritable set of privileges on a
system, all users who log on to the system have a larger set
of basic privileges. Such direct assignment enables all users of the system to
easily perform operations that are probably outside the bounds of ordinary users.</p>

<a name="prbac-15"></a><h5>Restricting a User or Role's Privileges</h5>
<p><a name="indexterm-1120"></a><a name="indexterm-1121"></a>By removing privileges, you can prevent users and roles from performing particular tasks.
You can remove privileges from the initial inheritable set, and from the limit
set. You should carefully test removal of privileges before you distribute an initial
inheritable set or a limit set that is smaller than the default 
set. By removing privileges from the initial inheritable set, you might prevent users
from logging in. When privileges are removed from the limit set, a legacy
<tt>setuid</tt> program might fail because the program requires a privilege that was removed.</p>

<a name="prbac-12"></a><h5>Assigning Privileges to a Script</h5>
<p><a name="indexterm-1122"></a><a name="indexterm-1123"></a>Scripts are executables, like commands. Therefore, in a rights profile, you can add
privileges to a script just as you can add privileges to a command.
The script runs with the added privileges when a user or role who
has been assigned the profile executes the script in a profile shell. If
the script contains commands that require privileges, the commands with added privileges should
also be in the profile.</p><p>Privilege-aware programs can restrict privileges per process. Your job with a privilege-aware program
is to assign the executable just the privileges that the program needs. You
then test the program to see that the program succeeds in performing its
tasks. You also check that the program does not abuse its use of
privileges.</p>

<a name="prbac-23"></a><h4>Privileges and Devices</h4>
<a name="indexterm-1124"></a><a name="indexterm-1125"></a><a name="indexterm-1126"></a><p>The privilege model uses privileges to protect system interfaces that are protected by
file permissions alone in the superuser model. In a system with privileges, file
permissions are too weak to protect the interfaces. A privilege such as <tt>proc_owner</tt>
could override file permissions and then give full access to all of the
system.</p><p>Therefore, ownership of the device directory is not sufficient to open a device.
For example, members of the group <tt>sys</tt> are no longer automatically allowed to
open the <tt>/dev/ip</tt> device. The file permissions on <tt>/dev/ip</tt> are <tt>0666</tt>, but the <tt>net_rawaccess</tt>
privilege is required to open the device.</p><p>Device policy is controlled by privileges. The <tt>getdevpolicy</tt> command displays the device policy
for every device. The device configuration command, <tt>devfsadm</tt>, installs the device policy.
The <tt>devfsadm</tt> command binds privilege sets with <tt>open</tt> for reading or writing of devices.
For more information, see the <a href="http://docs.sun.com/doc/819-2240/getdevpolicy-1m?a=view"><tt>getdevpolicy</tt>(1M)</a> and <a href="http://docs.sun.com/doc/819-2240/devfsadm-1m?a=view"><tt>devfsadm</tt>(1M)</a> man pages.</p><p>Device policy allows you more flexibility in granting permission to open devices. You
can require different privileges or more privileges than the default device policy. The
privilege requirements can be modified for the device policy and for the driver
proper. You can modify the privileges when installing, adding, or updating a device
driver.</p><p>The <tt>add_drv</tt> and <tt>update_drv</tt> commands can modify device policy entries and driver-specific privileges.
You must be running a process with the full set of privileges to
change the device policy. For more information, see the <a href="http://docs.sun.com/doc/819-2240/add-drv-1m?a=view"><tt>add_drv</tt>(1M)</a> and <a href="http://docs.sun.com/doc/819-2240/update-drv-1m?a=view"><tt>update_drv</tt>(1M)</a> man
pages.</p>

<a name="privtask-12"></a><h4>Privileges and Debugging</h4>
<a name="indexterm-1127"></a><p>The Solaris OS provides tools to debug privilege failure. The <tt>ppriv</tt> command and
the <tt>truss</tt> command provide debugging output. For examples, see the <a href="http://docs.sun.com/doc/819-2239/ppriv-1?a=view"><tt>ppriv</tt>(1)</a> man page. For
a procedure, see <a href="privtask-10.html#privtask-6">How to Determine Which Privileges a Program Requires</a>.</p>
         </div>
      </td>
   </tr>

   <tr class="PageControls" valign="top">
      <td></td>
      <td>
         <table width="100%">
      	   <tr>
      	     <td>
                 <a href="rbac-1.html">Previous</a>
             </td>
             <td align="right">
                 <a href="rbactask-1.html">Next</a>
             </td>
           </tr>
         </table>
      </td>
   </tr>
</tbody>
</table>


</body>
</html>

