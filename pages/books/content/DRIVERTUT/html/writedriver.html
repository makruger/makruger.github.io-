<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="en-US">
<head>
<meta http-equiv="Content-type" content="text/html; charset=iso-8859-1">
<title>Writing the Template Driver - Device Driver Tutorial</title>
<meta name="robots" content="index,follow">
<meta name="robots" content="index,follow">
<meta name="date" content="2008-12-01">
<meta name="collection" content="reference">
<link rel="stylesheet" type="text/css" href="css/elements.css">
<link rel="stylesheet" type="text/css" href="css/indiana.css">
</head>

<body>


<div class="Masthead">
   <div class="MastheadLogo">
      <a href="http://www.opensolaris.org"><img border="0" src="graphics/header.png"></img></a>
   </div>
   <div class="Title">Device Driver Tutorial</div>
</div>

<table class="Layout" border="0" cellspacing="0" width="100%">
<tbody>

   <tr valign="top" class="PageControls">
      <td></td>
      <td>
         <table width="100%">
      	   <tr>
      	     <td>
                 <a href="ffzpv.html">Previous</a>
             </td>
             <td align="right">
                 <a href="eoxzw.html">Next</a>
             </td>
           </tr>
         </table>
      </td>
   </tr>
   
   <tr valign="top">
      <td class="Navigation" width="200px"><p class="toc level1"><a href="docinfo.html">Document Information</a></p>
<p class="toc level1 tocsp"><a href="drivertutp.html">Preface</a></p>
<p class="toc level1 tocsp"><a href="drivertut1.html">1.&nbsp;&nbsp;Introduction to Device Drivers</a></p>
<p class="toc level1 tocsp"><a href="eoqrt.html">2.&nbsp;&nbsp;Template Driver Example</a></p>
<p class="toc level2"><a href="ffzpv.html">Overview of the Template Driver Example</a></p>
<div class="onpage">
<p class="toc level2"><a href="">Writing the Template Driver</a></p>
</div>
<p class="toc level2"><a href="eoxzw.html">Writing the Device Configuration File</a></p>
<p class="toc level2"><a href="eoxzr.html">Building and Installing the Template Driver</a></p>
<p class="toc level2"><a href="eoxzu.html">Testing the Template Driver</a></p>
<p class="toc level2"><a href="eqbof.html">Complete Template Driver Source</a></p>
<p class="toc level1 tocsp"><a href="faatl.html">3.&nbsp;&nbsp;Reading and Writing Data in Kernel Memory</a></p>
<p class="toc level1 tocsp"><a href="eoqrv.html">4.&nbsp;&nbsp;Tips for Developing Device Drivers</a></p>
<p class="toc level1 tocsp"><a href="idx-1.html">Index</a></p>
</td>
      <td class="ContentPane" width="705px">

	 <div class="MainContent">      	 
             

<a name="writedriver"></a><h3>Writing the Template Driver</h3>
<a name="indexterm-166"></a><p>This section describes the entry points and data structures that are included in
this driver and shows you how to define them. All of these
data structures and almost all of these entry points are required for any
character device driver.</p><p>This section describes the following entry points and data structures:</p>
<ul><li><p>Loadable module configuration entry points</p></li>
<li><p>Autoconfiguration entry points</p></li>
<li><p>User context entry points</p></li>
<li><p>Character and block operations structure</p></li>
<li><p>Device operations structure</p></li>
<li><p>Module linkage structures</p></li></ul>
<p>First, create a directory where you can develop your driver. This driver is
named  <tt>dummy</tt> because this driver does not do any real work. Next,
open a new text file named <tt>dummy.c</tt>.</p>

<a name="eoxzy"></a><h4>Writing the Loadable Module Configuration Entry Points</h4>
<a name="indexterm-167"></a><a name="indexterm-168"></a><a name="indexterm-169"></a><a name="indexterm-170"></a><a name="indexterm-171"></a><a name="indexterm-172"></a><a name="indexterm-173"></a><a name="indexterm-174"></a><a name="indexterm-175"></a><a name="indexterm-176"></a><a name="indexterm-177"></a><a name="indexterm-178"></a><a name="indexterm-179"></a><p>Every kernel module of any type must define at least the following
three loadable module configuration entry points:</p>
<ul><li><p>The <a href="http://docs.sun.com/doc/819-2255/u-init-9e?a=view"><tt>_init</tt>(9E)</a> routine initializes a loadable module. The <tt>_init</tt>(9E) routine must at least call the <a href="http://docs.sun.com/doc/819-2256/mod-install-9f?a=view"><tt>mod_install</tt>(9F)</a> function and return the success or failure value that is returned by <tt>mod_install</tt>(9F).</p></li>
<li><p>The <a href="http://docs.sun.com/doc/819-2255/u-info-9e?a=view"><tt>_info</tt>(9E)</a> routine returns information about a loadable module. The <tt>_info</tt>(9E) routine must at least call the <a href="http://docs.sun.com/doc/819-2256/mod-info-9f?a=view"><tt>mod_info</tt>(9F)</a> function and return the value that is returned by <tt>mod_info</tt>(9F).</p></li>
<li><p>The <a href="http://docs.sun.com/doc/819-2255/u-fini-9e?a=view"><tt>_fini</tt>(9E)</a> routine prepares a loadable module for unloading. The <tt>_fini</tt>(9E) routine must at least call the <a href="http://docs.sun.com/doc/819-2256/mod-remove-9f?a=view"><tt>mod_remove</tt>(9F)</a> function and return the success or failure value that is returned by <tt>mod_remove</tt>(9F). When <tt>mod_remove</tt>(9F) is successful, the <tt>_fini</tt>(9E) routine must undo everything that the <tt>_init</tt>(9E) routine did.</p></li></ul>
<p>The <tt>mod_install</tt>(9F), <tt>mod_info</tt>(9F), and <tt>mod_remove</tt>(9F) functions are used in exactly the same way
in every driver, regardless of the functionality of the driver. You do not
need to investigate what the values of the arguments of these functions should
be. You can copy these function calls from this example and paste them
into every driver you write.</p><p>In this section, the following code is added to the <tt>dummy.c</tt> source file:</p><pre>/* Loadable module configuration entry points */
int
_init(void)
{
    cmn_err(CE_NOTE, "Inside _init");
    return(mod_install(&amp;ml));
}

int
_info(struct modinfo *modinfop)
{
    cmn_err(CE_NOTE, "Inside _info");
    return(mod_info(&amp;ml, modinfop));
}

int
_fini(void)
{
    cmn_err(CE_NOTE, "Inside _fini");
    return(mod_remove(&amp;ml));
}</pre>

<a name="epmnj"></a><h5>Declaring the Loadable Module Configuration Entry Points</h5>
<p>The <tt>_init</tt>(9E), <tt>_info</tt>(9E), and <tt>_fini</tt>(9E) routine names are not unique to any particular
kernel module. You customize the behavior of these routines when you define them
in your module, but the names of these routines are not unique. These
three routines are declared in the <tt>modctl.h</tt> header file. You need to include
the <tt>modctl.h</tt> header file in your <tt>dummy.c</tt> file. Do not declare these three
routines in <tt>dummy.c</tt>.</p>

<a name="epmnk"></a><h5>Defining the Module Initialization Entry Point</h5>
<a name="indexterm-180"></a><a name="indexterm-181"></a><a name="indexterm-182"></a><a name="indexterm-183"></a><a name="indexterm-184"></a><a name="indexterm-185"></a><a name="indexterm-186"></a><a name="indexterm-187"></a><p>The <a href="http://docs.sun.com/doc/819-2255/u-init-9e?a=view"><tt>_init</tt>(9E)</a> routine returns type <tt>int</tt> and takes no arguments. The <tt>_init</tt>(9E) routine must
call the <a href="http://docs.sun.com/doc/819-2256/mod-install-9f?a=view"><tt>mod_install</tt>(9F)</a> function and return the success or failure value that is
returned by <tt>mod_install</tt>(9F).</p><p>The <tt>mod_install</tt>(9F) function takes an argument that is a <tt>modlinkage</tt>(9S) structure. See
<a href="#epffy">Defining the Module Linkage Structures</a> for information about the <tt>modlinkage</tt>(9S) structure.</p><p>This driver is supposed to write a message each time an entry
point is entered. Use the <a href="http://docs.sun.com/doc/819-2256/cmn-err-9f?a=view"><tt>cmn_err</tt>(9F)</a> function to write a message to a system
log. The <tt>cmn_err</tt>(9F) function usually is used to report an error condition. The
<tt>cmn_err</tt>(9F) function also is useful for debugging in the same way that you
might use print statements in a user program. Be sure to remove <tt>cmn_err()</tt>
calls that are used for development or debugging before you compile your production
version driver. You might want to use <tt>cmn_err()</tt> calls in a production driver
to write error messages that would be useful to a system administrator.</p><p>The <tt>cmn_err</tt>(9F) function requires you to include the <tt>cmn_err.h</tt> header file, the <tt>ddi.h</tt>
header file, and the <tt>sunddi.h</tt> header file. The <tt>cmn_err</tt>(9F) function takes two arguments.
The first argument is a constant that indicates the severity of the error
message. The message written by this driver is not an error message but
is simply a test message. Use <tt>CE_NOTE</tt> for the value of this
severity constant. The second argument the <tt>cmn_err</tt>(9F) function takes is a string message.</p><p>The following code is the <tt>_init</tt>(9E) routine that you should enter into your
<tt>dummy.c</tt> file. The <tt>ml</tt> structure is the <tt>modlinkage</tt>(9S) structure that is discussed in
<a href="#epffy">Defining the Module Linkage Structures</a>.</p><pre>int
_init(void)
{
    cmn_err(CE_NOTE, "Inside _init");
    return(mod_install(&amp;ml));
}</pre>

<a name="epmnm"></a><h5>Defining the Module Information Entry Point</h5>
<a name="indexterm-188"></a><a name="indexterm-189"></a><a name="indexterm-190"></a><a name="indexterm-191"></a><a name="indexterm-192"></a><a name="indexterm-193"></a><p>The <a href="http://docs.sun.com/doc/819-2255/u-info-9e?a=view"><tt>_info</tt>(9E)</a> routine returns type <tt>int</tt> and takes an argument that is a
pointer to an opaque <tt>modinfo</tt> structure. The <tt>_info</tt>(9E) routine must return the value that
is returned by the <a href="http://docs.sun.com/doc/819-2256/mod-info-9f?a=view"><tt>mod_info</tt>(9F)</a> function.</p><p>The <tt>mod_info</tt>(9F) function takes two arguments. The first argument to <tt>mod_info</tt>(9F) is a
<tt>modlinkage</tt>(9S) structure. See <a href="#epffy">Defining the Module Linkage Structures</a> for information about the <tt>modlinkage</tt>(9S) structure. The second
argument to <tt>mod_info</tt>(9F) is the same <tt>modinfo</tt> structure pointer that is the
argument to the <tt>_info</tt>(9E) routine. The <tt>mod_info</tt>(9F) function returns the module information or
returns zero if an error occurs.</p><p>Use the <a href="http://docs.sun.com/doc/819-2256/cmn-err-9f?a=view"><tt>cmn_err</tt>(9F)</a> function to write a message to the system log in
the same way that you used the <tt>cmn_err</tt>(9F) function in your <tt>_init</tt>(9E) entry
point.</p><p>The following code is the <tt>_info</tt>(9E) routine that you should enter into your
<tt>dummy.c</tt> file. The <tt>ml</tt> structure is discussed in <a href="#epffy">Defining the Module Linkage Structures</a>. The <tt>modinfop</tt> argument is a
pointer to an opaque structure that the system uses to pass module information.</p><pre>int
_info(struct modinfo *modinfop)
{
    cmn_err(CE_NOTE, "Inside _info");
    return(mod_info(&amp;ml, modinfop));
}</pre>

<a name="epmnn"></a><h5>Defining the Module Unload Entry Point</h5>
<a name="indexterm-194"></a><a name="indexterm-195"></a><a name="indexterm-196"></a><a name="indexterm-197"></a><p>The <a href="http://docs.sun.com/doc/819-2255/u-fini-9e?a=view"><tt>_fini</tt>(9E)</a> routine returns type <tt>int</tt> and takes no arguments. The <tt>_fini</tt>(9E) routine must
 call the <a href="http://docs.sun.com/doc/819-2256/mod-remove-9f?a=view"><tt>mod_remove</tt>(9F)</a> function and return the success or failure value
that is returned by <tt>mod_remove</tt>(9F).</p><p>When <tt>mod_remove</tt>(9F) is successful, the <tt>_fini</tt>(9E) routine must undo everything that the <tt>_init</tt>(9E)
routine did. The <tt>_fini</tt>(9E) routine must call <tt>mod_remove</tt>(9F) because the <tt>_init</tt>(9E) routine
called <tt>mod_install</tt>(9F). The <tt>_fini</tt>(9E) routine must deallocate anything that was allocated, close anything
that was opened, and destroy anything that was created in the <tt>_init</tt>(9E) routine.</p><p>The <tt>_fini</tt>(9E) routine can be called at any time when a module
is loaded. In normal operation, the <tt>_fini</tt>(9E) routine often fails. This behavior is normal
because the kernel allows the module to determine whether the module can be
unloaded. If <tt>mod_remove</tt>(9F) is successful, the module determines that devices were detached, and
the module can be unloaded. If <tt>mod_remove</tt>(9F) fails, the module determines that
devices were not detached, and the module cannot be unloaded.</p><p>The following actions take place when <tt>mod_remove</tt>(9F) is called:</p>
<ul><li><p>The kernel checks whether this driver is busy. This driver is busy if one of the following conditions is true:</p>
<ul><li><p>A device node that is managed by this driver is open.</p></li>
<li><p><a name="indexterm-198"></a><a name="indexterm-199"></a><a name="indexterm-200"></a>Another module that depends on this driver is open. A module depends on this driver if the module was linked using the <tt>-N</tt> option with this driver named as the argument to that <tt>-N</tt> option. See the <a href="http://docs.sun.com/doc/819-2239/ld-1?a=view"><tt>ld</tt>(1)</a> man page for more information.</p></li></ul>
</li>
<li><p>If the driver is busy, then <tt>mod_remove</tt>(9F) fails and <tt>_fini</tt>(9E) fails.</p></li>
<li><p><a name="indexterm-201"></a><a name="indexterm-202"></a>If the driver is not busy, then the kernel calls the <a href="http://docs.sun.com/doc/819-2255/detach-9e?a=view"><tt>detach</tt>(9E)</a> entry point of the driver.</p>
<ul><li><p>If <tt>detach</tt>(9E) fails, then <tt>mod_remove</tt>(9F) fails and <tt>_fini</tt>(9E) fails.</p></li>
<li><p>If <tt>detach</tt>(9E) succeeds, then <tt>mod_remove</tt>(9F) succeeds, and <tt>_fini</tt>(9E) continues its cleanup work.</p></li></ul>
</li></ul>
<p>The <tt>mod_remove</tt>(9F) function takes an argument that is a <tt>modlinkage</tt>(9S) structure. See
<a href="#epffy">Defining the Module Linkage Structures</a> for information about the <tt>modlinkage</tt>(9S) structure.</p><p>Use the <a href="http://docs.sun.com/doc/819-2256/cmn-err-9f?a=view"><tt>cmn_err</tt>(9F)</a> function to write a message to the system log in
the same way that you used the <tt>cmn_err</tt>(9F) function in your <tt>_init</tt>(9E) entry
point.</p><p>The following code is the <tt>_fini</tt>(9E) routine that you should enter into your
<tt>dummy.c</tt> file. The <tt>ml</tt> structure is discussed in <a href="#epffy">Defining the Module Linkage Structures</a>.</p><pre>int
_fini(void)
{
    cmn_err(CE_NOTE, "Inside _fini");
    return(mod_remove(&amp;ml));
}</pre>

<a name="epmnl"></a><h5>Including Loadable Module Configuration Header Files</h5>
<p>The <a href="http://docs.sun.com/doc/819-2255/u-init-9e?a=view"><tt>_init</tt>(9E)</a>, <tt>_info</tt>(9E), <tt>_fini</tt>(9E), and <a href="http://docs.sun.com/doc/819-2256/mod-install-9f?a=view"><tt>mod_install</tt>(9F)</a> functions require you to include the <tt>modctl.h</tt>
header file. The <a href="http://docs.sun.com/doc/819-2256/cmn-err-9f?a=view"><tt>cmn_err</tt>(9F)</a> function requires you to include the <tt>cmn_err.h</tt> header file, the
<tt>ddi.h</tt> header file, and the <tt>sunddi.h</tt> header file.</p><p>The following header files are required by the three loadable module configuration routines
that you have written in this section. Include this code near the top
of your <tt>dummy.c</tt> file.</p><pre>#include &lt;sys/modctl.h&gt;  /* used by _init, _info, _fini */
#include &lt;sys/cmn_err.h&gt; /* used by all entry points for this driver */
#include &lt;sys/ddi.h&gt;     /* used by all entry points for this driver */
#include &lt;sys/sunddi.h&gt;  /* used by all entry points for this driver */</pre>

<a name="epmnh"></a><h4>Writing the Autoconfiguration Entry Points</h4>
<a name="indexterm-203"></a><a name="indexterm-204"></a><a name="indexterm-205"></a><a name="indexterm-206"></a><a name="indexterm-207"></a><a name="indexterm-208"></a><a name="indexterm-209"></a><a name="indexterm-210"></a><a name="indexterm-211"></a><a name="indexterm-212"></a><a name="indexterm-213"></a><a name="indexterm-214"></a><a name="indexterm-215"></a><a name="indexterm-216"></a><a name="indexterm-217"></a><p>Every character driver must define at least the following autoconfiguration entry points. The
kernel calls these routines when the device driver is loaded.</p>
<ul><li><p>The <a href="http://docs.sun.com/doc/819-2255/attach-9e?a=view"><tt>attach</tt>(9E)</a> routine must call <a href="http://docs.sun.com/doc/819-2256/ddi-create-minor-node-9f?a=view"><tt>ddi_create_minor_node</tt>(9F)</a>. The <tt>ddi_create_minor_node</tt>(9F) function provides the information the system needs to create the device files.</p></li>
<li><p>The <a href="http://docs.sun.com/doc/819-2255/detach-9e?a=view"><tt>detach</tt>(9E)</a> routine must call <a href="http://docs.sun.com/doc/819-2256/ddi-remove-minor-node-9f?a=view"><tt>ddi_remove_minor_node</tt>(9F)</a> to deallocate everything that was allocated by <tt>ddi_create_minor_node</tt>(9F). The <tt>detach</tt>(9E) routine must undo everything that the <tt>attach</tt>(9E) routine did.</p></li>
<li><p>The <a href="http://docs.sun.com/doc/819-2255/getinfo-9e?a=view"><tt>getinfo</tt>(9E)</a> routine returns requested device driver information through one of its arguments.</p></li>
<li><p>The <a href="http://docs.sun.com/doc/819-2255/prop-op-9e?a=view"><tt>prop_op</tt>(9E)</a> routine returns requested device driver property information through a pointer. You can call the <a href="http://docs.sun.com/doc/819-2256/ddi-prop-op-9f?a=view"><tt>ddi_prop_op</tt>(9F)</a> function instead of writing your own <tt>prop_op</tt>(9E) entry point. Use the <tt>prop_op</tt>(9E) entry point to customize the behavior of the <tt>ddi_prop_op</tt>(9F) function.</p></li></ul>
<p>In this section, the following code is added:</p><pre>/* Device autoconfiguration entry points */
static int
dummy_attach(dev_info_t *dip, ddi_attach_cmd_t cmd)
{
    cmn_err(CE_NOTE, "Inside dummy_attach");
    switch(cmd) {
    case DDI_ATTACH:
        dummy_dip = dip;
        if (ddi_create_minor_node(dip, "0", S_IFCHR,
            ddi_get_instance(dip), DDI_PSEUDO,0)
            != DDI_SUCCESS) {
            cmn_err(CE_NOTE,
                "%s%d: attach: could not add character node.",
                "dummy", 0);
            return(DDI_FAILURE);
        } else
            return DDI_SUCCESS;
    default:
        return DDI_FAILURE;
    }
}

static int
dummy_detach(dev_info_t *dip, ddi_detach_cmd_t cmd)
{
    cmn_err(CE_NOTE, "Inside dummy_detach");
    switch(cmd) {
    case DDI_DETACH:
        dummy_dip = 0;
        ddi_remove_minor_node(dip, NULL);
        return DDI_SUCCESS;
    default:
        return DDI_FAILURE;
    }
}

static int
dummy_getinfo(dev_info_t *dip, ddi_info_cmd_t cmd, void *arg, 
    void **resultp)
{
    cmn_err(CE_NOTE, "Inside dummy_getinfo");
    switch(cmd) {
    case DDI_INFO_DEVT2DEVINFO:
        *resultp = dummy_dip;
        return DDI_SUCCESS;
    case DDI_INFO_DEVT2INSTANCE:
        *resultp = 0;
        return DDI_SUCCESS;
    default:
        return DDI_FAILURE;
    }
}

static int
dummy_prop_op(dev_t dev, dev_info_t *dip, ddi_prop_op_t prop_op,
    int flags, char *name, caddr_t valuep, int *lengthp)
{
    cmn_err(CE_NOTE, "Inside dummy_prop_op");
    return(ddi_prop_op(dev,dip,prop_op,flags,name,valuep,lengthp));
}</pre>

<a name="epmqa"></a><h5>Declaring the Autoconfiguration Entry Points</h5>
<p>The <tt>attach</tt>(9E), <tt>detach</tt>(9E), <tt>getinfo</tt>(9E), and <tt>prop_op</tt>(9E) entry point routines need to be uniquely
named for this driver. Choose a prefix to use with each entry point
routine.</p>
<hr><p><b>Note - </b><a name="indexterm-218"></a><a name="indexterm-219"></a>By convention, the prefix used for function and data names that are unique
to this driver is either the name of this driver or an abbreviation
of the name of this driver. Use the same prefix throughout the driver.
This practice makes debugging much easier.</p>
<hr>
<p>In the example shown in this chapter, <tt>dummy_</tt> is used for the prefix
to each function and data name that is unique to this example.</p><p>The following declarations are the autoconfiguration entry point declarations you should have in
your <tt>dummy.c</tt> file. Note that each of these functions is declared <tt>static</tt>.</p><pre>static int dummy_attach(dev_info_t *dip, ddi_attach_cmd_t cmd);
static int dummy_detach(dev_info_t *dip, ddi_detach_cmd_t cmd);
static int dummy_getinfo(dev_info_t *dip, ddi_info_cmd_t cmd, void *arg,
    void **resultp);
static int dummy_prop_op(dev_t dev, dev_info_t *dip, ddi_prop_op_t prop_op,
    int flags, char *name, caddr_t valuep, int *lengthp);</pre>

<a name="epmqc"></a><h5>Defining the Device Attach Entry Point</h5>
<a name="indexterm-220"></a><a name="indexterm-221"></a><a name="indexterm-222"></a><a name="indexterm-223"></a><p>The <a href="http://docs.sun.com/doc/819-2255/attach-9e?a=view"><tt>attach</tt>(9E)</a> routine returns type <tt>int</tt>. The <tt>attach</tt>(9E) routine must return either <tt>DDI_SUCCESS</tt>
or <tt>DDI_FAILURE</tt>. These two constants are defined in <tt>sunddi.h</tt>. All of the autoconfiguration
entry point routines except for <tt>prop_op</tt>(9E) return either <tt>DDI_SUCCESS</tt> or <tt>DDI_FAILURE</tt>.</p><p>The <tt>attach</tt>(9E) routine takes two arguments. The first argument is a pointer to
the <tt>dev_info</tt> structure for this driver. All of the autoconfiguration entry point routines
take a <tt>dev_info</tt> argument. The second argument is a constant that specifies the
attach type. The value that is passed through this second argument is either
<tt>DDI_ATTACH</tt> or <tt>DDI_RESUME</tt>. Every <tt>attach</tt>(9E) routine must define behavior for at least <tt>DDI_ATTACH</tt>.</p><p>The <tt>DDI_ATTACH</tt> code must initialize a device instance. In a realistic driver, you
define and manage multiple instances of the driver by using a state structure
and the <a href="http://docs.sun.com/doc/819-2256/ddi-soft-state-9f?a=view"><tt>ddi_soft_state</tt>(9F)</a> functions. Each instance of the driver has its own copy
of the state structure that holds data specific to that instance. One of
the pieces of data that is specific to each instance is the device
instance pointer. Each instance of the device driver is represented by a separate
device file in <tt>/devices</tt>. Each device instance file is pointed to by a
separate device instance pointer. See <a href="dataondemand.html#fcowf">Managing Device State</a> for information about state structures and <tt>ddi_soft_state</tt>(9F)
functions. See <a href="fgomr.html">Devices as Files</a> for information about device files and instances.</p><p>This <tt>dummy</tt> driver allows only one instance. Because this driver allows only one
instance, this driver does not use a state structure. This driver still must
declare a device instance pointer and initialize the pointer value in the <tt>attach</tt>(9E)
routine. Enter the following code near the beginning of <tt>dummy.c</tt> to declare a
device instance pointer for this driver:</p><pre>dev_info_t *dummy_dip;  /* keep track of one instance */</pre><p>The following code is the <tt>dummy_attach()</tt> routine that you should enter into your
<tt>dummy.c</tt> file. You can copy the name portion of this function definition directly
from the declaration you entered in <a href="#epmqa">Declaring the Autoconfiguration Entry Points</a>.</p><pre>static int
dummy_attach(dev_info_t *dip, ddi_attach_cmd_t cmd)
{
    cmn_err(CE_NOTE, "Inside dummy_attach");
    switch(cmd) {
    case DDI_ATTACH:
        dummy_dip = dip;
        if (ddi_create_minor_node(dip, "0", S_IFCHR,
            ddi_get_instance(dip), DDI_PSEUDO,0)
            != DDI_SUCCESS) {
            cmn_err(CE_NOTE,
                "%s%d: attach: could not add character node.",
                "dummy", 0);
            return(DDI_FAILURE);
        } else
            return DDI_SUCCESS;
    default:
        return DDI_FAILURE;
    }
}</pre><p><a name="indexterm-224"></a><a name="indexterm-225"></a><a name="indexterm-226"></a><a name="indexterm-227"></a><a name="indexterm-228"></a><a name="indexterm-229"></a><a name="indexterm-230"></a><a name="indexterm-231"></a><a name="indexterm-232"></a><a name="indexterm-233"></a><a name="indexterm-234"></a>First, use <tt>cmn_err</tt>(9F) to write a message to the system log, as you
did in your <tt>_init</tt>(9E) entry point. Then provide <tt>DDI_ATTACH</tt> behavior. Within the <tt>DDI_ATTACH</tt>
code, first assign the device instance pointer from the <tt>dummy_attach()</tt> argument to
the <tt>dummy_dip</tt> variable that you declared above. You need to save this pointer
value in the global variable so that you can use this pointer to
get information about this instance from <tt>dummy_getinfo()</tt> and detach this instance in
<tt>dummy_detach()</tt>. In this <tt>dummy_attach()</tt> routine, the device instance pointer is used by the <a href="http://docs.sun.com/doc/819-2256/ddi-get-instance-9f?a=view"><tt>ddi_get_instance</tt>(9F)</a>
function to return the instance number. The device instance pointer and the instance
number both are used by <a href="http://docs.sun.com/doc/819-2256/ddi-create-minor-node-9f?a=view"><tt>ddi_create_minor_node</tt>(9F)</a> to create a new device node.</p><p>A realistic driver probably would use the <tt>ddi_soft_state</tt>(9F) functions to create and manage
a device node. This <tt>dummy</tt> driver uses the <tt>ddi_create_minor_node</tt>(9F) function to create
a device node. The <tt>ddi_create_minor_node</tt>(9F) function takes six arguments. The first argument
to the <tt>ddi_create_minor_node</tt>(9F) function is the device instance pointer that points to
the <tt>dev_info</tt> structure of this device. The second argument is the name of
this minor node. The third argument is <tt>S_IFCHR</tt> if this device is a
character minor device or is <tt>S_IFBLK</tt> if this device is a block minor
device. This <tt>dummy</tt> driver is a character driver.</p><p>The fourth argument to the <tt>ddi_create_minor_node</tt>(9F) function is the minor number of this
minor device. This number is also called the instance number. The <tt>ddi_get_instance</tt>(9F) function
returns this instance number. The fifth argument to the <tt>ddi_create_minor_node</tt>(9F) function is the
node type. The <tt>ddi_create_minor_node</tt>(9F) man page lists the possible node types. The
<tt>DDI_PSEUDO</tt> node type is for pseudo devices. The sixth argument to the <tt>ddi_create_minor_node</tt>(9F)
function specifies whether this is a clone device. This is not a clone
device, so set this argument value to 0.</p><p>If the <tt>ddi_create_minor_node</tt>(9F) call is not successful, write a message to the system
log and return <tt>DDI_FAILURE</tt>. If the <tt>ddi_create_minor_node</tt>(9F) call is successful, return <tt>DDI_SUCCESS</tt>. If
this <tt>dummy_attach()</tt> routine receives any <tt>cmd</tt> other than <tt>DDI_ATTACH</tt>, return <tt>DDI_FAILURE</tt>.</p>

<a name="epmqi"></a><h5>Defining the Device Detach Entry Point</h5>
<a name="indexterm-235"></a><a name="indexterm-236"></a><a name="indexterm-237"></a><a name="indexterm-238"></a><a name="indexterm-239"></a><a name="indexterm-240"></a><a name="indexterm-241"></a><a name="indexterm-242"></a><a name="indexterm-243"></a><p>The <a href="http://docs.sun.com/doc/819-2255/detach-9e?a=view"><tt>detach</tt>(9E)</a> routine takes two arguments. The first argument is a pointer to
the <tt>dev_info</tt> structure for this driver. The second argument is a constant that
specifies the detach type. The value that is passed through this second argument
is either <tt>DDI_DETACH</tt> or <tt>DDI_SUSPEND</tt>. Every <tt>detach</tt>(9E) routine must define behavior for at
least <tt>DDI_DETACH</tt>.</p><p>The <tt>DDI_DETACH</tt> code must undo everything that the <tt>DDI_ATTACH</tt> code did. In
the <tt>DDI_ATTACH</tt> code in your <tt>attach</tt>(9E) routine, you saved the address of a
new <tt>dev_info</tt> structure and you called the <tt>ddi_create_minor_node</tt>(9F) function to create a new
node. In the <tt>DDI_DETACH</tt> code in this <tt>detach</tt>(9E) routine, you need to reset the
variable that pointed to the <tt>dev_info</tt> structure for this node. You also need
to call the <a href="http://docs.sun.com/doc/819-2256/ddi-remove-minor-node-9f?a=view"><tt>ddi_remove_minor_node</tt>(9F)</a> function to remove this node. The <tt>detach</tt>(9E) routine must
deallocate anything that was allocated, close anything that was opened, and destroy anything
that was created in the <tt>attach</tt>(9E) routine.</p><p>The following code is the <tt>dummy_detach()</tt> routine that you should enter into your
<tt>dummy.c</tt> file. You can copy the name portion of this function definition directly
from the declaration you entered in <a href="#epmqa">Declaring the Autoconfiguration Entry Points</a>.</p><pre>static int
dummy_detach(dev_info_t *dip, ddi_detach_cmd_t cmd)
{
    cmn_err(CE_NOTE, "Inside dummy_detach");
    switch(cmd) {
    case DDI_DETACH:
        dummy_dip = 0;
        ddi_remove_minor_node(dip, NULL);
        return DDI_SUCCESS;
    default:
        return DDI_FAILURE;
    }
}</pre><p>First, use <tt>cmn_err</tt>(9F) to write a message to the system log, as
you did in your <tt>_init</tt>(9E) entry point. Then provide <tt>DDI_DETACH</tt> behavior. Within the <tt>DDI_DETACH</tt>
code, first reset the <tt>dummy_dip</tt> variable that you set in <tt>dummy_attach()</tt> above. You
cannot reset this device instance pointer unless you remove all instances of the
device. This <tt>dummy</tt> driver supports only one instance.</p><p>Next, call the <tt>ddi_remove_minor_node</tt>(9F) function to remove this device node. The <tt>ddi_remove_minor_node</tt>(9F) function
takes two arguments. The first argument is the device instance pointer that points
to the <tt>dev_info</tt> structure of this device. The second argument is the
name of the minor node you want to remove. If the value of
the minor node argument is <tt>NULL</tt>, then <tt>ddi_remove_minor_node</tt>(9F) removes all instances of
this device. Because the <tt>DDI_DETACH</tt> code of this driver always removes all instances, this
<tt>dummy</tt> driver supports only one instance.</p><p>If the value of the <tt>cmd</tt> argument to this <tt>dummy_detach()</tt> routine is
<tt>DDI_DETACH</tt>, remove all instances of this device and return <tt>DDI_SUCCESS</tt>. If this <tt>dummy_detach()</tt>
routine receives any <tt>cmd</tt> other than <tt>DDI_DETACH</tt>, return <tt>DDI_FAILURE</tt>.</p>

<a name="epmql"></a><h5>Defining the Get Driver Information Entry Point</h5>
<a name="indexterm-244"></a><a name="indexterm-245"></a><a name="indexterm-246"></a><a name="indexterm-247"></a><a name="indexterm-248"></a><a name="indexterm-249"></a><a name="indexterm-250"></a><p>The <a href="http://docs.sun.com/doc/819-2255/getinfo-9e?a=view"><tt>getinfo</tt>(9E)</a> routine takes a pointer to a device number and returns a
pointer to a device information structure or returns a device instance number. The
return value of the <tt>getinfo</tt>(9E) routine is <tt>DDI_SUCCESS</tt> or <tt>DDI_FAILURE</tt>. The pointer or instance
number requested from the <tt>getinfo</tt>(9E) routine is returned through a pointer argument.</p><p>The <tt>getinfo</tt>(9E) routine takes four arguments. The first argument is a pointer to
the <tt>dev_info</tt> structure for this driver. This <tt>dev_info</tt> structure argument is obsolete
and is no longer used by the <tt>getinfo</tt>(9E) routine.</p><p>The second argument to the <tt>getinfo</tt>(9E) routine is a constant that specifies what
information the <tt>getinfo</tt>(9E) routine must return. The value of this second argument is
either <tt>DDI_INFO_DEVT2DEVINFO</tt> or <tt>DDI_INFO_DEVT2INSTANCE</tt>. The third argument to the <tt>getinfo</tt>(9E) routine is a
pointer to a device number. The fourth argument is a pointer to
the place where the <tt>getinfo</tt>(9E) routine must store the requested information. The information stored
at this location depends on the value you passed in the second
argument to the <tt>getinfo</tt>(9E) routine.</p><p>The following table describes the relationship between the second and fourth arguments to
the <tt>getinfo</tt>(9E) routine.</p><a name="eqbiy"></a><h6>Table&nbsp;2-1 Get Driver Information Entry Point Arguments</h6><table><col width="30%"><col width="25%"><col width="45%"><tr><th align="left" valign="top" scope="column"><p><i>cmd</i></p></th>
<th align="left" valign="top" scope="column"><p><i>arg</i></p></th>
<th align="left" valign="top" scope="column"><p><i>resultp</i></p></th>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>DDI_INFO_DEVT2DEVINFO</tt></p></td>
<td align="left" valign="top" scope="row"><p>Device number</p></td>
<td align="left" valign="top" scope="row"><p>Device information structure pointer</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>DDI_INFO_DEVT2INSTANCE</tt></p></td>
<td align="left" valign="top" scope="row"><p>Device number</p></td>
<td align="left" valign="top" scope="row"><p>Device instance number</p></td>
</tr>
</table><p>The following code is the <tt>dummy_getinfo()</tt> routine that you should enter into your
<tt>dummy.c</tt> file. You can copy the name portion of this function definition directly
from the declaration you entered in <a href="#epmqa">Declaring the Autoconfiguration Entry Points</a>.</p><pre>static int
dummy_getinfo(dev_info_t *dip, ddi_info_cmd_t cmd, void *arg, 
    void **resultp)
{
    cmn_err(CE_NOTE, "Inside dummy_getinfo");
    switch(cmd) {
    case DDI_INFO_DEVT2DEVINFO:
        *resultp = dummy_dip;
        return DDI_SUCCESS;
    case DDI_INFO_DEVT2INSTANCE:
        *resultp = 0;
        return DDI_SUCCESS;
    default:
        return DDI_FAILURE;
    }
}</pre><p>First, use <tt>cmn_err</tt>(9F) to write a message to the system log, as
you did in your <tt>_init</tt>(9E) entry point. Then provide <tt>DDI_INFO_DEVT2DEVINFO</tt> behavior. A realistic driver
would use <i>arg</i> to get the instance number of this device node. A
realistic driver would then call the <tt>ddi_get_soft_state</tt>(9F) function and return the device
information structure pointer from that state structure. This <tt>dummy</tt> driver supports only one instance
and does not use a state structure. In the <tt>DDI_INFO_DEVT2DEVINFO</tt> code of
this <tt>dummy_getinfo()</tt> routine, simply return the one device information structure pointer that the
<tt>dummy_attach()</tt> routine saved.</p><p>Next, provide <tt>DDI_INFO_DEVT2INSTANCE</tt> behavior. Within the <tt>DDI_INFO_DEVT2INSTANCE</tt> code, simply return 0. This <tt>dummy</tt>
driver supports only one instance. The instance number of that one instance is
0.</p>

<a name="epmqj"></a><h5>Defining the Report Driver Property Information Entry Point</h5>
<a name="indexterm-251"></a><a name="indexterm-252"></a><a name="indexterm-253"></a><a name="indexterm-254"></a><a name="indexterm-255"></a><p>The <a href="http://docs.sun.com/doc/819-2255/prop-op-9e?a=view"><tt>prop_op</tt>(9E)</a> entry point is required for every driver. If your driver does
not need to customize the behavior of the <tt>prop_op</tt>(9E) entry point, then your
driver can use the <a href="http://docs.sun.com/doc/819-2256/ddi-prop-op-9f?a=view"><tt>ddi_prop_op</tt>(9F)</a> function for the <tt>prop_op</tt>(9E) entry point. Drivers that
create and manage their own properties need a custom <tt>prop_op</tt>(9E) routine. This <tt>dummy</tt>
driver uses a <tt>prop_op</tt>(9E) routine to call <a href="http://docs.sun.com/doc/819-2256/cmn-err-9f?a=view"><tt>cmn_err</tt>(9F)</a> before calling the <tt>ddi_prop_op</tt>(9F) function.</p><p>The <tt>prop_op</tt>(9E) entry point and the <tt>ddi_prop_op</tt>(9F) function both require that you
include the <tt>types.h</tt> header file. The <tt>prop_op</tt>(9E) entry point and the <tt>ddi_prop_op</tt>(9F) function
both take the same seven arguments. These arguments are not discussed here because
this <tt>dummy</tt> driver does not create and manage its own properties. See the
<tt>prop_op</tt>(9E) man page to learn about the <tt>prop_op</tt>(9E) arguments.</p><p>The following code is the <tt>dummy_prop_op()</tt> routine that you should enter into your
<tt>dummy.c</tt> file. You can copy the name portion of this function definition directly
from the declaration you entered in <a href="#epmqa">Declaring the Autoconfiguration Entry Points</a>.</p><pre>static int
dummy_prop_op(dev_t dev, dev_info_t *dip, ddi_prop_op_t prop_op,
    int flags, char *name, caddr_t valuep, int *lengthp)
{
    cmn_err(CE_NOTE, "Inside dummy_prop_op");
    return(ddi_prop_op(dev,dip,prop_op,flags,name,valuep,lengthp));
}</pre><p>First, use <tt>cmn_err</tt>(9F) to write a message to the system log, as
you did in your <tt>_init</tt>(9E) entry point. Then call the <tt>ddi_prop_op</tt>(9F) function with
exactly the same arguments as the <tt>dummy_prop_op()</tt> function.</p>

<a name="epmqe"></a><h5>Including Autoconfiguration Header Files</h5>
<p>All of the autoconfiguration entry point routines and all of the user context
entry point routines require that you include the <tt>ddi.h</tt> and <tt>sunddi.h</tt> header
files. You already included these two header files for the <tt>cmn_err</tt>(9F) function.</p><p>The <a href="http://docs.sun.com/doc/819-2256/ddi-create-minor-node-9f?a=view"><tt>ddi_create_minor_node</tt>(9F)</a> function requires the <tt>stat.h</tt> header file. The <tt>dummy_attach()</tt> routine calls the
<tt>ddi_create_minor_node</tt>(9F) function. The <a href="http://docs.sun.com/doc/819-2255/prop-op-9e?a=view"><tt>prop_op</tt>(9E)</a> and the <a href="http://docs.sun.com/doc/819-2256/ddi-prop-op-9f?a=view"><tt>ddi_prop_op</tt>(9F)</a> functions require the <tt>types.h</tt> header file.</p><p>The following code is the list of header files that you now
should have included in your <tt>dummy.c</tt> file for the four autoconfiguration routines you have
written in this section and the three loadable module configuration routines you wrote
in the previous section.</p><pre>#include &lt;sys/modctl.h&gt;  /* used by _init, _info, _fini */
#include &lt;sys/types.h&gt;   /* used by prop_op, ddi_prop_op */
#include &lt;sys/stat.h&gt;    /* defines S_IFCHR used by ddi_create_minor_node */
#include &lt;sys/cmn_err.h&gt; /* used by all entry points for this driver */
#include &lt;sys/ddi.h&gt;     /* used by all entry points for this driver */
                         /* also used by ddi_get_instance, ddi_prop_op */
#include &lt;sys/sunddi.h&gt;  /* used by all entry points for this driver */
                         /* also used by ddi_create_minor_node, */
                         /* ddi_get_instance, and ddi_prop_op */</pre>

<a name="epmni"></a><h4>Writing the User Context Entry Points</h4>
<a name="indexterm-256"></a><a name="indexterm-257"></a><a name="indexterm-258"></a><a name="indexterm-259"></a><a name="indexterm-260"></a><a name="indexterm-261"></a><a name="indexterm-262"></a><a name="indexterm-263"></a><a name="indexterm-264"></a><a name="indexterm-265"></a><a name="indexterm-266"></a><p>User context entry points correspond closely to system calls. When a system call
opens a device file, then the <tt>open</tt>(9E) routine in the driver for
that device is called.</p><p>All character and block drivers must define the <tt>open</tt>(9E) user context entry point.
However, the <tt>open</tt>(9E) routine can be <a href="http://docs.sun.com/doc/819-2256/nulldev-9f?a=view"><tt>nulldev</tt>(9F)</a>. The <tt>close</tt>(9E), <tt>read</tt>(9E), and <tt>write</tt>(9E) user
context routines are optional.</p>
<ul><li><p>The <a href="http://docs.sun.com/doc/819-2255/open-9e?a=view"><tt>open</tt>(9E)</a> routine gains access to the device.</p></li>
<li><p>The <a href="http://docs.sun.com/doc/819-2255/close-9e?a=view"><tt>close</tt>(9E)</a> routine relinquishes access to the device. The <tt>close</tt>(9E) routine must undo everything that the <tt>open</tt>(9E) routine did.</p></li>
<li><p>The <a href="http://docs.sun.com/doc/819-2255/read-9e?a=view"><tt>read</tt>(9E)</a> routine reads data from the device node.</p></li>
<li><p>The <a href="http://docs.sun.com/doc/819-2255/write-9e?a=view"><tt>write</tt>(9E)</a> routine writes data to the device node.</p></li></ul>
<p>In this section, the following code is added:</p><pre>/* Use context entry points */
static int
dummy_open(dev_t *devp, int flag, int otyp, cred_t *cred)
{
    cmn_err(CE_NOTE, "Inside dummy_open");
    return DDI_SUCCESS;
}

static int
dummy_close(dev_t dev, int flag, int otyp, cred_t *cred)
{
    cmn_err(CE_NOTE, "Inside dummy_close");
    return DDI_SUCCESS;
}

static int
dummy_read(dev_t dev, struct uio *uiop, cred_t *credp)
{
    cmn_err(CE_NOTE, "Inside dummy_read");
    return DDI_SUCCESS;
}

static int
dummy_write(dev_t dev, struct uio *uiop, cred_t *credp)
{
    cmn_err(CE_NOTE, "Inside dummy_write");
    return DDI_SUCCESS;
}</pre>

<a name="eqbim"></a><h5>Declaring the User Context Entry Points</h5>
<p>The user context entry point routines need to be uniquely named for this
driver. Use the same prefix for each of the user context entry
points that you used for each of the autoconfiguration entry point routines. The following
declarations are the entry point declarations you should have in your <tt>dummy.c</tt> file:</p><pre>static int dummy_attach(dev_info_t *dip, ddi_attach_cmd_t cmd);
static int dummy_detach(dev_info_t *dip, ddi_detach_cmd_t cmd);
static int dummy_getinfo(dev_info_t *dip, ddi_info_cmd_t cmd, void *arg,
    void **resultp);
static int dummy_prop_op(dev_t dev, dev_info_t *dip, ddi_prop_op_t prop_op,
    int flags, char *name, caddr_t valuep, int *lengthp);
static int dummy_open(dev_t *devp, int flag, int otyp, cred_t *cred);
static int dummy_close(dev_t dev, int flag, int otyp, cred_t *cred);
static int dummy_read(dev_t dev, struct uio *uiop, cred_t *credp);
static int dummy_write(dev_t dev, struct uio *uiop, cred_t *credp);</pre>

<a name="eqbii"></a><h5>Defining the Open Device Entry Point</h5>
<a name="indexterm-267"></a><a name="indexterm-268"></a><p>The <a href="http://docs.sun.com/doc/819-2255/open-9e?a=view"><tt>open</tt>(9E)</a> routine returns type <tt>int</tt>. The <tt>open</tt>(9E) routine should return either <tt>DDI_SUCCESS</tt>
or the appropriate error number.</p><p>The <tt>open</tt>(9E) routine takes four arguments. This <tt>dummy</tt> driver is so simple that
this <tt>dummy_open()</tt> routine does not use any of the <tt>open</tt>(9E) arguments. The examples
in <a href="faatl.html">Chapter&nbsp;3, Reading and Writing Data in Kernel Memory</a> show the <tt>open</tt>(9E) routine in more detail.</p><p>The following code is the <tt>dummy_open()</tt> routine that you should enter into your
<tt>dummy.c</tt> file. You can copy the name portion of this function definition directly
from the declaration you entered in <a href="#eqbim">Declaring the User Context Entry Points</a>. Write a message to the system log
and return success.</p><pre>static int
dummy_open(dev_t *devp, int flag, int otyp, cred_t *cred)
{
    cmn_err(CE_NOTE, "Inside dummy_open");
    return DDI_SUCCESS;
}</pre>

<a name="eqbil"></a><h5>Defining the Close Device Entry Point</h5>
<a name="indexterm-269"></a><a name="indexterm-270"></a><p>The <a href="http://docs.sun.com/doc/819-2255/close-9e?a=view"><tt>close</tt>(9E)</a> routine returns type <tt>int</tt>. The <tt>close</tt>(9E) routine should return either <tt>DDI_SUCCESS</tt>
or the appropriate error number.</p><p>The <tt>close</tt>(9E) routine takes four arguments. This <tt>dummy</tt> driver is so simple that
this <tt>dummy_close()</tt> routine does not use any of the <tt>close</tt>(9E) arguments. The examples
in <a href="faatl.html">Chapter&nbsp;3, Reading and Writing Data in Kernel Memory</a> show the <tt>close</tt>(9E) routine in more detail.</p><p>The <tt>close</tt>(9E) routine must undo everything that the <tt>open</tt>(9E) routine did. The <tt>close</tt>(9E)
routine must deallocate anything that was allocated, close anything that was opened, and
destroy anything that was created in the <tt>open</tt>(9E) routine. In this <tt>dummy</tt> driver,
the <tt>open</tt>(9E) routine is so simple that nothing needs to be reclaimed or
undone in the <tt>close</tt>(9E) routine.</p><p>The following code is the <tt>dummy_close()</tt> routine that you should enter into your
<tt>dummy.c</tt> file. You can copy the name portion of this function definition directly
from the declaration you entered in <a href="#eqbim">Declaring the User Context Entry Points</a>. Write a message to the system log
and return success.</p><pre>static int
dummy_close(dev_t dev, int flag, int otyp, cred_t *cred)
{
    cmn_err(CE_NOTE, "Inside dummy_close");
    return DDI_SUCCESS;
}</pre>

<a name="eqbjc"></a><h5>Defining the Read Device Entry Point</h5>
<a name="indexterm-271"></a><a name="indexterm-272"></a><p>The <a href="http://docs.sun.com/doc/819-2255/read-9e?a=view"><tt>read</tt>(9E)</a> routine returns type <tt>int</tt>. The <tt>read</tt>(9E) routine should return either <tt>DDI_SUCCESS</tt>
or the appropriate error number.</p><p>The <tt>read</tt>(9E) routine takes three arguments. This <tt>dummy</tt> driver is so simple that
this <tt>dummy_read()</tt> routine does not use any of the <tt>read</tt>(9E) arguments. The examples
in <a href="faatl.html">Chapter&nbsp;3, Reading and Writing Data in Kernel Memory</a> show the <tt>read</tt>(9E) routine in more detail.</p><p>The following code is the <tt>dummy_read()</tt> routine that you should enter into your
<tt>dummy.c</tt> file. You can copy the name portion of this function definition directly
from the declaration you entered in <a href="#eqbim">Declaring the User Context Entry Points</a>. Write a message to the system log
and return success.</p><pre>static int
dummy_read(dev_t dev, struct uio *uiop, cred_t *credp)
{
    cmn_err(CE_NOTE, "Inside dummy_read");
    return DDI_SUCCESS;
}</pre>

<a name="eqbjb"></a><h5>Defining the Write Device Entry Point</h5>
<a name="indexterm-273"></a><a name="indexterm-274"></a><p>The <a href="http://docs.sun.com/doc/819-2255/write-9e?a=view"><tt>write</tt>(9E)</a> routine returns type <tt>int</tt>. The <tt>write</tt>(9E) routine should return either <tt>DDI_SUCCESS</tt>
or the appropriate error number.</p><p>The <tt>write</tt>(9E) routine takes three arguments. This <tt>dummy</tt> driver is so simple that
this <tt>dummy_write()</tt> routine does not use any of the <tt>write</tt>(9E) arguments. The examples
in <a href="faatl.html">Chapter&nbsp;3, Reading and Writing Data in Kernel Memory</a> show the <tt>write</tt>(9E) routine in more detail.</p><p>The following code is the <tt>dummy_write()</tt> routine that you should enter into your
<tt>dummy.c</tt> file. You can copy the name portion of this function definition directly
from the declaration you entered in <a href="#eqbim">Declaring the User Context Entry Points</a>. Write a message to the system log
and return success.</p><pre>static int
dummy_write(dev_t dev, struct uio *uiop, cred_t *credp)
{
    cmn_err(CE_NOTE, "Inside dummy_write");
    return DDI_SUCCESS;
}</pre>

<a name="eqbit"></a><h5>Including User Context Header Files</h5>
<p>The four user context entry point routines require your module to include several
header files. You already have included the <tt>types.h</tt> header file, the <tt>ddi.h</tt> header
file, and the <tt>sunddi.h</tt> header file. You need to include the <tt>file.h</tt>, <tt>errno.h</tt>,
<tt>open.h</tt>, <tt>cred.h</tt>, and <tt>uio.h</tt> header files.</p><p>The following code is the list of header files that you now
should have included in your <tt>dummy.c</tt> file for all the entry points you have
written in this section and the previous two sections:</p><pre>#include &lt;sys/modctl.h&gt;  /* used by modlinkage, modldrv, _init, _info, */
                         /* and _fini */
#include &lt;sys/types.h&gt;   /* used by open, close, read, write, prop_op, */
                         /* and ddi_prop_op */
#include &lt;sys/file.h&gt;    /* used by open, close */
#include &lt;sys/errno.h&gt;   /* used by open, close, read, write */
#include &lt;sys/open.h&gt;    /* used by open, close, read, write */
#include &lt;sys/cred.h&gt;    /* used by open, close, read */
#include &lt;sys/uio.h&gt;     /* used by read */
#include &lt;sys/stat.h&gt;    /* defines S_IFCHR used by ddi_create_minor_node */
#include &lt;sys/cmn_err.h&gt; /* used by all entry points for this driver */
#include &lt;sys/ddi.h&gt;     /* used by all entry points for this driver */
                         /* also used by ddi_get_instance and */
                         /* ddi_prop_op */
#include &lt;sys/sunddi.h&gt;  /* used by all entry points for this driver */
                         /* also used by ddi_create_minor_node, */
                         /* ddi_get_instance, and ddi_prop_op */</pre>

<a name="eoxzx"></a><h4>Writing the Driver Data Structures</h4>
<a name="indexterm-275"></a><a name="indexterm-276"></a><a name="indexterm-277"></a><a name="indexterm-278"></a><a name="indexterm-279"></a><a name="indexterm-280"></a><a name="indexterm-281"></a><a name="indexterm-282"></a><p>All of the data structures described in this section are required for every
device driver. All drivers must define a <a href="http://docs.sun.com/doc/819-2257/dev-ops-9s?a=view"><tt>dev_ops</tt>(9S)</a> device operations structure. Because the
<tt>dev_ops</tt>(9S) structure includes a pointer to the <a href="http://docs.sun.com/doc/819-2257/cb-ops-9s?a=view"><tt>cb_ops</tt>(9S)</a> character and block operations structure,
you must define the <tt>cb_ops</tt>(9S) structure first. The <a href="http://docs.sun.com/doc/819-2257/modldrv-9s?a=view"><tt>modldrv</tt>(9S)</a> linkage structure for loadable drivers
includes a pointer to the <tt>dev_ops</tt>(9S) structure. The <a href="http://docs.sun.com/doc/819-2257/modlinkage-9s?a=view"><tt>modlinkage</tt>(9S)</a> module linkage structure includes
a pointer to the <tt>modldrv</tt>(9S) structure.</p><p>Except for the loadable module configuration entry points, all of the required entry
points for a driver are initialized in the character and block operations structure
or in the device operations structure. Some optional entry points and other related
data also are initialized in these data structures. Initializing the entry points in
these data structures enables the driver to be dynamically loaded.</p><p>The loadable module configuration entry points are not initialized in driver data structures.
The <tt>_init</tt>(9E), <tt>_info</tt>(9E), and <tt>_fini</tt>(9E) entry points are required for all kernel modules
and are not specific to device driver modules.</p><p>In this section, the following code is added:</p><pre>/* cb_ops structure */
static struct cb_ops dummy_cb_ops = {
    dummy_open,
    dummy_close,
    nodev,              /* no strategy - nodev returns ENXIO */
    nodev,              /* no print */
    nodev,              /* no dump */
    dummy_read,
    dummy_write,
    nodev,              /* no ioctl */
    nodev,              /* no devmap */
    nodev,              /* no mmap */
    nodev,              /* no segmap */
    nochpoll,           /* returns ENXIO for non-pollable devices */
    dummy_prop_op,
    NULL,               /* streamtab struct; if not NULL, all above */
                        /* fields are ignored */
    D_NEW | D_MP,       /* compatibility flags: see conf.h */
    CB_REV,             /* cb_ops revision number */
    nodev,              /* no aread */
    nodev               /* no awrite */
};

/* dev_ops structure */
static struct dev_ops dummy_dev_ops = {
    DEVO_REV,
    0,                         /* reference count */
    dummy_getinfo,             /* no getinfo(9E) */
    nulldev,                   /* no identify(9E) - nulldev returns 0 */
    nulldev,                   /* no probe(9E) */
    dummy_attach,
    dummy_detach,
    nodev,                     /* no reset - nodev returns ENXIO */
    &amp;dummy_cb_ops,
    (struct bus_ops *)NULL,
    nodev,                     /* no power(9E) */
    ddi_quiesce_not_needed,    /* no quiesce(9E) */
};

/* modldrv structure */
static struct modldrv md = {
    &amp;mod_driverops,     /* Type of module. This is a driver. */
    "dummy driver",     /* Name of the module. */
    &amp;dummy_dev_ops
};

/* modlinkage structure */
static struct modlinkage ml = {
    MODREV_1,
    &amp;md,
    NULL
};

/* dev_info structure */
dev_info_t *dummy_dip;  /* keep track of one instance */</pre>

<a name="eoyag"></a><h5>Defining the Character and Block Operations Structure</h5>
<a name="indexterm-283"></a><a name="indexterm-284"></a><a name="indexterm-285"></a><p>The <a href="http://docs.sun.com/doc/819-2257/cb-ops-9s?a=view"><tt>cb_ops</tt>(9S)</a> structure initializes standard character and block interfaces. See the <tt>cb_ops</tt>(9S) man page
to learn what each element is and what the value of each
element should be. This <tt>dummy</tt> driver does not use all of the elements in
the <tt>cb_ops</tt>(9S) structure. See the description that follows the code sample.</p><p>When you name this structure, use the same <tt>dummy_</tt> prefix that you used
for the names of the autoconfiguration routines and the names of the user
context routines. Prepend the <tt>static</tt> type modifier to the declaration.</p><p>The following code is the <tt>cb_ops</tt>(9S) structure that you should enter into your
<tt>dummy.c</tt> file:</p><pre>static struct cb_ops dummy_cb_ops = {
    dummy_open,
    dummy_close,
    nodev,              /* no strategy - nodev returns ENXIO */
    nodev,              /* no print */
    nodev,              /* no dump */
    dummy_read,
    dummy_write,
    nodev,              /* no ioctl */
    nodev,              /* no devmap */
    nodev,              /* no mmap */
    nodev,              /* no segmap */
    nochpoll,           /* returns ENXIO for non-pollable devices */
    dummy_prop_op,
    NULL,               /* streamtab struct; if not NULL, all above */
                        /* fields are ignored */
    D_NEW | D_MP,       /* compatibility flags: see conf.h */
    CB_REV,             /* cb_ops revision number */
    nodev,              /* no aread */
    nodev               /* no awrite */
};</pre><p>Enter the names of the <tt>open</tt>(9E) and <tt>close</tt>(9E) entry points for this
driver as the values of the first two elements of this structure. Enter
the names of the <tt>read</tt>(9E) and <tt>write</tt>(9E) entry points for this driver as
the values of the sixth and seventh elements of this structure. Enter the
name of the <tt>prop_op</tt>(9E) entry point for this driver as the value of
the thirteenth element in this structure.</p><p><a name="indexterm-286"></a><a name="indexterm-287"></a><a name="indexterm-288"></a><a name="indexterm-289"></a>The <tt>strategy</tt>(9E), <tt>print</tt>(9E), and <tt>dump</tt>(9E) routines are for block drivers only. This <tt>dummy</tt>
driver does not define these three routines because this driver is a character
driver. This driver does not define an <tt>ioctl</tt>(9E) entry point because this driver
does not use I/O control commands. This driver does not define <tt>devmap</tt>(9E), <tt>mmap</tt>(9E), or
<tt>segmap</tt>(9E) entry points because this driver does not support memory mapping. This driver
does not does not define <tt>aread</tt>(9E) or <tt>awrite</tt>(9E) entry points because this
driver does not perform any asynchronous reads or writes. Initialize all of these unused
function elements to <a href="http://docs.sun.com/doc/819-2256/nodev-9f?a=view"><tt>nodev</tt>(9F)</a>. The <tt>nodev</tt>(9F) function returns the <tt>ENXIO</tt> error code.</p><p>Specify the <a href="http://docs.sun.com/doc/819-2256/nochpoll-9f?a=view"><tt>nochpoll</tt>(9F)</a> function for the <tt>chpoll</tt>(9E) element of the <tt>cb_ops</tt>(9S) structure because
this driver is not for a pollable device. Specify <tt>NULL</tt> for the <tt>streamtab</tt>(9S)
STREAMS entity declaration structure because this driver is not a STREAMS driver.</p><p>The compatibility flags are defined in the <tt>conf.h</tt> header file. The <tt>D_NEW</tt> flag
means this driver is a new-style driver. The <tt>D_MP</tt> flag means this driver
safely allows multiple threads of execution. All drivers must be multithreaded-safe, and must
specify this <tt>D_MP</tt> flag. The <tt>D_64BIT</tt> flag means this driver supports 64-bit offsets and
block numbers. See the <tt>conf.h</tt> header file for more compatibility flags.</p><p>The <tt>CB_REV</tt> element of the <tt>cb_ops</tt>(9S) structure is the <tt>cb_ops</tt>(9S) revision number. <tt>CB_REV</tt>
is defined in the <tt>devops.h</tt> header file.</p>

<a name="eoyaf"></a><h5>Defining the Device Operations Structure</h5>
<a name="indexterm-290"></a><a name="indexterm-291"></a><a name="indexterm-292"></a><p>The <a href="http://docs.sun.com/doc/819-2257/dev-ops-9s?a=view"><tt>dev_ops</tt>(9S)</a> structure initializes interfaces that are used for operations such as attaching
and detaching the driver. See the <tt>dev_ops</tt>(9S) man page to learn what each
element is and what the value of each element should be. This <tt>dummy</tt>
driver does not use all of the elements in the <tt>dev_ops</tt>(9S) structure. See
the description that follows the code sample.</p><p>When you name this structure, use the same <tt>dummy_</tt> prefix that you used
for the names of the autoconfiguration routines and the names of the user
context routines. Prepend the <tt>static</tt> type modifier to the declaration.</p><p>The following code is the <tt>dev_ops</tt>(9S) structure that you should enter into your
<tt>dummy.c</tt> file:</p><pre>static struct dev_ops dummy_dev_ops = {
    DEVO_REV,
    0,                         /* reference count */
    dummy_getinfo,             /* no getinfo(9E) */
    nulldev,                   /* no identify(9E) - nulldev returns 0 */
    nulldev,                   /* no probe(9E) */
    dummy_attach,
    dummy_detach,
    nodev,                     /* no reset - nodev returns ENXIO */
    &amp;dummy_cb_ops,
    (struct bus_ops *)NULL,
    nodev,                     /* no power(9E) */
    ddi_quiesce_not_needed,    /* no quiesce(9E) */
};</pre><p>The <tt>DEVO_REV</tt> element of the <tt>dev_ops</tt>(9S) structure is the driver build version. <tt>DEVO_REV</tt>
is defined in the <tt>devops.h</tt> header file. The second element in this
structure is the driver reference count. Initialize this value to zero. The driver
reference count is the number of instances of this driver that are currently
open. The driver cannot be unloaded if any instances of the driver are
still open.</p><p><a name="indexterm-293"></a><a name="indexterm-294"></a><a name="indexterm-295"></a><a name="indexterm-296"></a>The next six elements of the <tt>dev_ops</tt>(9S) structure are the names of the
<tt>getinfo</tt>(9E), <tt>identify</tt>(9E), <tt>probe</tt>(9E), <tt>attach</tt>(9E), <tt>detach</tt>(9E), and <tt>reset()</tt> functions for this particular driver. The
<tt>identify</tt>(9E) function is obsolete. Initialize this structure element to <a href="http://docs.sun.com/doc/819-2256/nulldev-9f?a=view"><tt>nulldev</tt>(9F)</a>. The <tt>probe</tt>(9E) function determines
whether the corresponding device exists and is valid. This <tt>dummy</tt> driver does
not define a <tt>probe</tt>(9E) function. Initialize this structure element to <tt>nulldev</tt>. The <tt>nulldev</tt>(9F)
function returns success. The <tt>reset()</tt> function is obsolete. Initialize the <tt>reset()</tt> function to
<a href="http://docs.sun.com/doc/819-2256/nodev-9f?a=view"><tt>nodev</tt>(9F)</a>.</p><p>The next element of the <tt>dev_ops</tt>(9S) structure is a pointer to the
<tt>cb_ops</tt>(9S) structure for this driver. You initialized the <tt>cb_ops</tt>(9S) structure for this driver
in <a href="#eoyag">Defining the Character and Block Operations Structure</a>. Enter <tt>&amp;dummy_cb_ops</tt> for the value of the pointer to the <tt>cb_ops</tt>(9S) structure.</p><p>The next element of the <tt>dev_ops</tt>(9S) structure is a pointer to the
bus operations structure. Only nexus drivers have bus operations structures. This <tt>dummy</tt> driver
is not a nexus driver. Set this value to <tt>NULL</tt> because this driver
is a leaf driver.</p><p>The next element of the <tt>dev_ops</tt>(9S) structure is the name of the
<tt>power</tt>(9E) routine for this driver. The <tt>power</tt>(9E) routine operates on a hardware device. This
driver does not drive a hardware device. Set the value of this
structure element to <tt>nodev</tt>.</p><p>The last element of the <tt>dev_ops</tt>(9S) structure is the name of the
<a href="http://docs.sun.com/doc/819-2255/quiesce-9e?a=view"><tt>quiesce</tt>(9E)</a> routine for this driver. The <tt>quiesce</tt>(9E) routine operates on a hardware device.
This driver does not drive a hardware device. Set the value of this
structure element to <tt>ddi_quiesce_not_needed()</tt>(9F).</p>

<a name="epffy"></a><h5>Defining the Module Linkage Structures</h5>
<a name="indexterm-297"></a><a name="indexterm-298"></a><a name="indexterm-299"></a><a name="indexterm-300"></a><a name="indexterm-301"></a><p>Two other module loading structures are required for every driver. The <a href="http://docs.sun.com/doc/819-2257/modlinkage-9s?a=view"><tt>modlinkage</tt>(9S)</a>
module linkage structure is used by the <tt>_init</tt>(9E), <tt>_info</tt>(9E), and <tt>_fini</tt>(9E) routines to
install, remove, and retrieve information from a module. The <a href="http://docs.sun.com/doc/819-2257/modldrv-9s?a=view"><tt>modldrv</tt>(9S)</a> linkage structure for
loadable drivers exports driver-specific information to the kernel. See the man pages for each
structure to learn what each element is and what the value of
each element should be.</p><p>The following code defines the <tt>modldrv</tt>(9S) and <tt>modlinkage</tt>(9S) structures for the driver shown
in this chapter:</p><pre>static struct modldrv md = {
    &amp;mod_driverops,     /* Type of module. This is a driver. */
    "dummy driver",     /* Name of the module. */
    &amp;dummy_dev_ops
};

static struct modlinkage ml = {
    MODREV_1,
    &amp;md,
    NULL
};</pre><p>The first element in the <tt>modldrv</tt>(9S) structure is a pointer to a
structure that tells the kernel what kind of module this is. Set this
value to the address of the <tt>mod_driverops</tt> structure. The <tt>mod_driverops</tt> structure tells the kernel
that the <tt>dummy.c</tt> module is a loadable driver module. The <tt>mod_driverops</tt> structure is
declared in the <tt>modctl.h</tt> header file. You already included the <tt>modctl.h</tt> header file
in your <tt>dummy.c</tt> file, so do not declare the <tt>mod_driverops</tt> structure in <tt>dummy.c</tt>.
The <tt>mod_driverops</tt> structure is defined in the <tt>modctl.c</tt> source file.</p><p>The second element in the <tt>modldrv</tt>(9S) structure is a string that describes this
module. Usually this string contains the name of this module and the version
number of this module. The last element of the <tt>modldrv</tt>(9S) structure is a
pointer to the <tt>dev_ops</tt>(9S) structure for this driver. You initialized the <tt>dev_ops</tt>(9S) structure
for this driver in <a href="#eoyaf">Defining the Device Operations Structure</a>.</p><p>The first element in the <tt>modlinkage</tt>(9S) structure is the revision number of the
loadable modules system. Set this value to <tt>MODREV_1</tt>. The next element of the
<tt>modlinkage</tt>(9S) structure is the address of a null-terminated array of pointers to linkage
structures. Driver modules have only one linkage structure. Enter the address of the
<tt>md</tt> structure for the value of this element of the <tt>modlinkage</tt>(9S) structure. Enter
the value <tt>NULL</tt> to terminate this list of linkage structures.</p>

<a name="eqbni"></a><h5>Including Data Structures Header Files</h5>
<p>The <a href="http://docs.sun.com/doc/819-2257/cb-ops-9s?a=view"><tt>cb_ops</tt>(9S)</a> and <a href="http://docs.sun.com/doc/819-2257/dev-ops-9s?a=view"><tt>dev_ops</tt>(9S)</a> structures require you to include the <tt>conf.h</tt> and <tt>devops.h</tt>
header files. The <a href="http://docs.sun.com/doc/819-2257/modlinkage-9s?a=view"><tt>modlinkage</tt>(9S)</a> and <a href="http://docs.sun.com/doc/819-2257/modldrv-9s?a=view"><tt>modldrv</tt>(9S)</a> structures require you to include the <tt>modctl.h</tt> header
file. You already included the <tt>modctl.h</tt> header file for the loadable module configuration entry
points.</p><p>The following code is the complete list of header files that you
now should have included in your <tt>dummy.c</tt> file:</p><pre>#include &lt;sys/devops.h&gt;  /* used by dev_ops */
#include &lt;sys/conf.h&gt;    /* used by dev_ops and cb_ops */
#include &lt;sys/modctl.h&gt;  /* used by modlinkage, modldrv, _init, _info, */
                         /* and _fini */
#include &lt;sys/types.h&gt;   /* used by open, close, read, write, prop_op, */
                         /* and ddi_prop_op */
#include &lt;sys/file.h&gt;    /* used by open, close */
#include &lt;sys/errno.h&gt;   /* used by open, close, read, write */
#include &lt;sys/open.h&gt;    /* used by open, close, read, write */
#include &lt;sys/cred.h&gt;    /* used by open, close, read */
#include &lt;sys/uio.h&gt;     /* used by read */
#include &lt;sys/stat.h&gt;    /* defines S_IFCHR used by ddi_create_minor_node */
#include &lt;sys/cmn_err.h&gt; /* used by all entry points for this driver */
#include &lt;sys/ddi.h&gt;     /* used by all entry points for this driver */
                         /* also used by cb_ops, ddi_get_instance, and */
                         /* ddi_prop_op */
#include &lt;sys/sunddi.h&gt;  /* used by all entry points for this driver */
                         /* also used by cb_ops, ddi_create_minor_node, */
                         /* ddi_get_instance, and ddi_prop_op */</pre>
         </div>
      </td>
   </tr>

   <tr class="PageControls" valign="top">
      <td></td>
      <td>
         <table width="100%">
      	   <tr>
      	     <td>
                 <a href="ffzpv.html">Previous</a>
             </td>
             <td align="right">
                 <a href="eoxzw.html">Next</a>
             </td>
           </tr>
         </table>
      </td>
   </tr>
</tbody>
</table>


</body>
</html>

