<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="en-US">
<head>
<meta http-equiv="Content-type" content="text/html; charset=iso-8859-1">
<title>Building and Transporting a Command - Writing Device Drivers</title>
<meta name="robots" content="index,follow">
<meta name="robots" content="index,follow">
<meta name="date" content="2008-08-01">
<meta name="collection" content="reference">
<link rel="stylesheet" type="text/css" href="css/elements.css">
<link rel="stylesheet" type="text/css" href="css/indiana.css">
</head>

<body>


<div class="Masthead">
   <div class="MastheadLogo">
      <a href="http://www.opensolaris.org"><img border="0" src="graphics/header.png"></img></a>
   </div>
   <div class="Title">Writing Device Drivers</div>
</div>

<table class="Layout" border="0" cellspacing="0" width="100%">
<tbody>

   <tr valign="top" class="PageControls">
      <td></td>
      <td>
         <table width="100%">
      	   <tr>
      	     <td>
                 <a href="scsi-12.html">Previous</a>
             </td>
             <td align="right">
                 <a href="scsi-100.html">Next</a>
             </td>
           </tr>
         </table>
      </td>
   </tr>
   
   <tr valign="top">
      <td class="Navigation" width="200px"><p class="toc level1"><a href="docinfo.html">Document Information</a></p>
<p class="toc level1 tocsp"><a href="preface-1.html">Preface</a></p>
<p class="toc level1 tocsp"><a href="eqbvu.html">Part&nbsp;I&nbsp;Designing Device Drivers for the Solaris Platform</a></p>
<p class="toc level2"><a href="eqbqn.html">1.&nbsp;&nbsp;Overview of Solaris Device Drivers</a></p>
<p class="toc level2"><a href="kernelovr-77198.html">2.&nbsp;&nbsp;Solaris Kernel and Device Tree</a></p>
<p class="toc level2"><a href="mt-17026.html">3.&nbsp;&nbsp;Multithreading</a></p>
<p class="toc level2"><a href="properties-1.html">4.&nbsp;&nbsp;Properties</a></p>
<p class="toc level2"><a href="events-1.html">5.&nbsp;&nbsp;Managing Events and Queueing Tasks</a></p>
<p class="toc level2"><a href="autoconf-17.html">6.&nbsp;&nbsp;Driver Autoconfiguration</a></p>
<p class="toc level2"><a href="devaccess-3.html">7.&nbsp;&nbsp;Device Access: Programmed I/O</a></p>
<p class="toc level2"><a href="interrupt-15678.html">8.&nbsp;&nbsp;Interrupt Handlers</a></p>
<p class="toc level2"><a href="dma-29901.html">9.&nbsp;&nbsp;Direct Memory Access (DMA)</a></p>
<p class="toc level2"><a href="devmap-24338.html">10.&nbsp;&nbsp;Mapping Device and Kernel Memory</a></p>
<p class="toc level2"><a href="devcnmgt-19679.html">11.&nbsp;&nbsp;Device Context Management</a></p>
<p class="toc level2"><a href="powermgt-37437.html">12.&nbsp;&nbsp;Power Management</a></p>
<p class="toc level2"><a href="gevsi.html">13.&nbsp;&nbsp;Hardening Solaris Drivers</a></p>
<p class="toc level2"><a href="ldi-1.html">14.&nbsp;&nbsp;Layered Driver Interface (LDI)</a></p>
<p class="toc level1 tocsp"><a href="eqbvb.html">Part&nbsp;II&nbsp;Designing Specific Kinds of Device Drivers</a></p>
<p class="toc level2"><a href="character-21002.html">15.&nbsp;&nbsp;Drivers for Character Devices</a></p>
<p class="toc level2"><a href="block-34861.html">16.&nbsp;&nbsp;Drivers for Block Devices</a></p>
<p class="toc level2"><a href="scsi-36812.html">17.&nbsp;&nbsp;SCSI Target Drivers</a></p>
<p class="toc level3"><a href="scsi-6a.html">Introduction to Target Drivers</a></p>
<p class="toc level3"><a href="scsi-3.html">Sun Common SCSI Architecture Overview</a></p>
<p class="toc level3"><a href="scsi-37210.html">Hardware Configuration File</a></p>
<p class="toc level3"><a href="scsi-9.html">Declarations and Data Structures</a></p>
<p class="toc level3"><a href="scsi-11.html">Autoconfiguration for SCSI Target Drivers</a></p>
<p class="toc level3"><a href="scsi-12.html">Resource Allocation</a></p>
<div class="onpage">
<p class="toc level3"><a href="">Building and Transporting a Command</a></p>
</div>
<p class="toc level3"><a href="scsi-100.html">SCSI Options</a></p>
<p class="toc level2 tocsp"><a href="scsihba-32898.html">18.&nbsp;&nbsp;SCSI Host Bus Adapter Drivers</a></p>
<p class="toc level2"><a href="gld-1.html">19.&nbsp;&nbsp;Drivers for Network Devices</a></p>
<p class="toc level2"><a href="usb-1.html">20.&nbsp;&nbsp;USB Drivers</a></p>
<p class="toc level1 tocsp"><a href="eqbvo.html">Part&nbsp;III&nbsp;Building a Device Driver</a></p>
<p class="toc level2"><a href="loading-15035.html">21.&nbsp;&nbsp;Compiling, Loading, Packaging, and Testing Drivers</a></p>
<p class="toc level2"><a href="debug-60.html">22.&nbsp;&nbsp;Debugging, Testing, and Tuning Device Drivers</a></p>
<p class="toc level2"><a href="coding-practices.html">23.&nbsp;&nbsp;Recommended Coding Practices</a></p>
<p class="toc level1 tocsp"><a href="eqbva.html">Part&nbsp;IV&nbsp;Appendixes</a></p>
<p class="toc level2"><a href="hwovr-18191.html">A.&nbsp;&nbsp;Hardware Overview</a></p>
<p class="toc level2"><a href="ddidkisvc-29227.html">B.&nbsp;&nbsp;Summary of Solaris DDI/DKI Services</a></p>
<p class="toc level2"><a href="lp64-35004.html">C.&nbsp;&nbsp;Making a Device Driver 64-Bit Ready</a></p>
<p class="toc level2"><a href="euazz.html">D.&nbsp;&nbsp;Console Frame Buffer Drivers</a></p>
<p class="toc level1 tocsp"><a href="idx-1.html">Index</a></p>
</td>
      <td class="ContentPane" width="705px">

	 <div class="MainContent">      	 
             

<a name="scsi-15"></a><h3>Building and Transporting a Command</h3>
<p>The host bus adapter driver is responsible for transmitting the command to the
device. Furthermore, the driver is responsible for handling the low-level SCSI protocol. The
<a href="http://docs.sun.com/doc/819-2256/scsi-transport-9f?a=view"><tt>scsi_transport</tt>(9F)</a> routine hands a packet to the host bus adapter driver for transmission.
The target driver has the responsibility to create a valid <a href="http://docs.sun.com/doc/819-2257/scsi-pkt-9s?a=view"><tt>scsi_pkt</tt>(9S)</a> structure.
</p>

<a name="scsi-16"></a><h4>Building a Command</h4>
<p><a name="scsi-ix496"></a>The routine <a href="http://docs.sun.com/doc/819-2256/scsi-init-pkt-9f?a=view"><tt>scsi_init_pkt</tt>(9F)</a> allocates space for a SCSI CDB, allocates DMA resources if
necessary, and sets the <tt>pkt_flags</tt> field, as shown in this example:</p><pre>pkt = scsi_init_pkt(&amp;sdp-&gt;sd_address, NULL, bp,
    CDB_GROUP0, 1, 0, 0, SLEEP_FUNC, NULL);</pre><p>This example creates a new packet along with allocating DMA resources as specified
in the passed <a href="http://docs.sun.com/doc/819-2257/buf-9s?a=view"><tt>buf</tt>(9S)</a> structure pointer. A SCSI CDB is allocated for a
Group 0 (6-byte) command. The <tt>pkt_flags</tt> field is set to zero, but
no space is allocated for the <tt>pkt_private</tt> field. This call to <a href="http://docs.sun.com/doc/819-2256/scsi-init-pkt-9f?a=view"><tt>scsi_init_pkt</tt>(9F)</a>,
because of the <tt>SLEEP_FUNC</tt> parameter, waits indefinitely for resources if no resources
are currently available.</p><p><a name="scsi-ix497"></a><a name="scsi-ix498"></a>The next step is to initialize the SCSI CDB, using the <a href="http://docs.sun.com/doc/819-2256/scsi-setup-cdb-9f?a=view"><tt>scsi_setup_cdb</tt>(9F)</a> function:</p><pre>if (scsi_setup_cdb((union scsi_cdb *)pkt-&gt;pkt_cdbp,
    SCMD_READ, bp-&gt;b_blkno, bp-&gt;b_bcount &gt;&gt; DEV_BSHIFT, 0) == 0)
    goto failed;</pre><p>This example builds a Group 0 command descriptor block. The example fills in
the <tt>pkt_cdbp</tt> field as follows:</p>
<ul><li><p>The command itself is in byte 0. The command is set from the parameter <tt>SCMD_READ</tt>.</p></li>
<li><p>The address field is in bits 0-4 of byte 1 and bytes 2 and 3. The address is set from <tt>bp-&gt;b_blkno</tt>.</p></li>
<li><p>The count field is in byte 4. The count is set from the last parameter. In this case, <tt>count</tt> is set to <tt>bp-&gt;b_bcount</tt> <tt>&gt;&gt;</tt> <tt>DEV_BSHIFT</tt>, where <tt>DEV_BSHIFT</tt> is the byte count of the transfer converted to the number of blocks.</p></li></ul>

<hr><p><b>Note - </b><a name="indexterm-595"></a><a href="http://docs.sun.com/doc/819-2256/scsi-setup-cdb-9f?a=view"><tt>scsi_setup_cdb</tt>(9F)</a> does not support setting a target device's logical unit number (LUN) in
bits 5-7 of byte 1 of the SCSI command block. This requirement is
defined by SCSI-1. For SCSI-1 devices that require the LUN bits set in
the command block, use  <a href="http://docs.sun.com/doc/819-2256/makecom-g0-9f?a=view"><tt>makecom_g0</tt>(9F)</a> or some equivalent rather than  <a href="http://docs.sun.com/doc/819-2256/scsi-setup-cdb-9f?a=view"><tt>scsi_setup_cdb</tt>(9F)</a>.</p>
<hr>
<p>After initializing the SCSI CDB, initialize three other fields in the packet and
store as a pointer to the packet in the state structure.</p><pre>pkt-&gt;pkt_private = (opaque_t)bp;
pkt-&gt;pkt_comp = xxcallback;
pkt-&gt;pkt_time = 30;
xsp-&gt;pkt = pkt;</pre><p>The <a href="http://docs.sun.com/doc/819-2257/buf-9s?a=view"><tt>buf</tt>(9S)</a> pointer is saved in the <tt>pkt_private</tt> field for later use in
the completion routine.</p>

<a name="scsi-17"></a><h4>Setting Target Capabilities</h4>
<p><a name="scsi-ix499"></a><a name="scsi-ix500"></a>The target drivers use  <a href="http://docs.sun.com/doc/819-2256/scsi-ifsetcap-9f?a=view"><tt>scsi_ifsetcap</tt>(9F)</a> to set the capabilities of the host
adapter driver. A <b>cap</b> is a name-value pair, consisting of a null-terminated character string
and an integer value. The current value of a capability can be retrieved
using  <a href="http://docs.sun.com/doc/819-2256/scsi-ifgetcap-9f?a=view"><tt>scsi_ifgetcap</tt>(9F)</a>. <a href="http://docs.sun.com/doc/819-2256/scsi-ifsetcap-9f?a=view"><tt>scsi_ifsetcap</tt>(9F)</a> allows capabilities to be set for all targets
on the bus.</p><p>In general, however, setting capabilities of targets that are not owned by the
target driver is not recommended. This practice is not universally supported by HBA
drivers. Some capabilities, such as disconnect and synchronous, can be set by default
by the HBA driver. Other capabilities might need to be set explicitly by
the target driver. Wide-xfer and tagged-queueing must be set by the target drive,
for example.</p>

<a name="scsi-61361"></a><h4>Transporting a Command</h4>
<p><a name="scsi-ix501"></a>After the <a href="http://docs.sun.com/doc/819-2257/scsi-pkt-9s?a=view"><tt>scsi_pkt</tt>(9S)</a> structure is filled in, use <a href="http://docs.sun.com/doc/819-2256/scsi-transport-9f?a=view"><tt>scsi_transport</tt>(9F)</a> to hand the structure
to the bus adapter driver:</p><pre>if (scsi_transport(pkt) != TRAN_ACCEPT) {
    bp-&gt;b_resid = bp-&gt;b_bcount;
    bioerror(bp, EIO);
    biodone(bp);
}</pre><p><a name="scsi-ix502"></a>The other return values from <a href="http://docs.sun.com/doc/819-2256/scsi-transport-9f?a=view"><tt>scsi_transport</tt>(9F)</a> are as follows:</p>
<ul><li><p><tt>TRAN_BUSY</tt> &ndash; A command for the specified target is already in progress.</p></li>
<li><p><tt>TRAN_BADPKT</tt> &ndash; The DMA count in the packet was too large, or the host adapter driver rejected this packet for other reasons.</p></li></ul>

<ul><li><p><tt>TRAN_FATAL_ERROR</tt> &ndash; The host adapter driver is unable to accept this packet.</p></li></ul>

<hr><p><b>Note - </b>The mutex <tt>sd_mutex</tt> in the <a href="http://docs.sun.com/doc/819-2257/scsi-device-9s?a=view"><tt>scsi_device</tt>(9S)</a> structure must not be held across a
call to <a href="http://docs.sun.com/doc/819-2256/scsi-transport-9f?a=view"><tt>scsi_transport</tt>(9F)</a>.</p>
<hr>
<p>If  <a href="http://docs.sun.com/doc/819-2256/scsi-transport-9f?a=view"><tt>scsi_transport</tt>(9F)</a> returns <tt>TRAN_ACCEPT</tt>, the packet becomes the responsibility of the host
bus adapter driver. The packet should not be accessed by the target driver
until the command completion routine is called.</p>

<a name="scsi-18"></a><h5>Synchronous <tt>scsi_transport()</tt> Function</h5>
<p>If <tt>FLAG_NOINTR</tt> is set in the packet, then <a href="http://docs.sun.com/doc/819-2256/scsi-transport-9f?a=view"><tt>scsi_transport</tt>(9F)</a> does not return until
the command is complete.  No callback is performed.</p>
<hr><p><b>Note - </b>Do not use <tt>FLAG_NOINTR</tt> in interrupt context.</p>
<hr>


<a name="scsi-19"></a><h4>Command Completion</h4>
<p><a name="scsi-ix503"></a>When the host bus adapter driver is through with the command, the driver
invokes the packet's completion callback routine. The driver then passes a pointer to
the <a href="http://docs.sun.com/doc/819-2257/scsi-pkt-9s?a=view"><tt>scsi_pkt</tt>(9S)</a> structure as a parameter. After decoding the packet, the completion routine
takes the appropriate action.</p><p><a href="#scsi-35252">Example&nbsp;17-5</a> presents a simple completion callback routine. This code checks for transport failures. In
case of failure, the routine gives up rather than retrying the command. If
the target is busy, extra code is required to resubmit the command
at a later time.</p><p>If the command results in a check condition, the target driver needs to
send a request sense command unless auto request sense has been enabled.</p><p>Otherwise, the command succeeded. At the end of processing for the command, the
command destroys the packet and calls <a href="http://docs.sun.com/doc/819-2256/biodone-9f?a=view"><tt>biodone</tt>(9F)</a>.</p><p>In the event of a transport error, such as a bus reset
or parity problem, the target driver can resubmit the packet by using <a href="http://docs.sun.com/doc/819-2256/scsi-transport-9f?a=view"><tt>scsi_transport</tt>(9F)</a>.
No values in the packet need to be changed prior to resubmitting.</p><p>The following example does not attempt to retry incomplete commands.</p>
<hr><p><b>Note - </b>Normally, the target driver's callback function is called in interrupt context. Consequently, the
callback function should never sleep.</p>
<hr>
<a name="scsi-35252"></a><h6>Example&nbsp;17-5 Completion Routine for a SCSI Driver</h6><pre>static void
xxcallback(struct scsi_pkt *pkt)
{
    struct buf        *bp;
    struct xxstate    *xsp;
    minor_t           instance;
    struct scsi_status *ssp;
    /*
     * Get a pointer to the buf(9S) structure for the command
     * and to the per-instance data structure.
     */
    bp = (struct buf *)pkt-&gt;pkt_private;
    instance = getminor(bp-&gt;b_edev);
    xsp = ddi_get_soft_state(statep, instance);
    /*
     * Figure out why this callback routine was called
     */
    if (pkt-&gt;pkt_reason != CMP_CMPLT) {
        bp-&gt;b_resid = bp-&gt;b_bcount;
        bioerror(bp, EIO);
        scsi_destroy_pkt(pkt);          /* Release resources */
        biodone(bp);                    /* Notify waiting threads */ ;
    } else {
        /*
         * Command completed, check status.
         * See scsi_status(9S)
         */
        ssp = (struct scsi_status *)pkt-&gt;pkt_scbp;
        if (ssp-&gt;sts_busy) {
            /* error, target busy or reserved */
        } else if (ssp-&gt;sts_chk) {
            /* Send a request sense command. */
        } else {
            bp-&gt;b_resid = pkt-&gt;pkt_resid;  /* Packet completed OK */
            scsi_destroy_pkt(pkt);
            biodone(bp);
       }
    }
}</pre>

<a name="scsi-200"></a><h4>Reuse of Packets</h4>
<p><a name="scsi-ix504"></a>A target driver can reuse packets in the following ways:</p>
<ul><li><p>Resubmit the packet unchanged.</p></li>
<li><p><a name="scsi-ix505"></a>Use <a href="http://docs.sun.com/doc/819-2256/scsi-sync-pkt-9f?a=view"><tt>scsi_sync_pkt</tt>(9F)</a> to synchronize the data. Then, process the data in the driver. Finally, resubmit the packet.</p></li>
<li><p><a name="scsi-ix506"></a>Free DMA resources, using <a href="http://docs.sun.com/doc/819-2256/scsi-dmafree-9f?a=view"><tt>scsi_dmafree</tt>(9F)</a>, and pass the <tt>pkt</tt> pointer to <a href="http://docs.sun.com/doc/819-2256/scsi-init-pkt-9f?a=view"><tt>scsi_init_pkt</tt>(9F)</a> for binding to a new <tt>bp</tt>. The target driver is responsible for reinitializing the packet. The CDB has to have the same length as the previous CDB.</p></li>
<li><p>If only partial DMA is allocated during the first call to  <a href="http://docs.sun.com/doc/819-2256/scsi-init-pkt-9f?a=view"><tt>scsi_init_pkt</tt>(9F)</a>, subsequent calls to <a href="http://docs.sun.com/doc/819-2256/scsi-init-pkt-9f?a=view"><tt>scsi_init_pkt</tt>(9F)</a> can be made for the same packet. Calls can be made to <tt>bp</tt> as well to adjust the DMA resources to the next portion of the transfer.</p></li></ul>


<a name="scsi-21"></a><h4>Auto-Request Sense Mode</h4>
<p><a name="scsi-ix507"></a><a name="indexterm-596"></a>Auto-request sense mode is most desirable if queuing is used, whether the queuing
is tagged or untagged. A contingent allegiance condition is cleared by any subsequent
command and, consequently, the sense data is lost. Most HBA drivers start the
next command before performing the target driver callback. Other HBA drivers can use
a separate, lower-priority thread to perform the callbacks. This approach might increase the
time needed to notify the target driver that the packet completed with a
check condition. In this case, the target driver might not be able to
submit a request sense command in time to retrieve the sense data.</p><p>To avoid this loss of sense data, the HBA driver, or controller,
should issue a request sense command if a check condition has been detected.
This mode is known as auto-request sense mode. Note that not all HBA
drivers are capable of auto-request sense mode, and some drivers can only operate
with auto-request sense mode enabled.</p><p>A target driver enables auto-request-sense mode by using <a href="http://docs.sun.com/doc/819-2256/scsi-ifsetcap-9f?a=view"><tt>scsi_ifsetcap</tt>(9F)</a>. The following example shows
auto-request sense enabling.</p><a name="scsi-73381"></a><h6>Example&nbsp;17-6 Enabling Auto-Request Sense Mode</h6><pre>static int
xxattach(dev_info_t *dip, ddi_attach_cmd_t cmd)
{
    struct xxstate *xsp;
    struct scsi_device *sdp = (struct scsi_device *)
    ddi_get_driver_private(dip);
    /*
     * Enable auto-request-sense; an auto-request-sense cmd might
     * fail due to a BUSY condition or transport error. Therefore,
     * it is recommended to allocate a separate request sense
     * packet as well.
     * Note that scsi_ifsetcap(9F) can return -1, 0, or 1
     */
    xsp-&gt;sdp_arq_enabled =
    ((scsi_ifsetcap(ROUTE, &ldquo;auto-rqsense&rdquo;, 1, 1) == 1) ? 1 : 0);
    /*
     * If the HBA driver supports auto request sense then the
     * status blocks should be sizeof (struct scsi_arq_status);
     * else
     * One byte is sufficient
     */
    xsp-&gt;sdp_cmd_stat_size =  (xsp-&gt;sdp_arq_enabled ?
    sizeof (struct scsi_arq_status) : 1);
    /* ... */
}</pre><p>If a packet is allocated using <a href="http://docs.sun.com/doc/819-2256/scsi-init-pkt-9f?a=view"><tt>scsi_init_pkt</tt>(9F)</a> and auto-request sense is desired on
this packet, additional space is needed. The target driver must request this 
space for the status block to hold the auto-request sense structure. The sense
length used in the request sense command is <tt>sizeof</tt>, from <tt>struct</tt> <tt>scsi_extended_sense</tt>. Auto-request sense
can be disabled per individual packet by allocating <tt>sizeof</tt>, from <tt>struct</tt> <tt>scsi_status</tt>, for
the status block.</p><p>The packet is submitted using <a href="http://docs.sun.com/doc/819-2256/scsi-transport-9f?a=view"><tt>scsi_transport</tt>(9F)</a> as usual. When a check condition occurs
on this packet, the host adapter driver takes the following steps:</p>
<ul><li><p>Issues a request sense command if the controller does not have auto-request sense capability</p></li>
<li><p>Obtains the sense data</p></li>
<li><p>Fills in the <tt>scsi_arq_status</tt> information in the packet's status block</p></li>
<li><p>Sets <tt>STATE_ARQ_DONE</tt> in the packet's <tt>pkt_state</tt> field</p></li>
<li><p>Calls the packet's callback handler (<tt>pkt_comp()</tt>)</p></li></ul>
<p>The target driver's callback routine should verify that sense data is available by
checking the <tt>STATE_ARQ_DONE</tt> bit in <tt>pkt_state</tt>. <tt>STATE_ARQ_DONE</tt> implies that a check condition has
occurred and that a request sense has been performed. If auto-request sense has
been temporarily disabled in a packet, subsequent retrieval of the sense data cannot
be guaranteed.</p><p>The target driver should then verify whether the auto-request sense command completed successfully
and decode the sense data.</p>

<a name="scsi-1a"></a><h4>Dump Handling</h4>
<p>The <a href="http://docs.sun.com/doc/819-2255/dump-9e?a=view"><tt>dump</tt>(9E)</a> entry point copies a portion of virtual address space directly to
the specified device in the case of system failure or checkpoint operation. See
the <a href="http://docs.sun.com/doc/819-2254/cpr-7?a=view"><tt>cpr</tt>(7)</a> and <a href="http://docs.sun.com/doc/819-2255/dump-9e?a=view"><tt>dump</tt>(9E)</a> man pages. The <a href="http://docs.sun.com/doc/819-2255/dump-9e?a=view"><tt>dump</tt>(9E)</a> entry point must be
capable of performing this operation without the use of interrupts.</p><p>The arguments for <tt>dump()</tt> are as follows:</p><dl><dt><i>dev</i></dt>
<dd><p>Device number of the dump device</p></dd>
<dt><i>addr</i></dt>
<dd><p>Kernel virtual address at which to start the dump</p></dd>
<dt><i>blkno</i></dt>
<dd><p>First destination block on the device</p></dd>
<dt><i>nblk</i></dt>
<dd><p>Number of blocks to dump</p></dd>
</dl>
<a name="scsi-ex-3"></a><h6>Example&nbsp;17-7 <tt>dump</tt>(9E) Routine</h6><pre>static int
xxdump(dev_t dev, caddr_t addr, daddr_t blkno, int nblk)
{
    struct xxstate     *xsp;
    struct buf         *bp;
    struct scsi_pkt    *pkt;
    int    rval;
    int    instance;

    instance = getminor(dev);
    xsp = ddi_get_soft_state(statep, instance);

    if (tgt-&gt;suspended) {
        (void) pm_raise_power(DEVINFO(tgt), 0, 1);
    }

    bp = getrbuf(KM_NOSLEEP);
    if (bp == NULL) {
        return (EIO);
    }

/* Calculate block number relative to partition. */
    bp-&gt;b_un.b_addr = addr;
    bp-&gt;b_edev = dev;
    bp-&gt;b_bcount = nblk * DEV_BSIZE;
    bp-&gt;b_flags = B_WRITE | B_BUSY;
    bp-&gt;b_blkno = blkno;

    pkt = scsi_init_pkt(ROUTE(tgt), NULL, bp, CDB_GROUP1,
    sizeof (struct scsi_arq_status),
    sizeof (struct bst_pkt_private), 0, NULL_FUNC, NULL);
    if (pkt == NULL) {
        freerbuf(bp);
        return (EIO);
    }
    (void) scsi_setup_cdb((union scsi_cdb *)pkt-&gt;pkt_cdbp,
        SCMD_WRITE_G1, blkno, nblk, 0);
    /*
     * While dumping in polled mode, other cmds might complete
     * and these should not be resubmitted. we set the
     * dumping flag here which prevents requeueing cmds.
     */
    tgt-&gt;dumping = 1;
    rval = scsi_poll(pkt);
    tgt-&gt;dumping = 0;

    scsi_destroy_pkt(pkt);
    freerbuf(bp);

    if (rval != DDI_SUCCESS) {
        rval = EIO;
    }
    return (rval);
}</pre>
         </div>
      </td>
   </tr>

   <tr class="PageControls" valign="top">
      <td></td>
      <td>
         <table width="100%">
      	   <tr>
      	     <td>
                 <a href="scsi-12.html">Previous</a>
             </td>
             <td align="right">
                 <a href="scsi-100.html">Next</a>
             </td>
           </tr>
         </table>
      </td>
   </tr>
</tbody>
</table>


</body>
</html>

