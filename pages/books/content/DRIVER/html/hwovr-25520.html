<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="en-US">
<head>
<meta http-equiv="Content-type" content="text/html; charset=iso-8859-1">
<title>Bus Specifics - Writing Device Drivers</title>
<meta name="robots" content="index,follow">
<meta name="robots" content="index,follow">
<meta name="date" content="2008-08-01">
<meta name="collection" content="reference">
<link rel="stylesheet" type="text/css" href="css/elements.css">
<link rel="stylesheet" type="text/css" href="css/indiana.css">
</head>

<body>


<div class="Masthead">
   <div class="MastheadLogo">
      <a href="http://www.opensolaris.org"><img border="0" src="graphics/header.png"></img></a>
   </div>
   <div class="Title">Writing Device Drivers</div>
</div>

<table class="Layout" border="0" cellspacing="0" width="100%">
<tbody>

   <tr valign="top" class="PageControls">
      <td></td>
      <td>
         <table width="100%">
      	   <tr>
      	     <td>
                 <a href="hwovr-18.html">Previous</a>
             </td>
             <td align="right">
                 <a href="hwovr-100.html">Next</a>
             </td>
           </tr>
         </table>
      </td>
   </tr>
   
   <tr valign="top">
      <td class="Navigation" width="200px"><p class="toc level1"><a href="docinfo.html">Document Information</a></p>
<p class="toc level1 tocsp"><a href="preface-1.html">Preface</a></p>
<p class="toc level1 tocsp"><a href="eqbvu.html">Part&nbsp;I&nbsp;Designing Device Drivers for the Solaris Platform</a></p>
<p class="toc level2"><a href="eqbqn.html">1.&nbsp;&nbsp;Overview of Solaris Device Drivers</a></p>
<p class="toc level2"><a href="kernelovr-77198.html">2.&nbsp;&nbsp;Solaris Kernel and Device Tree</a></p>
<p class="toc level2"><a href="mt-17026.html">3.&nbsp;&nbsp;Multithreading</a></p>
<p class="toc level2"><a href="properties-1.html">4.&nbsp;&nbsp;Properties</a></p>
<p class="toc level2"><a href="events-1.html">5.&nbsp;&nbsp;Managing Events and Queueing Tasks</a></p>
<p class="toc level2"><a href="autoconf-17.html">6.&nbsp;&nbsp;Driver Autoconfiguration</a></p>
<p class="toc level2"><a href="devaccess-3.html">7.&nbsp;&nbsp;Device Access: Programmed I/O</a></p>
<p class="toc level2"><a href="interrupt-15678.html">8.&nbsp;&nbsp;Interrupt Handlers</a></p>
<p class="toc level2"><a href="dma-29901.html">9.&nbsp;&nbsp;Direct Memory Access (DMA)</a></p>
<p class="toc level2"><a href="devmap-24338.html">10.&nbsp;&nbsp;Mapping Device and Kernel Memory</a></p>
<p class="toc level2"><a href="devcnmgt-19679.html">11.&nbsp;&nbsp;Device Context Management</a></p>
<p class="toc level2"><a href="powermgt-37437.html">12.&nbsp;&nbsp;Power Management</a></p>
<p class="toc level2"><a href="gevsi.html">13.&nbsp;&nbsp;Hardening Solaris Drivers</a></p>
<p class="toc level2"><a href="ldi-1.html">14.&nbsp;&nbsp;Layered Driver Interface (LDI)</a></p>
<p class="toc level1 tocsp"><a href="eqbvb.html">Part&nbsp;II&nbsp;Designing Specific Kinds of Device Drivers</a></p>
<p class="toc level2"><a href="character-21002.html">15.&nbsp;&nbsp;Drivers for Character Devices</a></p>
<p class="toc level2"><a href="block-34861.html">16.&nbsp;&nbsp;Drivers for Block Devices</a></p>
<p class="toc level2"><a href="scsi-36812.html">17.&nbsp;&nbsp;SCSI Target Drivers</a></p>
<p class="toc level2"><a href="scsihba-32898.html">18.&nbsp;&nbsp;SCSI Host Bus Adapter Drivers</a></p>
<p class="toc level2"><a href="gld-1.html">19.&nbsp;&nbsp;Drivers for Network Devices</a></p>
<p class="toc level2"><a href="usb-1.html">20.&nbsp;&nbsp;USB Drivers</a></p>
<p class="toc level1 tocsp"><a href="eqbvo.html">Part&nbsp;III&nbsp;Building a Device Driver</a></p>
<p class="toc level2"><a href="loading-15035.html">21.&nbsp;&nbsp;Compiling, Loading, Packaging, and Testing Drivers</a></p>
<p class="toc level2"><a href="debug-60.html">22.&nbsp;&nbsp;Debugging, Testing, and Tuning Device Drivers</a></p>
<p class="toc level2"><a href="coding-practices.html">23.&nbsp;&nbsp;Recommended Coding Practices</a></p>
<p class="toc level1 tocsp"><a href="eqbva.html">Part&nbsp;IV&nbsp;Appendixes</a></p>
<p class="toc level2"><a href="hwovr-18191.html">A.&nbsp;&nbsp;Hardware Overview</a></p>
<p class="toc level3"><a href="hwovr-1.html">SPARC Processor Issues</a></p>
<p class="toc level3"><a href="hwovr-35423.html">x86 Processor Issues</a></p>
<p class="toc level3"><a href="hwovr-66.html">Endianness</a></p>
<p class="toc level3"><a href="hwovr-14.html">Store Buffers</a></p>
<p class="toc level3"><a href="hwovr-15.html">System Memory Model</a></p>
<p class="toc level3"><a href="hwovr-18.html">Bus Architectures</a></p>
<div class="onpage">
<p class="toc level3"><a href="">Bus Specifics</a></p>
</div>
<p class="toc level3"><a href="hwovr-100.html">Device Issues</a></p>
<p class="toc level3"><a href="hwovr-101.html">PROM on SPARC Machines</a></p>
<p class="toc level2 tocsp"><a href="ddidkisvc-29227.html">B.&nbsp;&nbsp;Summary of Solaris DDI/DKI Services</a></p>
<p class="toc level2"><a href="lp64-35004.html">C.&nbsp;&nbsp;Making a Device Driver 64-Bit Ready</a></p>
<p class="toc level2"><a href="euazz.html">D.&nbsp;&nbsp;Console Frame Buffer Drivers</a></p>
<p class="toc level1 tocsp"><a href="idx-1.html">Index</a></p>
</td>
      <td class="ContentPane" width="705px">

	 <div class="MainContent">      	 
             

<a name="hwovr-25520"></a><h3>Bus Specifics</h3>
<p>This section covers addressing and device configuration issues specific to the buses that
the Solaris platform supports.</p>

<a name="hwovr-22"></a><h4>PCI Local Bus</h4>
<p><a name="hwovr-ix47"></a><a name="hwovr-ix48"></a>The PCI local bus is a high-performance bus designed for high-speed data transfer.
The PCI bus resides on the system board. This bus is normally used
as an interconnect mechanism between highly integrated peripheral components, peripheral add-on boards, and
host processor or memory systems. The host processor, main memory, and the PCI
bus itself are connected through a PCI host bridge, as shown in <a href="#hwovr-fig-23">Figure&nbsp;A-3</a>.</p><p>A tree structure of interconnected I/O buses is supported through a series of
PCI bus bridges. Subordinate PCI bus bridges can be extended underneath the PCI
host bridge to enable a single bus system to be expanded into
a complex system with multiple secondary buses. PCI devices can be connected to
one or more of these secondary buses. In addition, other bus bridges, such
as SCSI or USB, can be connected.</p><p><a name="hwovr-ix49"></a>Every PCI device has a unique vendor ID and device ID. Multiple devices
of the same kind are further identified by their unique device numbers on
the bus where they reside.</p><a name="hwovr-fig-23"></a><h6>Figure&nbsp;A-3 <a name="hwovr-24466"></a>Machine Block Diagram</h6><img src="figures/hwovr.machinediagram.gif" alt="Diagram shows how a PCI host bridge connects the CPU and main memory to a PCI bus."></img><p>The PCI host bridge provides an interconnect between the processor and peripheral components.
Through the PCI host bridge, the processor can directly access main memory independent
of other PCI bus masters. For example, while the CPU is fetching data
from the cache controller in the host bridge, other PCI devices can also
access the system memory through the host bridge. The advantage of this architecture
is that this architecture separates the I/O bus from the processor's host bus.</p><p>The PCI host bridge also provides data access mappings between the CPU and
peripheral I/O devices. The bridge maps every peripheral device to the host address
domain so that the processor can access the device through programmed I/O. On
the local bus side, the PCI host bridge maps the system memory
to the PCI address domain so that the PCI device can access the
host memory as a bus master. <a href="#hwovr-fig-23">Figure&nbsp;A-3</a> shows the two address domains.</p>

<a name="hwovr-25"></a><h4>PCI Address Domain</h4>
<p>The PCI address domain consists of three distinct address spaces: configuration, memory, and
I/O space.</p>

<a name="hwovr-26"></a><h5>PCI Configuration Address Space</h5>
<p><a name="hwovr-ix50"></a>Configuration space is defined geographically. The location of a peripheral device is determined
by its physical location within an interconnected tree of PCI bus bridges. A
device is located by its <b>bus number</b> and <b>device</b> (<b>slot</b>) <b>number</b>. Each peripheral
device contains a set of well-defined configuration registers in its PCI configuration space.
The registers are used not only to identify devices but also to supply
device configuration information to the configuration framework. For example, base address registers in
the device configuration space must be mapped before a device can respond to
data access.</p><p>The method for generating configuration cycles is host dependent. In x86 machines, special
I/O ports are used. On other platforms, the PCI configuration space can be
memory-mapped to certain address locations corresponding to the PCI host bridge in the
host address domain. When a device configuration register is accessed by the processor,
the request is routed to the PCI host bridge. The bridge then translates
the access into proper configuration cycles on the bus.</p>

<a name="hwovr-28"></a><h5>PCI Configuration Base Address Registers</h5>
<p><a name="hwovr-ix51"></a>The PCI configuration space consists of up to six 32-bit base address registers
for each device. These registers provide both size and data type information. System
firmware assigns base addresses in the PCI address domain to these registers.</p><p>Each addressable region can be either memory or I/O space. The value contained
in bit 0 of the base address register identifies the type. A
value of 0 in bit 0 indicates a memory space and a value
of 1 indicates an I/O space. The following figure shows two base address
registers: one for memory and the other for I/O types.</p><a name="hwovr-fig-29"></a><h6>Figure&nbsp;A-4 <a name="hwovr-23659"></a>Base Address Registers for Memory and I/O</h6><img src="figures/hwovr.memiobaseaddr.gif" alt="Diagram shows how bit 0 in a base address indicates a memory or I/O space."></img>

<a name="hwovr-30746"></a><h5>PCI Memory Address Space</h5>
<p><a name="hwovr-ix52"></a>PCI supports both 32-bit and 64-bit addresses for memory space. System firmware assigns
regions of memory space in the PCI address domain to PCI peripherals. The
base address of a region is stored in the base address register of
the device's PCI configuration space. The size of each region must be a
power of two, and the assigned base address must be aligned on a
boundary equal to the size of the region. Device addresses in memory space
are <b>memory-mapped</b> into the host address domain so that data access to any
device can be performed by the processor's native load or store instructions.</p>

<a name="hwovr-30"></a><h5>PCI I/O Address Space</h5>
<p><a name="hwovr-ix53"></a>PCI supports 32-bit I/O space. I/O space can be accessed differently on different
platforms. Processors with special I/O instructions, like the Intel processor family, access the
I/O space with <tt>in</tt> and <tt>out</tt> instructions. Machines without special I/O instructions will
map to the address locations corresponding to the PCI host bridge in the
host address domain. When the processor accesses the memory-mapped addresses, an I/O request
will be sent to the PCI host bridge, which then translates the addresses
into I/O cycles and puts them on the PCI bus. Memory-mapped I/O is
performed by the native load/store instructions of the processor.</p>

<a name="hwovr-31"></a><h5>PCI Hardware Configuration Files</h5>
<p><a name="hwovr-ix54"></a><a name="hwovr-ix55"></a>Hardware configuration files should be unnecessary for PCI local bus devices. However, on
some occasions drivers for PCI devices need to use hardware configuration files to
augment the driver private information. See the <a href="http://docs.sun.com/doc/819-2251/driver.conf-4?a=view"><tt>driver.conf</tt>(4)</a> and <a href="http://docs.sun.com/doc/819-2251/pci-4?a=view"><tt>pci</tt>(4)</a> man pages for further
details.</p>

<a name="fxjuf"></a><h4>PCI Express</h4>
<p>The standard PCI bus has evolved into PCI Express. PCI Express is
the next generation high performance I/O bus for connecting peripheral devices in such applications
as desktop, mobile, workstation, server, embedded computing and communication platforms.</p><p>PCI Express improves bus performance, reduces overall system cost and takes advantage of
new developments in computer design. PCI Express uses a serial, point-to-point type interconnect
for communication between two devices. Using switches enables users to connect a large
number of devices together in a system. Serial interconnect implies fewer pins per
device package, which reduces cost and makes the performance highly scalable.</p><p>The PCI Express bus has built-in features to accommodate the following technologies:</p>
<ul><li><p>QoS (Quality of Service)</p></li>
<li><p>Hotplugging and hot swap</p></li>
<li><p>Advanced power management</p></li>
<li><p>RAS (Reliability, Available, Serviceable)</p></li>
<li><p>Improved error handling</p></li>
<li><p>MSI interrupts</p></li></ul>
<p>A PCI Express interconnect that connects two devices together is called a <b>link</b>.
A link can either be x1, x2, x4, x8, x12, x16 or x32
bidirectional signal pairs. These signals are called <b>lanes</b>. The bandwidth (x1) of each
lane is 500 MB/sec in duplex mode.  Although PCI-X and PCI Express
have different hardware connections, the two buses are identical from a driver writer's
point of view. PCI-X is a shared bus. For example, all the devices
on the bus share a single set of data lines and signal
lines. PCI-Express is a switched bus, which enables more efficient use of the
bandwidth between the devices and the system bus.</p><p>For more information on PCI Express, please refer to the following web site:
 <a href="http://www.pcisig.com/">http://www.pcisig.com/</a></p>

<a name="hwovr-32"></a><h4>SBus</h4>
<p><a name="hwovr-ix56"></a>Typical SBus systems consist of a motherboard (containing the CPU and SBus interface
logic), a number of SBus devices on the motherboard itself, and a number
of SBus expansion slots. An SBus can also be connected to other types
of buses through an appropriate bus bridge.</p><p><a name="hwovr-ix57"></a>The SBus is geographically addressed. Each SBus slot exists at a fixed physical
address in the system. An SBus card has a different address, depending on
which slot it is plugged into. Moving an SBus device to a new
slot causes the system to treat this device as a new device.</p><p>The SBus uses polling interrupts. When an SBus device interrupts, the system only
knows which of several devices might have issued the interrupt. The system interrupt
handler must ask the driver for each device whether that device is responsible
for the interrupt.</p>

<a name="hwovr-33"></a><h5>SBus Physical Address Space</h5>
<p><a name="hwovr-ix58"></a>The following table shows the physical address space layout of the Sun UltraSPARC
2 computer. A physical address on the UltraSPARC 2 model consists of 41
bits. The 41-bit physical address space is further broken down into multiple 33-bit
address spaces identified by <tt>PA(40:33)</tt>.</p><a name="hwovr-tbl-34"></a><h6>Table&nbsp;A-1 <a name="hwovr-34856"></a>Device Physical Space in the Ultra 2</h6><table><col width="22%"><col width="44%"><col width="33%"><tr><th align="left" valign="top" scope="column"><p>PA(40:33)</p></th>
<th align="left" valign="top" scope="column"><p>33-bit Space</p></th>
<th align="left" valign="top" scope="column"><p>Usage</p></th>
</tr>
<tr><td align="left" valign="top" scope="row"><p>0x0</p></td>
<td align="left" valign="top" scope="row"><p><tt>0x000000000 - 0x07FFFFFFF</tt></p></td>
<td align="left" valign="top" scope="row"><p>2 Gbytes main memory</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p>0x80 &ndash; 0xDF</p></td>
<td align="left" valign="top" scope="row"><p><tt>Reserved on Ultra 2</tt></p></td>
<td align="left" valign="top" scope="row"><p>Reserved on Ultra
2</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p>0xE0</p></td>
<td align="left" valign="top" scope="row"><p><tt>Processor 0</tt></p></td>
<td align="left" valign="top" scope="row"><p>Processor 0</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p>0xE1</p></td>
<td align="left" valign="top" scope="row"><p><tt>Processor 1</tt></p></td>
<td align="left" valign="top" scope="row"><p>Processor 1</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p>0xE2 &ndash; 0xFD</p></td>
<td align="left" valign="top" scope="row"><p><tt>Reserved on Ultra 2</tt></p></td>
<td align="left" valign="top" scope="row"><p>Reserved on Ultra 2</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p>0xFE</p></td>
<td align="left" valign="top" scope="row"><p><tt>0x000000000 - 0x1FFFFFFFF</tt></p></td>
<td align="left" valign="top" scope="row"><p>UPA Slave (FFB)</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p>0xFF</p></td>
<td align="left" valign="top" scope="row"><p><tt>0x000000000 - 0x0FFFFFFFF</tt></p></td>
<td align="left" valign="top" scope="row"><p>System I/O space</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p></p></td>
<td align="left" valign="top" scope="row"><p><tt>0x100000000 - 0x10FFFFFFF</tt></p></td>
<td align="left" valign="top" scope="row"><p>SBus
Slot 0</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p></p></td>
<td align="left" valign="top" scope="row"><p><tt>0x110000000 - 0x11FFFFFFF</tt></p></td>
<td align="left" valign="top" scope="row"><p>SBus Slot 1</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p></p></td>
<td align="left" valign="top" scope="row"><p><tt>0x120000000 - 0x12FFFFFFF</tt></p></td>
<td align="left" valign="top" scope="row"><p>SBus Slot 2</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p></p></td>
<td align="left" valign="top" scope="row"><p><tt>0x130000000 - 0x13FFFFFFF</tt></p></td>
<td align="left" valign="top" scope="row"><p>SBus Slot 3</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p></p></td>
<td align="left" valign="top" scope="row"><p><tt>0x1D0000000 - 0x1DFFFFFFF</tt></p></td>
<td align="left" valign="top" scope="row"><p>SBus Slot D</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p></p></td>
<td align="left" valign="top" scope="row"><p><tt>0x1E0000000 - 0x1EFFFFFFF</tt></p></td>
<td align="left" valign="top" scope="row"><p>SBus Slot E</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p></p></td>
<td align="left" valign="top" scope="row"><p><tt>0x1F0000000 - 0x1FFFFFFFF</tt></p></td>
<td align="left" valign="top" scope="row"><p>SBus
Slot F</p></td>
</tr>
</table>

<a name="hwovr-35"></a><h5>Physical SBus Addresses</h5>
<p><a name="hwovr-ix59"></a>The SBus has 32 address bits, as described in the <i>SBus Specification</i>. The following
table describes how the Ultra 2 uses the address bits.</p><a name="hwovr-37963"></a><h6>Table&nbsp;A-2 Ultra 2 SBus Address Bits</h6><table><col width="22%"><col width="77%"><tr><th align="left" valign="top" scope="column"><p>Bits</p></th>
<th align="left" valign="top" scope="column"><p>Description</p></th>
</tr>
<tr><td align="left" valign="top" scope="row"><p>0 - 27</p></td>
<td align="left" valign="top" scope="row"><p>These bits
are the SBus address lines used by an SBus card to address the
contents of the card.</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p>28 - 31</p></td>
<td align="left" valign="top" scope="row"><p>Used by the CPU to select one
of the SBus slots. These bits generate the SlaveSelect lines.</p></td>
</tr>
</table><p>This addressing scheme yields the Ultra 2 addresses shown in <a href="#hwovr-tbl-34">Table&nbsp;A-1</a>. Other
implementations might use a different number of address bits.</p><p>The Ultra 2 has seven SBus slots, four of which are physical.
Slots 0 through 3 are available for SBus cards. Slots 4-12 are reserved.
The slots are used as follows:</p>
<ul><li><p><a name="hwovr-ix60"></a><a name="hwovr-ix61"></a>Slots 0-3 are physical slots that have DMA-master capability.</p></li>
<li><p>Slots D, E, and F are not actual physical slots, but refer to the onboard direct memory access (DMA), SCSI, Ethernet, and audio controllers. For convenience, these classes of devices are viewed as being plugged into slots D, E, and F.</p>
<hr><p><b>Note - </b>Some SBus slots are slave-only slots. Drivers that require DMA capability should use <a href="http://docs.sun.com/doc/819-2256/ddi-slaveonly-9f?a=view"><tt>ddi_slaveonly</tt>(9F)</a> to determine whether their device is in a DMA-capable slot. For an example of this function, see <a href="autoconf-60641.html#autoconf-41111"><tt>attach()</tt> Entry Point</a>.</p>
<hr>
</li></ul>


<a name="hwovr-36"></a><h5>SBus Hardware Configuration Files</h5>
<p><a name="hwovr-ix62"></a><a name="hwovr-ix63"></a>Hardware configuration files are normally unnecessary for SBus devices. However, on some occasions,
drivers for SBus devices need to use hardware configuration files to augment the
information provided by the SBus card. See the <a href="http://docs.sun.com/doc/819-2251/driver.conf-4?a=view"><tt>driver.conf</tt>(4)</a> and <a href="http://docs.sun.com/doc/819-2251/sbus-4?a=view"><tt>sbus</tt>(4)</a> man page for
further details.</p>
         </div>
      </td>
   </tr>

   <tr class="PageControls" valign="top">
      <td></td>
      <td>
         <table width="100%">
      	   <tr>
      	     <td>
                 <a href="hwovr-18.html">Previous</a>
             </td>
             <td align="right">
                 <a href="hwovr-100.html">Next</a>
             </td>
           </tr>
         </table>
      </td>
   </tr>
</tbody>
</table>


</body>
</html>

