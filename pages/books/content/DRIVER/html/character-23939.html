<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="en-US">
<head>
<meta http-equiv="Content-type" content="text/html; charset=iso-8859-1">
<title>Miscellaneous I/O Control - Writing Device Drivers</title>
<meta name="robots" content="index,follow">
<meta name="robots" content="index,follow">
<meta name="date" content="2008-08-01">
<meta name="collection" content="reference">
<link rel="stylesheet" type="text/css" href="css/elements.css">
<link rel="stylesheet" type="text/css" href="css/indiana.css">
</head>

<body>


<div class="Masthead">
   <div class="MastheadLogo">
      <a href="http://www.opensolaris.org"><img border="0" src="graphics/header.png"></img></a>
   </div>
   <div class="Title">Writing Device Drivers</div>
</div>

<table class="Layout" border="0" cellspacing="0" width="100%">
<tbody>

   <tr valign="top" class="PageControls">
      <td></td>
      <td>
         <table width="100%">
      	   <tr>
      	     <td>
                 <a href="character-11313.html">Previous</a>
             </td>
             <td align="right">
                 <a href="character-17.html">Next</a>
             </td>
           </tr>
         </table>
      </td>
   </tr>
   
   <tr valign="top">
      <td class="Navigation" width="200px"><p class="toc level1"><a href="docinfo.html">Document Information</a></p>
<p class="toc level1 tocsp"><a href="preface-1.html">Preface</a></p>
<p class="toc level1 tocsp"><a href="eqbvu.html">Part&nbsp;I&nbsp;Designing Device Drivers for the Solaris Platform</a></p>
<p class="toc level2"><a href="eqbqn.html">1.&nbsp;&nbsp;Overview of Solaris Device Drivers</a></p>
<p class="toc level2"><a href="kernelovr-77198.html">2.&nbsp;&nbsp;Solaris Kernel and Device Tree</a></p>
<p class="toc level2"><a href="mt-17026.html">3.&nbsp;&nbsp;Multithreading</a></p>
<p class="toc level2"><a href="properties-1.html">4.&nbsp;&nbsp;Properties</a></p>
<p class="toc level2"><a href="events-1.html">5.&nbsp;&nbsp;Managing Events and Queueing Tasks</a></p>
<p class="toc level2"><a href="autoconf-17.html">6.&nbsp;&nbsp;Driver Autoconfiguration</a></p>
<p class="toc level2"><a href="devaccess-3.html">7.&nbsp;&nbsp;Device Access: Programmed I/O</a></p>
<p class="toc level2"><a href="interrupt-15678.html">8.&nbsp;&nbsp;Interrupt Handlers</a></p>
<p class="toc level2"><a href="dma-29901.html">9.&nbsp;&nbsp;Direct Memory Access (DMA)</a></p>
<p class="toc level2"><a href="devmap-24338.html">10.&nbsp;&nbsp;Mapping Device and Kernel Memory</a></p>
<p class="toc level2"><a href="devcnmgt-19679.html">11.&nbsp;&nbsp;Device Context Management</a></p>
<p class="toc level2"><a href="powermgt-37437.html">12.&nbsp;&nbsp;Power Management</a></p>
<p class="toc level2"><a href="gevsi.html">13.&nbsp;&nbsp;Hardening Solaris Drivers</a></p>
<p class="toc level2"><a href="ldi-1.html">14.&nbsp;&nbsp;Layered Driver Interface (LDI)</a></p>
<p class="toc level1 tocsp"><a href="eqbvb.html">Part&nbsp;II&nbsp;Designing Specific Kinds of Device Drivers</a></p>
<p class="toc level2"><a href="character-21002.html">15.&nbsp;&nbsp;Drivers for Character Devices</a></p>
<p class="toc level3"><a href="character-1.html">Overview of the Character Driver Structure</a></p>
<p class="toc level3"><a href="character-51.html">Character Device Autoconfiguration</a></p>
<p class="toc level3"><a href="character-6.html">Device Access (Character Drivers)</a></p>
<p class="toc level3"><a href="character-25379.html">I/O Request Handling</a></p>
<p class="toc level3"><a href="character-16543.html">Mapping Device Memory</a></p>
<p class="toc level3"><a href="character-11313.html">Multiplexing I/O on File Descriptors</a></p>
<div class="onpage">
<p class="toc level3"><a href="">Miscellaneous I/O Control</a></p>
</div>
<p class="toc level3"><a href="character-17.html">32-bit and 64-bit Data Structure Macros</a></p>
<p class="toc level2 tocsp"><a href="block-34861.html">16.&nbsp;&nbsp;Drivers for Block Devices</a></p>
<p class="toc level2"><a href="scsi-36812.html">17.&nbsp;&nbsp;SCSI Target Drivers</a></p>
<p class="toc level2"><a href="scsihba-32898.html">18.&nbsp;&nbsp;SCSI Host Bus Adapter Drivers</a></p>
<p class="toc level2"><a href="gld-1.html">19.&nbsp;&nbsp;Drivers for Network Devices</a></p>
<p class="toc level2"><a href="usb-1.html">20.&nbsp;&nbsp;USB Drivers</a></p>
<p class="toc level1 tocsp"><a href="eqbvo.html">Part&nbsp;III&nbsp;Building a Device Driver</a></p>
<p class="toc level2"><a href="loading-15035.html">21.&nbsp;&nbsp;Compiling, Loading, Packaging, and Testing Drivers</a></p>
<p class="toc level2"><a href="debug-60.html">22.&nbsp;&nbsp;Debugging, Testing, and Tuning Device Drivers</a></p>
<p class="toc level2"><a href="coding-practices.html">23.&nbsp;&nbsp;Recommended Coding Practices</a></p>
<p class="toc level1 tocsp"><a href="eqbva.html">Part&nbsp;IV&nbsp;Appendixes</a></p>
<p class="toc level2"><a href="hwovr-18191.html">A.&nbsp;&nbsp;Hardware Overview</a></p>
<p class="toc level2"><a href="ddidkisvc-29227.html">B.&nbsp;&nbsp;Summary of Solaris DDI/DKI Services</a></p>
<p class="toc level2"><a href="lp64-35004.html">C.&nbsp;&nbsp;Making a Device Driver 64-Bit Ready</a></p>
<p class="toc level2"><a href="euazz.html">D.&nbsp;&nbsp;Console Frame Buffer Drivers</a></p>
<p class="toc level1 tocsp"><a href="idx-1.html">Index</a></p>
</td>
      <td class="ContentPane" width="705px">

	 <div class="MainContent">      	 
             

<a name="character-23939"></a><h3>Miscellaneous I/O Control</h3>
<a name="character-ix412"></a><p><a name="character-ix413"></a><a name="character-ix414"></a>The <a href="http://docs.sun.com/doc/819-2255/ioctl-9e?a=view"><tt>ioctl</tt>(9E)</a> routine is called when a user thread issues an <a href="http://docs.sun.com/doc/819-2241/ioctl-2?a=view"><tt>ioctl</tt>(2)</a> system
call on a file descriptor associated with the device. The I/O control mechanism
is a catchall for getting and setting device-specific parameters. This mechanism is frequently
used to set a device-specific mode, either by setting internal driver software flags or
by writing commands to the device. The control mechanism can also be used
to return information to the user about the current device state. In short,
the control mechanism can do whatever the application and driver need to have
done.</p>

<a name="character-22"></a><h4><tt>ioctl()</tt> Entry Point (Character Drivers)</h4>
<a name="character-ix415"></a><pre>int xxioctl(dev_t <i>dev</i>, int <i>cmd</i>, intptr_t <i>arg</i>, int <i>mode</i>,
     cred_t *<i>credp</i>, int *<i>rvalp</i>);</pre><p>The <i>cmd</i> parameter indicates which command <a href="http://docs.sun.com/doc/819-2255/ioctl-9e?a=view"><tt>ioctl</tt>(9E)</a> should perform. By convention, the driver
with which an I/O control command is associated is indicated in bits 8-15
of the command. Typically, the  ASCII code of a character represents the
driver. The driver-specific command in bits 0-7. The creation of some I/O commands
is illustrated in the following example:</p><pre>#define XXIOC            (`x' &lt;&lt; 8)   /* `x' is a character that represents device xx */
#define XX_GET_STATUS    (XXIOC | 1)  /* get status register */
#define XX_SET_CMD       (XXIOC | 2)  /* send command */</pre><p>The interpretation of <i>arg</i> depends on the command. I/O control commands should be
documented in the driver documentation or a man page. The command should also
be defined in a public header file, so that applications can determine the
name of the command, what the command does, and what the command accepts
or returns as <i>arg</i>. Any data transfer of <i>arg</i> into or out of
the driver must be performed by the driver.</p><p>Certain classes of devices such as frame buffers or disks must support standard
sets of I/O control requests. These standard I/O control interfaces are documented in
the <i>Solaris 8 Reference Manual Collection</i>. For example, <a href="http://docs.sun.com/doc/819-2254/fbio-7i?a=view"><tt>fbio</tt>(7I)</a> documents the I/O controls that frame buffers must support,
and <a href="http://docs.sun.com/doc/819-2254/dkio-7i?a=view"><tt>dkio</tt>(7I)</a> documents standard disk I/O controls. See <a href="">Miscellaneous I/O Control</a> for more information on I/O
controls.</p><p>Drivers must use <a href="http://docs.sun.com/doc/819-2256/ddi-copyin-9f?a=view"><tt>ddi_copyin</tt>(9F)</a> to transfer <i>arg</i> data from the user-level application to
the kernel level. Drivers must use  <a href="http://docs.sun.com/doc/819-2256/ddi-copyout-9f?a=view"><tt>ddi_copyout</tt>(9F)</a> to transfer data from
the kernel to the user level.  Failure to use <a href="http://docs.sun.com/doc/819-2256/ddi-copyin-9f?a=view"><tt>ddi_copyin</tt>(9F)</a> or <a href="http://docs.sun.com/doc/819-2256/ddi-copyout-9f?a=view"><tt>ddi_copyout</tt>(9F)</a>
can result in panics under two conditions. A panic occurs if the architecture
separates the kernel and user address spaces, or if the user address has
been swapped out.</p><p><a href="http://docs.sun.com/doc/819-2255/ioctl-9e?a=view"><tt>ioctl</tt>(9E)</a> is usually a switch statement with a case for each supported 
<a href="http://docs.sun.com/doc/819-2255/ioctl-9e?a=view"><tt>ioctl</tt>(9E)</a> request.</p><a name="character-15130"></a><h6>Example&nbsp;15-12 <tt>ioctl</tt>(9E) Routine</h6><pre>static int
xxioctl(dev_t dev, int cmd, intptr_t arg, int mode,
    cred_t *credp, int *rvalp)
{
    uint8_t        csr;
    struct xxstate     *xsp;

    xsp = ddi_get_soft_state(statep, getminor(dev));
    if (xsp == NULL) {
        return (ENXIO);
    }
    switch (cmd) {
    case XX_GET_STATUS:
        csr = ddi_get8(xsp-&gt;data_access_handle, &amp;xsp-&gt;regp-&gt;csr);
        if (ddi_copyout(&amp;csr, (void *)arg, sizeof (uint8_t), mode) != 0) {
            return (EFAULT);
        }
        break;
    case XX_SET_CMD:
        if (ddi_copyin((void *)arg, &amp;csr, sizeof (uint8_t), mode) != 0) {
            return (EFAULT);
        }
        ddi_put8(xsp-&gt;data_access_handle, &amp;xsp-&gt;regp-&gt;csr, csr);
        break;
    default:
        /* generic "ioctl unknown" error */
        return (ENOTTY);
    }
    return (0);
}</pre><p>The <i>cmd</i> variable identifies a specific device control operation. A problem can occur
if <i>arg</i> contains a user virtual address. <a href="http://docs.sun.com/doc/819-2255/ioctl-9e?a=view"><tt>ioctl</tt>(9E)</a> must call <a href="http://docs.sun.com/doc/819-2256/ddi-copyin-9f?a=view"><tt>ddi_copyin</tt>(9F)</a> or <a href="http://docs.sun.com/doc/819-2256/ddi-copyout-9f?a=view"><tt>ddi_copyout</tt>(9F)</a> to
transfer data between the data structure in the application program pointed to by
<i>arg</i> and the driver. In <a href="#character-15130">Example&nbsp;15-12</a>, for the case of an <tt>XX_GET_STATUS</tt> request, the
contents of <i>xsp-&gt;regp-&gt;csr</i> are copied to the address in <i>arg</i>.  <a href="http://docs.sun.com/doc/819-2255/ioctl-9e?a=view"><tt>ioctl</tt>(9E)</a> can store
in <i>*rvalp</i> any integer value as the return value to the <a href="http://docs.sun.com/doc/819-2241/ioctl-2?a=view"><tt>ioctl</tt>(2)</a> system call
that makes a successful request. Negative return values, such as -1, should be
avoided. Many application programs assume that negative values indicate failure.</p><p>The following example demonstrates an application that uses the I/O controls discussed in
the previous paragraph.</p><a name="character-20506"></a><h6>Example&nbsp;15-13 Using <tt>ioctl</tt>(9E)</h6><pre>#include &lt;sys/types.h&gt;
#include "xxio.h"     /* contains device's ioctl cmds and args */
int
main(void)
{
     uint8_t    status;
     /* ... */
     /*
      * read the device status
      */
     if (ioctl(fd, XX_GET_STATUS, &amp;status) == -1) {
         /* error handling */
     }
     printf("device status %x\n", status);
     exit(0);
}</pre>

<a name="character-24565"></a><h4>I/O Control Support for 64-Bit Capable Device Drivers</h4>
<p><a name="character-ix416"></a><a name="indexterm-572"></a>The Solaris kernel runs in 64-bit mode on suitable hardware, supporting both 32-bit
applications and 64-bit applications. A 64-bit device driver is required to support I/O
control commands from programs of both sizes. The difference between a 32-bit program
and a 64-bit program is the C language type model. A 32-bit program
is ILP32, and a 64-bit program is LP64. See <a href="lp64-35004.html">Appendix&nbsp;C, Making a Device Driver 64-Bit Ready</a> for information on
C data type models.</p><p>If data that flows between programs and the kernel is not identical in
format, the driver must be able to handle the model mismatch. Handling a
model mismatch requires making appropriate adjustments to the data.</p><p>To determine whether a model mismatch exists, the  <a href="http://docs.sun.com/doc/819-2255/ioctl-9e?a=view"><tt>ioctl</tt>(9E)</a> mode parameter
passes the data model bits to the driver. As <a href="#character-38299">Example&nbsp;15-14</a> shows, the mode
parameter is then passed to <a href="http://docs.sun.com/doc/819-2256/ddi-model-convert-from-9f?a=view"><tt>ddi_model_convert_from</tt>(9F)</a> to determine whether any model conversion
is necessary. </p><p>A flag subfield of the mode argument is used to pass the
data model to the <a href="http://docs.sun.com/doc/819-2255/ioctl-9e?a=view"><tt>ioctl</tt>(9E)</a> routine. The flag is set to one of the
following:</p>
<ul><li><p><tt>DATAMODEL_ILP32</tt></p></li>
<li><p><tt>DATAMODEL_LP64</tt></p></li></ul>
<p><tt>FNATIVE</tt> is conditionally defined to match the data model of the kernel implementation.
The <tt>FMODELS</tt> mask should be used to extract the flag from the <i>mode</i>
argument. The driver can then examine the data model explicitly to determine how
to copy the application data structure.</p><p>The DDI function <a href="http://docs.sun.com/doc/819-2256/ddi-model-convert-from-9f?a=view"><tt>ddi_model_convert_from</tt>(9F)</a> is a convenience routine that can assist some drivers
with their <tt>ioctl()</tt> calls. The function takes the data type model of the
user application as an argument and returns one of the following values:</p>
<ul><li><p><tt>DDI_MODEL_ILP32</tt> &ndash; Convert from ILP32 application</p></li>
<li><p><tt>DDI_MODEL_NONE</tt> &ndash; No conversion needed</p></li></ul>
<p><tt>DDI_MODEL_NONE</tt> is returned if no data conversion is necessary, as occurs when the
application and driver have the same data model. <tt>DDI_MODEL_ILP32</tt> is returned to a
driver that is compiled to the LP64 model and that communicates with a
32-bit application.</p><p>In the following example, the driver copies a data structure that contains a
user address. The data structure changes size from ILP32 to LP64. Accordingly, the
64-bit driver uses a 32-bit version of the structure when communicating with a
32-bit application.</p><a name="character-38299"></a><h6>Example&nbsp;15-14 <tt>ioctl</tt>(9E) Routine to Support 32-bit Applications and 64-bit Applications</h6><pre>struct args32 {
    uint32_t    addr;    /* 32-bit address in LP64 */
    int     len;
}
struct args {
    caddr_t     addr;    /* 64-bit address in LP64 */
    int     len;
}

static int
xxioctl(dev_t dev, int cmd, intptr_t arg, int mode,
    cred_t *credp, int *rvalp)
{
    struct  xxstate  *xsp;
    struct  args     a;
    xsp = ddi_get_soft_state(statep, getminor(dev));
    if (xsp == NULL) {
        return (ENXIO);
    }
    switch (cmd) {
    case XX_COPYIN_DATA:
        switch(ddi_model_convert_from(mode)) {
        case DDI_MODEL_ILP32:
        {
            struct args32 a32;

            /* copy 32-bit args data shape */
            if (ddi_copyin((void *)arg, &amp;a32,
                sizeof (struct args32), mode) != 0) {
                return (EFAULT);
            }
            /* convert 32-bit to 64-bit args data shape */
            a.addr = a32.addr;
            a.len = a32.len;
            break;
        }
        case DDI_MODEL_NONE:
            /* application and driver have same data model. */
            if (ddi_copyin((void *)arg, &amp;a, sizeof (struct args),
                mode) != 0) {
                return (EFAULT);
            }
        }
        /* continue using data shape in native driver data model. */
        break;

    case XX_COPYOUT_DATA:
        /* copyout handling */
        break;
    default:
        /* generic "ioctl unknown" error */
        return (ENOTTY);
    }
    return (0);
}</pre>

<a name="character-5"></a><h4>Handling <tt>copyout()</tt> Overflow</h4>
<p>Sometimes a driver needs to copy out a native quantity that no
longer fits in the 32-bit sized structure. In this case, the driver should
return <tt>EOVERFLOW</tt> to the caller. <tt>EOVERFLOW</tt> serves as an indication that the data
type in the interface is too small to hold the value to be
returned, as shown in the following example.</p><a name="character-ex-6"></a><h6>Example&nbsp;15-15 Handling <tt>copyout</tt>(9F) Overflow</h6><pre>int
    xxioctl(dev_t dev, int cmd, intptr_t arg, int mode,
     cred_t *cr, int *rval_p)
    {
        struct resdata res;
        /* body of driver */
        switch (ddi_model_convert_from(mode &amp; FMODELS)) {
        case DDI_MODEL_ILP32: {
            struct resdata32 res32;

            if (res.size &gt; UINT_MAX)
                    return (EOVERFLOW);
            res32.size = (size32_t)res.size;
            res32.flag = res.flag;
            if (ddi_copyout(&amp;res32,
                (void *)arg, sizeof (res32), mode))
                    return (EFAULT);
        }
        break;

        case DDI_MODEL_NONE:
            if (ddi_copyout(&amp;res, (void *)arg, sizeof (res), mode))
                    return (EFAULT);
            break;
        }
        return (0);
    }</pre>
         </div>
      </td>
   </tr>

   <tr class="PageControls" valign="top">
      <td></td>
      <td>
         <table width="100%">
      	   <tr>
      	     <td>
                 <a href="character-11313.html">Previous</a>
             </td>
             <td align="right">
                 <a href="character-17.html">Next</a>
             </td>
           </tr>
         </table>
      </td>
   </tr>
</tbody>
</table>


</body>
</html>

