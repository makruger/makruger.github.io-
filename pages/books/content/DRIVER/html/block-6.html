<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="en-US">
<head>
<meta http-equiv="Content-type" content="text/html; charset=iso-8859-1">
<title>Controlling Device Access - Writing Device Drivers</title>
<meta name="robots" content="index,follow">
<meta name="robots" content="index,follow">
<meta name="date" content="2008-08-01">
<meta name="collection" content="reference">
<link rel="stylesheet" type="text/css" href="css/elements.css">
<link rel="stylesheet" type="text/css" href="css/indiana.css">
</head>

<body>


<div class="Masthead">
   <div class="MastheadLogo">
      <a href="http://www.opensolaris.org"><img border="0" src="graphics/header.png"></img></a>
   </div>
   <div class="Title">Writing Device Drivers</div>
</div>

<table class="Layout" border="0" cellspacing="0" width="100%">
<tbody>

   <tr valign="top" class="PageControls">
      <td></td>
      <td>
         <table width="100%">
      	   <tr>
      	     <td>
                 <a href="block-5.html">Previous</a>
             </td>
             <td align="right">
                 <a href="block-78892.html">Next</a>
             </td>
           </tr>
         </table>
      </td>
   </tr>
   
   <tr valign="top">
      <td class="Navigation" width="200px"><p class="toc level1"><a href="docinfo.html">Document Information</a></p>
<p class="toc level1 tocsp"><a href="preface-1.html">Preface</a></p>
<p class="toc level1 tocsp"><a href="eqbvu.html">Part&nbsp;I&nbsp;Designing Device Drivers for the Solaris Platform</a></p>
<p class="toc level2"><a href="eqbqn.html">1.&nbsp;&nbsp;Overview of Solaris Device Drivers</a></p>
<p class="toc level2"><a href="kernelovr-77198.html">2.&nbsp;&nbsp;Solaris Kernel and Device Tree</a></p>
<p class="toc level2"><a href="mt-17026.html">3.&nbsp;&nbsp;Multithreading</a></p>
<p class="toc level2"><a href="properties-1.html">4.&nbsp;&nbsp;Properties</a></p>
<p class="toc level2"><a href="events-1.html">5.&nbsp;&nbsp;Managing Events and Queueing Tasks</a></p>
<p class="toc level2"><a href="autoconf-17.html">6.&nbsp;&nbsp;Driver Autoconfiguration</a></p>
<p class="toc level2"><a href="devaccess-3.html">7.&nbsp;&nbsp;Device Access: Programmed I/O</a></p>
<p class="toc level2"><a href="interrupt-15678.html">8.&nbsp;&nbsp;Interrupt Handlers</a></p>
<p class="toc level2"><a href="dma-29901.html">9.&nbsp;&nbsp;Direct Memory Access (DMA)</a></p>
<p class="toc level2"><a href="devmap-24338.html">10.&nbsp;&nbsp;Mapping Device and Kernel Memory</a></p>
<p class="toc level2"><a href="devcnmgt-19679.html">11.&nbsp;&nbsp;Device Context Management</a></p>
<p class="toc level2"><a href="powermgt-37437.html">12.&nbsp;&nbsp;Power Management</a></p>
<p class="toc level2"><a href="gevsi.html">13.&nbsp;&nbsp;Hardening Solaris Drivers</a></p>
<p class="toc level2"><a href="ldi-1.html">14.&nbsp;&nbsp;Layered Driver Interface (LDI)</a></p>
<p class="toc level1 tocsp"><a href="eqbvb.html">Part&nbsp;II&nbsp;Designing Specific Kinds of Device Drivers</a></p>
<p class="toc level2"><a href="character-21002.html">15.&nbsp;&nbsp;Drivers for Character Devices</a></p>
<p class="toc level2"><a href="block-34861.html">16.&nbsp;&nbsp;Drivers for Block Devices</a></p>
<p class="toc level3"><a href="block-1.html">Block Driver Structure Overview</a></p>
<p class="toc level3"><a href="block-82249.html">File I/O</a></p>
<p class="toc level3"><a href="block-5.html">Block Device Autoconfiguration</a></p>
<div class="onpage">
<p class="toc level3"><a href="">Controlling Device Access</a></p>
</div>
<p class="toc level3"><a href="block-78892.html">Synchronous Data Transfers (Block Drivers)</a></p>
<p class="toc level3"><a href="block-54698.html">Asynchronous Data Transfers (Block Drivers)</a></p>
<p class="toc level3"><a href="block-25.html"><tt>dump()</tt> and <tt>print()</tt> Entry Points</a></p>
<p class="toc level3"><a href="advanced-7.html">Disk Device Drivers</a></p>
<p class="toc level2 tocsp"><a href="scsi-36812.html">17.&nbsp;&nbsp;SCSI Target Drivers</a></p>
<p class="toc level2"><a href="scsihba-32898.html">18.&nbsp;&nbsp;SCSI Host Bus Adapter Drivers</a></p>
<p class="toc level2"><a href="gld-1.html">19.&nbsp;&nbsp;Drivers for Network Devices</a></p>
<p class="toc level2"><a href="usb-1.html">20.&nbsp;&nbsp;USB Drivers</a></p>
<p class="toc level1 tocsp"><a href="eqbvo.html">Part&nbsp;III&nbsp;Building a Device Driver</a></p>
<p class="toc level2"><a href="loading-15035.html">21.&nbsp;&nbsp;Compiling, Loading, Packaging, and Testing Drivers</a></p>
<p class="toc level2"><a href="debug-60.html">22.&nbsp;&nbsp;Debugging, Testing, and Tuning Device Drivers</a></p>
<p class="toc level2"><a href="coding-practices.html">23.&nbsp;&nbsp;Recommended Coding Practices</a></p>
<p class="toc level1 tocsp"><a href="eqbva.html">Part&nbsp;IV&nbsp;Appendixes</a></p>
<p class="toc level2"><a href="hwovr-18191.html">A.&nbsp;&nbsp;Hardware Overview</a></p>
<p class="toc level2"><a href="ddidkisvc-29227.html">B.&nbsp;&nbsp;Summary of Solaris DDI/DKI Services</a></p>
<p class="toc level2"><a href="lp64-35004.html">C.&nbsp;&nbsp;Making a Device Driver 64-Bit Ready</a></p>
<p class="toc level2"><a href="euazz.html">D.&nbsp;&nbsp;Console Frame Buffer Drivers</a></p>
<p class="toc level1 tocsp"><a href="idx-1.html">Index</a></p>
</td>
      <td class="ContentPane" width="705px">

	 <div class="MainContent">      	 
             

<a name="block-6"></a><h3>Controlling Device Access</h3>
<p>This section describes the entry points for <tt>open()</tt> and <tt>close()</tt> functions in
block device drivers. See <a href="character-21002.html">Chapter&nbsp;15, Drivers for Character Devices</a> for more information on <a href="http://docs.sun.com/doc/819-2255/open-9e?a=view"><tt>open</tt>(9E)</a> and <a href="http://docs.sun.com/doc/819-2255/close-9e?a=view"><tt>close</tt>(9E)</a>.</p>

<a name="block-7"></a><h4><tt>open()</tt> Entry Point (Block Drivers)</h4>
<p><a name="block-ix426"></a><a name="block-ix427"></a><a name="block-ix428"></a><a name="block-ix429"></a>The <a href="http://docs.sun.com/doc/819-2255/open-9e?a=view"><tt>open</tt>(9E)</a> entry point is used to gain access to a given device.
The <a href="http://docs.sun.com/doc/819-2255/open-9e?a=view"><tt>open</tt>(9E)</a> routine of a block driver is called when a user thread
issues an <a href="http://docs.sun.com/doc/819-2241/open-2?a=view"><tt>open</tt>(2)</a> or <a href="http://docs.sun.com/doc/819-2241/mount-2?a=view"><tt>mount</tt>(2)</a> system call on a block special file associated
with the minor device, or when a layered driver calls  <a href="http://docs.sun.com/doc/819-2255/open-9e?a=view"><tt>open</tt>(9E)</a>.
See <a href="block-82249.html">File I/O</a> for more information.</p><p>The <tt>open()</tt> entry point should check for the following conditions:</p>
<ul><li><p>The device can be opened, that is, the device is online and ready.</p></li>
<li><p>The device can be opened as requested. The device supports the operation. The device's current state does not conflict with the request.</p></li>
<li><p>The caller has permission to open the device.</p></li></ul>
<p>The following example demonstrates a block driver <a href="http://docs.sun.com/doc/819-2255/open-9e?a=view"><tt>open</tt>(9E)</a> entry point.</p><a name="block-40232"></a><h6>Example&nbsp;16-2 Block Driver <tt>open</tt>(9E) Routine</h6><pre>static int
xxopen(dev_t *devp, int flags, int otyp, cred_t *credp)
{
    minor_t         instance;
    struct xxstate        *xsp;

    instance = getminor(*devp);
    xsp = ddi_get_soft_state(statep, instance);
    if (xsp == NULL)
        return (ENXIO);
    mutex_enter(&amp;xsp-&gt;mu);
    /*
     * only honor FEXCL. If a regular open or a layered open
     * is still outstanding on the device, the exclusive open
     * must fail.
     */
    if ((flags &amp; FEXCL) &amp;&amp; (xsp-&gt;open || xsp-&gt;nlayered)) {
        mutex_exit(&amp;xsp-&gt;mu);
        return (EAGAIN);
    }
    switch (otyp) {
      case OTYP_LYR:
          xsp-&gt;nlayered++;
          break;
      case OTYP_BLK:
          xsp-&gt;open = 1;
          break;
      default:
          mutex_exit(&amp;xsp-&gt;mu);
          return (EINVAL);
    }
    mutex_exit(&amp;xsp-&gt;mu);
    return (0);
}</pre><p>The <tt>otyp</tt> argument is used to specify the type of open on the
device. <tt>OTYP_BLK</tt> is the typical open type for a block device. A device
can be opened several times with <tt>otyp</tt> set to <tt>OTYP_BLK</tt>.  <a href="http://docs.sun.com/doc/819-2255/close-9e?a=view"><tt>close</tt>(9E)</a> is
called only once when the final close of type <tt>OTYP_BLK</tt> has occurred for
the device. <tt>otyp</tt> is set to <tt>OTYP_LYR</tt> if the device is being used
as a layered device. For every open of type <tt>OTYP_LYR</tt>, the layering driver
issues a corresponding close of type <tt>OTYP_LYR</tt>. The example keeps track of each
type of open so the driver can determine when the device is not
being used in <a href="http://docs.sun.com/doc/819-2255/close-9e?a=view"><tt>close</tt>(9E)</a>.</p>

<a name="block-8"></a><h4><tt>close()</tt> Entry Point (Block Drivers)</h4>
<p><a name="block-ix430"></a><a name="block-ix431"></a>The <a href="http://docs.sun.com/doc/819-2255/close-9e?a=view"><tt>close</tt>(9E)</a> entry point uses the same arguments as  <a href="http://docs.sun.com/doc/819-2255/open-9e?a=view"><tt>open</tt>(9E)</a> with one exception.
<tt>dev</tt> is the device number rather than a pointer to the device number.</p><p>The <tt>close()</tt> routine should verify <tt>otyp</tt> in the same way as was described
for the <a href="http://docs.sun.com/doc/819-2255/open-9e?a=view"><tt>open</tt>(9E)</a> entry point. In the following example, <tt>close()</tt> must determine
when the device can really be closed. Closing is affected by the number
of block opens and layered opens.</p><a name="block-15508"></a><h6>Example&nbsp;16-3 Block Device <tt>close</tt>(9E) Routine</h6><pre>static int
xxclose(dev_t dev, int flag, int otyp, cred_t *credp)
{
    minor_t instance;
    struct xxstate *xsp;

    instance = getminor(dev);
    xsp = ddi_get_soft_state(statep, instance);
    if (xsp == NULL)
        return (ENXIO);
    mutex_enter(&amp;xsp-&gt;mu);
    switch (otyp) {
      case OTYP_LYR:
          xsp-&gt;nlayered--;
          break;
      case OTYP_BLK:
          xsp-&gt;open = 0;
          break;
      default:
          mutex_exit(&amp;xsp-&gt;mu);
         return (EINVAL);
    }

    if (xsp-&gt;open || xsp-&gt;nlayered) {
        /* not done yet */
        mutex_exit(&amp;xsp-&gt;mu);
        return (0);
    }
    /* cleanup (rewind tape, free memory, etc.) */
    /* wait for I/O to drain */
    mutex_exit(&amp;xsp-&gt;mu);

    return (0);
}</pre>

<a name="block-20"></a><h4><tt>strategy()</tt> Entry Point</h4>
<p><a name="indexterm-583"></a>The <a href="http://docs.sun.com/doc/819-2255/strategy-9e?a=view"><tt>strategy</tt>(9E)</a> entry point is used to read and write data buffers to
and from a block device. The name <b>strategy</b> refers to the fact
that this entry point might implement some optimal strategy for ordering requests to
the device.</p><p><a name="indexterm-584"></a><a href="http://docs.sun.com/doc/819-2255/strategy-9e?a=view"><tt>strategy</tt>(9E)</a> can be written to process one request at a time, that is,
a synchronous transfer. <tt>strategy()</tt> can also be written to queue multiple requests
to the device, as in an asynchronous transfer. When choosing a method, the
abilities and limitations of the device should be taken into account.</p><p>The <a href="http://docs.sun.com/doc/819-2255/strategy-9e?a=view"><tt>strategy</tt>(9E)</a> routine is passed a pointer to a <a href="http://docs.sun.com/doc/819-2257/buf-9s?a=view"><tt>buf</tt>(9S)</a> structure. This structure describes
the transfer request, and contains status information on return. <a href="http://docs.sun.com/doc/819-2257/buf-9s?a=view"><tt>buf</tt>(9S)</a> and <a href="http://docs.sun.com/doc/819-2255/strategy-9e?a=view"><tt>strategy</tt>(9E)</a> are
the focus of block device operations.</p>

<a name="block-3"></a><h4><tt>buf</tt> Structure</h4>
<p><a name="indexterm-585"></a><a name="indexterm-586"></a>The following <tt>buf</tt> structure members are important to block drivers:</p><pre>int           b_flags;       /* Buffer Status */
struct buf    *av_forw;      /* Driver work list link */
struct buf    *av_back;      /* Driver work list link */
size_t        b_bcount;      /* # of bytes to transfer */
union {
    caddr_t   b_addr;        /* Buffer's virtual address */
} b_un;
daddr_t       b_blkno;       /* Block number on device */
diskaddr_t    b_lblkno;      /* Expanded block number on device */
size_t        b_resid;       /* # of bytes not transferred after error */
int           b_error;       /* Expanded error field */
void          *b_private;    /* &ldquo;opaque&rdquo; driver private area */
dev_t         b_edev;        /* expanded dev field */</pre><p>where:</p><dl><dt><tt>av_forw</tt> and <tt>av_back</tt></dt>
<dd><p>Pointers that the driver can use to manage a list of buffers by the driver. See <a href="block-54698.html">Asynchronous Data Transfers (Block Drivers)</a> for a discussion of the <tt>av_forw</tt> and <tt>av_back</tt> pointers.</p></dd>
<dt><tt>b_bcount</tt></dt>
<dd><p>Specifies the number of bytes to be transferred by the device.</p></dd>
<dt><tt>b_un.b_addr</tt></dt>
<dd><p>The kernel virtual address of the data buffer. Only valid after <a href="http://docs.sun.com/doc/819-2256/bp-mapin-9f?a=view"><tt>bp_mapin</tt>(9F)</a> call.</p></dd>
<dt><tt>b_blkno</tt></dt>
<dd><p>The starting 32-bit logical block number on the device for the data transfer, which is expressed in 512-byte <tt>DEV_BSIZE</tt> units. The driver should use either <tt>b_blkno</tt> or <tt>b_lblkno</tt> but not both.</p></dd>
<dt><tt>b_lblkno</tt></dt>
<dd><p>The starting 64-bit logical block number on the device for the data transfer, which is expressed in 512-byte <tt>DEV_BSIZE</tt> units. The driver should use either <tt>b_blkno</tt> or <tt>b_lblkno</tt> but not both.</p></dd>
<dt><tt>b_resid</tt></dt>
<dd><p>Set by the driver to indicate the number of bytes that were not transferred because of an error. See <a href="block-54698.html#block-33565">Example&nbsp;16-7</a> for an example of setting <tt>b_resid</tt>. The <tt>b_resid</tt> member is overloaded. <tt>b_resid</tt> is also used by <a href="http://docs.sun.com/doc/819-2256/disksort-9f?a=view"><tt>disksort</tt>(9F)</a>.</p></dd>
<dt><tt>b_error</tt></dt>
<dd><p>Set to an error number by the driver when a transfer error occurs. <tt>b_error</tt> is set in conjunction with the <tt>b_flags</tt> <tt>B_ERROR</tt> bit. See the <a href="http://docs.sun.com/doc/819-2255/intro-9e?a=view"><tt>Intro</tt>(9E)</a> man page for details about error values. Drivers should use <a href="http://docs.sun.com/doc/819-2256/bioerror-9f?a=view"><tt>bioerror</tt>(9F)</a> rather than setting <tt>b_error</tt> directly.</p></dd>
<dt><tt>b_flags</tt></dt>
<dd><p>Flags with status and transfer attributes of the <tt>buf</tt> structure. If <tt>B_READ</tt> is set, the <tt>buf</tt> structure indicates a transfer from the device to memory. Otherwise, this structure indicates a transfer from memory to the device. If the driver encounters an error during data transfer, the driver should set the <tt>B_ERROR</tt> field in the <tt>b_flags</tt> member. In addition, the driver should provide a more specific error value in <tt>b_error</tt>. Drivers should use <a href="http://docs.sun.com/doc/819-2256/bioerror-9f?a=view"><tt>bioerror</tt>(9F)</a> rather than setting <tt>B_ERROR</tt>.</p>
<hr><p><b>Caution - </b>Drivers should never clear <tt>b_flags</tt>.</p>
<hr>
</dd>
<dt><tt>b_private</tt></dt>
<dd><p>For exclusive use by the driver to store driver-private data.</p></dd>
<dt><tt>b_edev</tt></dt>
<dd><p>Contains the device number of the device that was used in the transfer.</p></dd>
</dl>


<a name="block-4"></a><h5><tt>bp_mapin</tt> Structure</h5>
<p>A <tt>buf</tt> structure pointer can be passed into the device driver's <a href="http://docs.sun.com/doc/819-2255/strategy-9e?a=view"><tt>strategy</tt>(9E)</a> routine. However,
the data buffer referred to by <tt>b_un.b_addr</tt> is not necessarily mapped in the
kernel's address space. Therefore, the driver cannot directly access the data. Most block-oriented
devices have DMA capability and therefore do not need to access the data
buffer directly. Instead, these devices use the DMA mapping routines to enable the
device's DMA engine to do the data transfer. For details about using DMA,
see <a href="dma-29901.html">Chapter&nbsp;9, Direct Memory Access (DMA)</a>.</p><p>If a driver needs to access the data buffer directly, that driver
must first map the buffer into the kernel's address space by using <a href="http://docs.sun.com/doc/819-2256/bp-mapin-9f?a=view"><tt>bp_mapin</tt>(9F)</a>.
 <a href="http://docs.sun.com/doc/819-2256/bp-mapout-9f?a=view"><tt>bp_mapout</tt>(9F)</a> should be used when the driver no longer needs to access
the data directly.</p>
<hr><p><b>Caution - </b><a href="http://docs.sun.com/doc/819-2256/bp-mapout-9f?a=view"><tt>bp_mapout</tt>(9F)</a> should only be called on buffers that have  been  allocated
and are owned by the device driver. <tt>bp_mapout()</tt> must not be called on
buffers that are passed to the driver through the <a href="http://docs.sun.com/doc/819-2255/strategy-9e?a=view"><tt>strategy</tt>(9E)</a> entry point, such
as a file system. <a href="http://docs.sun.com/doc/819-2256/bp-mapin-9f?a=view"><tt>bp_mapin</tt>(9F)</a> does not keep a reference count. <a href="http://docs.sun.com/doc/819-2256/bp-mapout-9f?a=view"><tt>bp_mapout</tt>(9F)</a> removes any
kernel  mapping  on which  a layer over the device driver
might rely.</p>
<hr>

         </div>
      </td>
   </tr>

   <tr class="PageControls" valign="top">
      <td></td>
      <td>
         <table width="100%">
      	   <tr>
      	     <td>
                 <a href="block-5.html">Previous</a>
             </td>
             <td align="right">
                 <a href="block-78892.html">Next</a>
             </td>
           </tr>
         </table>
      </td>
   </tr>
</tbody>
</table>


</body>
</html>

