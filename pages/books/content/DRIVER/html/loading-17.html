<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="en-US">
<head>
<meta http-equiv="Content-type" content="text/html; charset=iso-8859-1">
<title>Criteria for Testing Drivers - Writing Device Drivers</title>
<meta name="robots" content="index,follow">
<meta name="robots" content="index,follow">
<meta name="date" content="2008-08-01">
<meta name="collection" content="reference">
<link rel="stylesheet" type="text/css" href="css/elements.css">
<link rel="stylesheet" type="text/css" href="css/indiana.css">
</head>

<body>


<div class="Masthead">
   <div class="MastheadLogo">
      <a href="http://www.opensolaris.org"><img border="0" src="graphics/header.png"></img></a>
   </div>
   <div class="Title">Writing Device Drivers</div>
</div>

<table class="Layout" border="0" cellspacing="0" width="100%">
<tbody>

   <tr valign="top" class="PageControls">
      <td></td>
      <td>
         <table width="100%">
      	   <tr>
      	     <td>
                 <a href="loading-32.html">Previous</a>
             </td>
             <td align="right">
                 <a href="debug-60.html">Next</a>
             </td>
           </tr>
         </table>
      </td>
   </tr>
   
   <tr valign="top">
      <td class="Navigation" width="200px"><p class="toc level1"><a href="docinfo.html">Document Information</a></p>
<p class="toc level1 tocsp"><a href="preface-1.html">Preface</a></p>
<p class="toc level1 tocsp"><a href="eqbvu.html">Part&nbsp;I&nbsp;Designing Device Drivers for the Solaris Platform</a></p>
<p class="toc level2"><a href="eqbqn.html">1.&nbsp;&nbsp;Overview of Solaris Device Drivers</a></p>
<p class="toc level2"><a href="kernelovr-77198.html">2.&nbsp;&nbsp;Solaris Kernel and Device Tree</a></p>
<p class="toc level2"><a href="mt-17026.html">3.&nbsp;&nbsp;Multithreading</a></p>
<p class="toc level2"><a href="properties-1.html">4.&nbsp;&nbsp;Properties</a></p>
<p class="toc level2"><a href="events-1.html">5.&nbsp;&nbsp;Managing Events and Queueing Tasks</a></p>
<p class="toc level2"><a href="autoconf-17.html">6.&nbsp;&nbsp;Driver Autoconfiguration</a></p>
<p class="toc level2"><a href="devaccess-3.html">7.&nbsp;&nbsp;Device Access: Programmed I/O</a></p>
<p class="toc level2"><a href="interrupt-15678.html">8.&nbsp;&nbsp;Interrupt Handlers</a></p>
<p class="toc level2"><a href="dma-29901.html">9.&nbsp;&nbsp;Direct Memory Access (DMA)</a></p>
<p class="toc level2"><a href="devmap-24338.html">10.&nbsp;&nbsp;Mapping Device and Kernel Memory</a></p>
<p class="toc level2"><a href="devcnmgt-19679.html">11.&nbsp;&nbsp;Device Context Management</a></p>
<p class="toc level2"><a href="powermgt-37437.html">12.&nbsp;&nbsp;Power Management</a></p>
<p class="toc level2"><a href="gevsi.html">13.&nbsp;&nbsp;Hardening Solaris Drivers</a></p>
<p class="toc level2"><a href="ldi-1.html">14.&nbsp;&nbsp;Layered Driver Interface (LDI)</a></p>
<p class="toc level1 tocsp"><a href="eqbvb.html">Part&nbsp;II&nbsp;Designing Specific Kinds of Device Drivers</a></p>
<p class="toc level2"><a href="character-21002.html">15.&nbsp;&nbsp;Drivers for Character Devices</a></p>
<p class="toc level2"><a href="block-34861.html">16.&nbsp;&nbsp;Drivers for Block Devices</a></p>
<p class="toc level2"><a href="scsi-36812.html">17.&nbsp;&nbsp;SCSI Target Drivers</a></p>
<p class="toc level2"><a href="scsihba-32898.html">18.&nbsp;&nbsp;SCSI Host Bus Adapter Drivers</a></p>
<p class="toc level2"><a href="gld-1.html">19.&nbsp;&nbsp;Drivers for Network Devices</a></p>
<p class="toc level2"><a href="usb-1.html">20.&nbsp;&nbsp;USB Drivers</a></p>
<p class="toc level1 tocsp"><a href="eqbvo.html">Part&nbsp;III&nbsp;Building a Device Driver</a></p>
<p class="toc level2"><a href="loading-15035.html">21.&nbsp;&nbsp;Compiling, Loading, Packaging, and Testing Drivers</a></p>
<p class="toc level3"><a href="fcaqh.html">Driver Development Summary</a></p>
<p class="toc level3"><a href="loading-112.html">Driver Code Layout</a></p>
<p class="toc level3"><a href="loading-1.html">Preparing for Driver Installation</a></p>
<p class="toc level3"><a href="loading-85890.html">Installing, Updating, and Removing Drivers</a></p>
<p class="toc level3"><a href="loading-9.html">Loading and Unloading Drivers</a></p>
<p class="toc level3"><a href="loading-32.html">Driver Packaging</a></p>
<div class="onpage">
<p class="toc level3"><a href="">Criteria for Testing Drivers</a></p>
</div>
<p class="toc level2 tocsp"><a href="debug-60.html">22.&nbsp;&nbsp;Debugging, Testing, and Tuning Device Drivers</a></p>
<p class="toc level2"><a href="coding-practices.html">23.&nbsp;&nbsp;Recommended Coding Practices</a></p>
<p class="toc level1 tocsp"><a href="eqbva.html">Part&nbsp;IV&nbsp;Appendixes</a></p>
<p class="toc level2"><a href="hwovr-18191.html">A.&nbsp;&nbsp;Hardware Overview</a></p>
<p class="toc level2"><a href="ddidkisvc-29227.html">B.&nbsp;&nbsp;Summary of Solaris DDI/DKI Services</a></p>
<p class="toc level2"><a href="lp64-35004.html">C.&nbsp;&nbsp;Making a Device Driver 64-Bit Ready</a></p>
<p class="toc level2"><a href="euazz.html">D.&nbsp;&nbsp;Console Frame Buffer Drivers</a></p>
<p class="toc level1 tocsp"><a href="idx-1.html">Index</a></p>
</td>
      <td class="ContentPane" width="705px">

	 <div class="MainContent">      	 
             

<a name="loading-17"></a><h3>Criteria for Testing Drivers</h3>
<p><a name="indexterm-1104"></a><a name="indexterm-1105"></a>Once a device driver is functional, that driver should be thoroughly tested prior
to distribution. Besides testing the features in traditional UNIX device drivers, Solaris drivers
require testing power management features, such as dynamic loading and unloading of drivers.</p>

<a name="loading-18"></a><h4>Configuration Testing</h4>
<a name="indexterm-1106"></a><p>A driver's ability to handle multiple device configurations is an important part of
the test process. Once the driver is working on a simple, or
default, configuration, additional configurations should be tested. Depending on the device, configuration testing can
be accomplished by changing jumpers or DIP switches. If the number of possible
configurations is small, all configurations should be tried. If the number is large,
various classes of possible configurations should be defined, and a sampling of configurations
from each class should be tested. Defining these classes depends on the potential
interactions among the different configuration parameters. These interactions are a function of the type
of the device and the way in which the driver was written.</p><p>For each device configuration, the basic functions must be tested, which include loading,
opening, reading, writing, closing, and unloading the driver. Any function that depends upon
the configuration deserves special attention. For example, changing the base memory address of
device registers is not likely to affect the behavior of most driver functions.
If a driver works well with one address, that driver is likely to
work as well with a different address. On the other hand, a special
I/O control call might have different effects depending on the particular device configuration.</p><p>Loading the driver with varying configurations ensures that the  <a href="http://docs.sun.com/doc/819-2255/probe-9e?a=view"><tt>probe</tt>(9E)</a> and
 <a href="http://docs.sun.com/doc/819-2255/attach-9e?a=view"><tt>attach</tt>(9E)</a> entry points can find the device at different addresses. For basic
functional testing, using regular UNIX commands such as  <a href="http://docs.sun.com/doc/819-2239/cat-1?a=view"><tt>cat</tt>(1)</a> or  <a href="http://docs.sun.com/doc/819-2240/dd-1m?a=view"><tt>dd</tt>(1M)</a>
is usually sufficient for character devices. Mounting or booting might be required for block
devices.</p>

<a name="loading-19"></a><h4>Functionality Testing</h4>
<p><a name="indexterm-1107"></a>After a driver has been completely tested for configuration, all of  the
driver's functionality should be thoroughly tested. These tests require exercising the operation of
all of the driver's entry points.</p><p>Many drivers require custom applications to test functionality. However, basic drivers for devices
such as disks, tapes, or asynchronous boards can be tested using standard system
utilities. All entry points should be tested in this process, including  <a href="http://docs.sun.com/doc/819-2255/devmap-9e?a=view"><tt>devmap</tt>(9E)</a>,
<a href="http://docs.sun.com/doc/819-2255/chpoll-9e?a=view"><tt>chpoll</tt>(9E)</a>, and <a href="http://docs.sun.com/doc/819-2255/ioctl-9e?a=view"><tt>ioctl</tt>(9E)</a>, if applicable. The <tt>ioctl()</tt> tests might be quite different
for each driver. For nonstandard devices, a custom testing application is generally required.</p>

<a name="loading-20"></a><h4>Error Handling</h4>
<p><a name="indexterm-1108"></a><a name="indexterm-1109"></a>A driver might perform correctly in an ideal environment but fail in cases
of errors, such as erroneous operations or bad data. Therefore, an important part
of driver testing is the testing of the driver's error handling.</p><p>All possible error conditions of a driver should be exercised, including error conditions
for actual hardware malfunctions. Some hardware error conditions might be difficult to induce,
but an effort should be made to force or to simulate such errors
if possible. All of these conditions could be encountered in the field. Cables
should be removed or be loosened, boards should be removed, and erroneous user
application code should be written to test those error paths. See also <a href="gevsi.html">Chapter&nbsp;13, Hardening Solaris Drivers</a>.</p>
<hr><p><b>Caution - </b>Be sure to take proper electrical precautions when testing.</p>
<hr>


<a name="loading-12"></a><h4>Testing Loading and Unloading</h4>
<p>Because a driver that does not load or unload can force unscheduled downtime,
loading and unloading must be thoroughly tested.</p><p>A script like the following example should suffice:</p><pre>#!/bin/sh
cd &lt;location_of_driver&gt;
while [ 1 ]
do
    modunload -i 'modinfo | grep " &lt;driver_name&gt; " | cut -cl-3' &amp;
    modload &lt;driver_name&gt; &amp;
done</pre>

<a name="loading-21"></a><h4>Stress, Performance, and Interoperability Testing</h4>
<p>To help ensure that a driver performs well, that driver should be
subjected to vigorous stress testing. For example, running single threads through a driver does
not test  locking logic or conditional variables that have to wait. Device
operations should be performed by multiple processes at once to cause several threads
to execute the same code simultaneously.</p><p>Techniques for performing simultaneous tests depend upon the driver. Some drivers  require
special testing applications, while starting several UNIX commands in the background is suitable
for others. Appropriate testing depends upon where the particular driver uses locks and
condition variables. Testing a driver on a multiprocessor machine is more likely to
expose problems than testing on a single-processor machine.</p><p>Interoperability between drivers must also be tested, particularly because different devices can share
interrupt levels. If possible, configure another device at the same interrupt level as
the one being tested. A stress test can determine whether the driver correctly
claims its own interrupts and operates according to expectations. Stress tests should be
run on both devices at once. Even if the devices do not share
an interrupt level, this test can still be valuable. For example, consider a
case in which serial communication devices experience errors when a network driver is
tested. The same problem might be causing the rest of the system to
encounter interrupt latency problems as well.</p><p>Driver performance under these stress tests should be measured using UNIX performance-measuring tools.
This type of testing can be as simple as using the  <a href="http://docs.sun.com/doc/819-2239/time-1?a=view"><tt>time</tt>(1)</a>
command along with commands to be used in the stress tests.</p>

<a name="loading-22"></a><h4>DDI/DKI Compliance Testing</h4>
<p><a name="indexterm-1110"></a><a name="indexterm-1111"></a>To ensure compatibility with later releases and reliable support for the current release,
every driver should be DDI/DKI compliant. Check that only kernel routines in <a href="http://docs.sun.com/doc/819-2256"><i>man pages section 9: DDI and DKI Kernel Functions</i></a>
and <a href="http://docs.sun.com/doc/819-2255"><i>man pages section 9: DDI and DKI Driver Entry Points</i></a> and data structures in <a href="http://docs.sun.com/doc/819-2257"><i>man pages section 9: DDI and DKI Properties and Data Structures</i></a> are used.</p>

<a name="loading-23"></a><h4>Installation and Packaging Testing</h4>
<p><a name="indexterm-1112"></a>Drivers are delivered to customers in <b>packages</b>. A package can be added or
be removed from the system using a standard mechanism (see the <a href="http://docs.sun.com/doc/817-0406"><i>Application Packaging Developer&rsquo;s Guide</i></a>).</p><p>The ability of a user to add or remove the package from
a system should be tested.  In testing, the package should be both
installed and removed from every type of media to be used for the
release. This testing should include several system configurations. Packages must not make unwarranted
assumptions about the directory environment of the target system. Certain valid assumptions, however, can
be made about where standard kernel files are kept. Also test adding and
removing of packages on newly installed machines that have not been modified for
a development environment. A common packaging error is for a package to rely
on a tool or file that is used in development only. For example,
no tools from the Source Compatibility package, <tt>SUNWscpu</tt>, should be used in driver
installation programs.</p><p>The driver installation must be tested on a minimal Solaris system without any
optional packages.</p>

<a name="loading-24"></a><h4>Testing Specific Types of Drivers</h4>
<p><a name="indexterm-1113"></a>This section provides some suggestions about how to test certain types of standard
devices.</p>

<a name="loading-25"></a><h5>Tape Drivers</h5>
<a name="indexterm-1114"></a><p>Tape drivers should be tested by performing several archive and restore operations. The
 <a href="http://docs.sun.com/doc/819-2239/cpio-1?a=view"><tt>cpio</tt>(1)</a> and <a href="http://docs.sun.com/doc/819-2239/tar-1?a=view"><tt>tar</tt>(1)</a> commands can be used for this purpose.  
Use the  <a href="http://docs.sun.com/doc/819-2240/dd-1m?a=view"><tt>dd</tt>(1M)</a> command to write an entire disk partition to tape.
Next, read back the data, and write the data to another partition of
the same size. Then compare the two copies. The  <a href="http://docs.sun.com/doc/819-2239/mt-1?a=view"><tt>mt</tt>(1)</a> command can exercise
most of the I/O controls that are specific to tape drivers. See the
<a href="http://docs.sun.com/doc/819-2254/mtio-7i?a=view"><tt>mtio</tt>(7I)</a> man page. Try to use all the options. These three techniques can
test the error-handling capabilities of tape drivers:</p>
<ul><li><p>Remove the tape and try various operations</p></li>
<li><p>Write-protect the tape and try a write</p></li>
<li><p>Turn off power in the middle of different operations</p></li></ul>
<p>Tape drivers typically implement exclusive-access <a href="http://docs.sun.com/doc/819-2255/open-9e?a=view"><tt>open</tt>(9E)</a> calls. These <tt>open()</tt> calls can be tested
by opening a device and then having a second process try to open
the same device.</p>

<a name="loading-26"></a><h5>Disk Drivers</h5>
<p><a name="indexterm-1115"></a><a name="indexterm-1116"></a>Disk drivers should be tested in both the raw and block device modes.
  For block device tests, create a new file system on the
device. Then try to mount the new file system. Then try to perform
multiple file operations.</p>
<hr><p><b>Note - </b>The file system uses a page cache, so reading the same file
over and over again does not really exercise the driver. The page cache
can be forced to retrieve data from the device by memory-mapping the file
with <a href="http://docs.sun.com/doc/819-2241/mmap-2?a=view"><tt>mmap</tt>(2)</a>. Then use <a href="http://docs.sun.com/doc/819-2243/msync-3c?a=view"><tt>msync</tt>(3C)</a> to invalidate the in-memory copies.</p>
<hr>
<p>Copy another (unmounted) partition of the same size to the raw device. Then
use a command such as  <a href="http://docs.sun.com/doc/819-2240/fsck-1m?a=view"><tt>fsck</tt>(1M)</a> to verify the correctness of the
copy. The new partition can also be mounted and then later compared to
the old partition on a file-by-file basis.</p>

<a name="loading-27"></a><h5>Asynchronous Communication Drivers</h5>
<p><a name="indexterm-1117"></a><a name="indexterm-1118"></a>Asynchronous drivers can be tested at the basic level by setting up a
<tt>login</tt> line to the serial ports. A good test is to see whether
a user can log in on this line. To sufficiently test an asynchronous
driver, however, all the I/O control functions must be tested, with many interrupts
at high speed. A test involving a loopback serial cable and high data
transfer rates can help determine the reliability of the driver. You can run
<a href="http://docs.sun.com/doc/819-2239/uucp-1c?a=view"><tt>uucp</tt>(1C)</a> over the line to provide some exercise. However, because <tt>uucp</tt> performs its
own error handling, verify that the driver is not reporting excessive numbers of
errors to the  <tt>uucp</tt> process.</p><p>These types of devices are usually STREAMS-based. See the <a href="http://docs.sun.com/doc/816-4855"><i>STREAMS Programming Guide</i></a> for more information.</p>

<a name="loading-28"></a><h5>Network Drivers</h5>
<p><a name="indexterm-1119"></a><a name="indexterm-1120"></a>Network drivers can be tested using standard network utilities. The <a href="http://docs.sun.com/doc/819-2239/ftp-1?a=view"><tt>ftp</tt>(1)</a> and  <a href="http://docs.sun.com/doc/819-2239/rcp-1?a=view"><tt>rcp</tt>(1)</a>
commands are useful because the files can be compared on each end of
the network. The driver should be tested under heavy network loading, so that
various commands can be run by multiple processes.</p><p>Heavy network loading includes the following conditions:</p>
<ul><li><p>Traffic to the test machine is heavy.</p></li>
<li><p>Traffic among all machines on the network is heavy.</p></li></ul>
<p>Network cables should be unplugged while the tests are executing to ensure that
the driver recovers gracefully from the resulting error conditions. Another important test is
for the driver to receive multiple packets in rapid succession, that is, 
<b>back-to-back</b> packets. In this case, a relatively fast host on a lightly loaded
network should send multiple packets in quick succession to the test machine. Verify
that the receiving driver does not drop the second and subsequent packets.</p><p>These types of devices are usually STREAMS-based. See the <a href="http://docs.sun.com/doc/816-4855"><i>STREAMS Programming Guide</i></a> for more information.</p>
         </div>
      </td>
   </tr>

   <tr class="PageControls" valign="top">
      <td></td>
      <td>
         <table width="100%">
      	   <tr>
      	     <td>
                 <a href="loading-32.html">Previous</a>
             </td>
             <td align="right">
                 <a href="debug-60.html">Next</a>
             </td>
           </tr>
         </table>
      </td>
   </tr>
</tbody>
</table>


</body>
</html>

