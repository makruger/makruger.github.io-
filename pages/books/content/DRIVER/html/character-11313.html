<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="en-US">
<head>
<meta http-equiv="Content-type" content="text/html; charset=iso-8859-1">
<title>Multiplexing I/O on File Descriptors - Writing Device Drivers</title>
<meta name="robots" content="index,follow">
<meta name="robots" content="index,follow">
<meta name="date" content="2008-08-01">
<meta name="collection" content="reference">
<link rel="stylesheet" type="text/css" href="css/elements.css">
<link rel="stylesheet" type="text/css" href="css/indiana.css">
</head>

<body>


<div class="Masthead">
   <div class="MastheadLogo">
      <a href="http://www.opensolaris.org"><img border="0" src="graphics/header.png"></img></a>
   </div>
   <div class="Title">Writing Device Drivers</div>
</div>

<table class="Layout" border="0" cellspacing="0" width="100%">
<tbody>

   <tr valign="top" class="PageControls">
      <td></td>
      <td>
         <table width="100%">
      	   <tr>
      	     <td>
                 <a href="character-16543.html">Previous</a>
             </td>
             <td align="right">
                 <a href="character-23939.html">Next</a>
             </td>
           </tr>
         </table>
      </td>
   </tr>
   
   <tr valign="top">
      <td class="Navigation" width="200px"><p class="toc level1"><a href="docinfo.html">Document Information</a></p>
<p class="toc level1 tocsp"><a href="preface-1.html">Preface</a></p>
<p class="toc level1 tocsp"><a href="eqbvu.html">Part&nbsp;I&nbsp;Designing Device Drivers for the Solaris Platform</a></p>
<p class="toc level2"><a href="eqbqn.html">1.&nbsp;&nbsp;Overview of Solaris Device Drivers</a></p>
<p class="toc level2"><a href="kernelovr-77198.html">2.&nbsp;&nbsp;Solaris Kernel and Device Tree</a></p>
<p class="toc level2"><a href="mt-17026.html">3.&nbsp;&nbsp;Multithreading</a></p>
<p class="toc level2"><a href="properties-1.html">4.&nbsp;&nbsp;Properties</a></p>
<p class="toc level2"><a href="events-1.html">5.&nbsp;&nbsp;Managing Events and Queueing Tasks</a></p>
<p class="toc level2"><a href="autoconf-17.html">6.&nbsp;&nbsp;Driver Autoconfiguration</a></p>
<p class="toc level2"><a href="devaccess-3.html">7.&nbsp;&nbsp;Device Access: Programmed I/O</a></p>
<p class="toc level2"><a href="interrupt-15678.html">8.&nbsp;&nbsp;Interrupt Handlers</a></p>
<p class="toc level2"><a href="dma-29901.html">9.&nbsp;&nbsp;Direct Memory Access (DMA)</a></p>
<p class="toc level2"><a href="devmap-24338.html">10.&nbsp;&nbsp;Mapping Device and Kernel Memory</a></p>
<p class="toc level2"><a href="devcnmgt-19679.html">11.&nbsp;&nbsp;Device Context Management</a></p>
<p class="toc level2"><a href="powermgt-37437.html">12.&nbsp;&nbsp;Power Management</a></p>
<p class="toc level2"><a href="gevsi.html">13.&nbsp;&nbsp;Hardening Solaris Drivers</a></p>
<p class="toc level2"><a href="ldi-1.html">14.&nbsp;&nbsp;Layered Driver Interface (LDI)</a></p>
<p class="toc level1 tocsp"><a href="eqbvb.html">Part&nbsp;II&nbsp;Designing Specific Kinds of Device Drivers</a></p>
<p class="toc level2"><a href="character-21002.html">15.&nbsp;&nbsp;Drivers for Character Devices</a></p>
<p class="toc level3"><a href="character-1.html">Overview of the Character Driver Structure</a></p>
<p class="toc level3"><a href="character-51.html">Character Device Autoconfiguration</a></p>
<p class="toc level3"><a href="character-6.html">Device Access (Character Drivers)</a></p>
<p class="toc level3"><a href="character-25379.html">I/O Request Handling</a></p>
<p class="toc level3"><a href="character-16543.html">Mapping Device Memory</a></p>
<div class="onpage">
<p class="toc level3"><a href="">Multiplexing I/O on File Descriptors</a></p>
</div>
<p class="toc level3"><a href="character-23939.html">Miscellaneous I/O Control</a></p>
<p class="toc level3"><a href="character-17.html">32-bit and 64-bit Data Structure Macros</a></p>
<p class="toc level2 tocsp"><a href="block-34861.html">16.&nbsp;&nbsp;Drivers for Block Devices</a></p>
<p class="toc level2"><a href="scsi-36812.html">17.&nbsp;&nbsp;SCSI Target Drivers</a></p>
<p class="toc level2"><a href="scsihba-32898.html">18.&nbsp;&nbsp;SCSI Host Bus Adapter Drivers</a></p>
<p class="toc level2"><a href="gld-1.html">19.&nbsp;&nbsp;Drivers for Network Devices</a></p>
<p class="toc level2"><a href="usb-1.html">20.&nbsp;&nbsp;USB Drivers</a></p>
<p class="toc level1 tocsp"><a href="eqbvo.html">Part&nbsp;III&nbsp;Building a Device Driver</a></p>
<p class="toc level2"><a href="loading-15035.html">21.&nbsp;&nbsp;Compiling, Loading, Packaging, and Testing Drivers</a></p>
<p class="toc level2"><a href="debug-60.html">22.&nbsp;&nbsp;Debugging, Testing, and Tuning Device Drivers</a></p>
<p class="toc level2"><a href="coding-practices.html">23.&nbsp;&nbsp;Recommended Coding Practices</a></p>
<p class="toc level1 tocsp"><a href="eqbva.html">Part&nbsp;IV&nbsp;Appendixes</a></p>
<p class="toc level2"><a href="hwovr-18191.html">A.&nbsp;&nbsp;Hardware Overview</a></p>
<p class="toc level2"><a href="ddidkisvc-29227.html">B.&nbsp;&nbsp;Summary of Solaris DDI/DKI Services</a></p>
<p class="toc level2"><a href="lp64-35004.html">C.&nbsp;&nbsp;Making a Device Driver 64-Bit Ready</a></p>
<p class="toc level2"><a href="euazz.html">D.&nbsp;&nbsp;Console Frame Buffer Drivers</a></p>
<p class="toc level1 tocsp"><a href="idx-1.html">Index</a></p>
</td>
      <td class="ContentPane" width="705px">

	 <div class="MainContent">      	 
             

<a name="character-11313"></a><h3>Multiplexing I/O on File Descriptors</h3>
<p><a name="character-ix407"></a><a name="indexterm-571"></a>A thread sometimes needs to handle I/O on more than one file
descriptor. One example is an application program that needs to read the temperature
from a temperature-sensing device and then report the temperature to an interactive display. 
A program that makes a read request with no data available should not
block while waiting for the temperature before interacting with the user again.</p><p><a name="character-ix408"></a>The <a href="http://docs.sun.com/doc/819-2241/poll-2?a=view"><tt>poll</tt>(2)</a> system call provides users with a mechanism for multiplexing I/O over
a set of file descriptors that reference open files.  <a href="http://docs.sun.com/doc/819-2241/poll-2?a=view"><tt>poll</tt>(2)</a> identifies those file
descriptors on which a program can send or receive data without blocking, or
on which certain events have occurred.</p><p><a name="character-ix409"></a><a name="character-ix410"></a><a name="character-ix411"></a>To enable a program to poll a character driver, the driver must implement
the <a href="http://docs.sun.com/doc/819-2255/chpoll-9e?a=view"><tt>chpoll</tt>(9E)</a> entry point. The system calls <tt>chpoll</tt>(9E) when a user process issues
a <a href="http://docs.sun.com/doc/819-2241/poll-2?a=view"><tt>poll</tt>(2)</a> system call on a file descriptor associated with the device. The
<tt>chpoll</tt>(9E) entry point routine is used by non-STREAMS character device drivers that need
to support polling.</p><p>The <a href="http://docs.sun.com/doc/819-2255/chpoll-9e?a=view"><tt>chpoll</tt>(9E)</a> function uses the following syntax:</p><pre>int xxchpoll(dev_t <i>dev</i>, short <i>events</i>, int <i>anyyet</i>, short *<i>reventsp</i>,
     struct <i>pollhead</i> **<i>phpp</i>);</pre><p>In the <tt>chpoll</tt>(9E) entry point, the driver must follow these rules:</p>
<ul><li><p>Implement the following algorithm when the <tt>chpoll</tt>(9E) entry point is called:</p><pre>if ( /* events are satisfied now */ ) {
    *reventsp = <i>mask_of_satisfied_events</i>
} else {
    *reventsp = 0;
    if (!anyyet)
        *phpp = &amp;<i>local_pollhead_structure</i>;
}
return (0);</pre><p>See the <a href="http://docs.sun.com/doc/819-2255/chpoll-9e?a=view"><tt>chpoll</tt>(9E)</a> man page for a discussion of events to check. The <tt>chpoll</tt>(9E) entry point should then return the mask of satisfied events by setting the return events in <i>*reventsp</i>.</p><p>If no events have occurred, the return field for the events is cleared. If the <i>anyyet</i> field is not set, the driver must return an instance of the <tt>pollhead</tt> structure. The <tt>pollhead</tt> structure is usually allocated in a state structure. The <tt>pollhead</tt> structure should be treated as opaque by the driver. None of the <tt>pollhead</tt> fields should be referenced.</p></li>
<li><p>Call <a href="http://docs.sun.com/doc/819-2256/pollwakeup-9f?a=view"><tt>pollwakeup</tt>(9F)</a> whenever a device condition of type <tt>events</tt>, listed in <a href="#character-25342">Example&nbsp;15-10</a>, occurs. This function should be called only with one event at a time. You can call <tt>pollwakeup</tt>(9F) in the interrupt routine when the condition has occurred.</p></li></ul>
<p><a href="#character-25342">Example&nbsp;15-10</a> and <a href="#character-38661">Example&nbsp;15-11</a> show how to implement the polling discipline and how to
use <tt>pollwakeup</tt>(9F).</p><p>The following example shows how to handle the <tt>POLLIN</tt> and <tt>POLLERR</tt> events.
The driver first reads the status register to determine the current state of
the device. The parameter <tt>events</tt> specifies which conditions the driver should check. If
an appropriate condition has occurred, the driver sets that bit in <i>*reventsp</i>. If none
of the conditions has occurred and if <i>anyyet</i> is not set, the address
of the <tt>pollhead</tt> structure is returned in <i>*phpp</i>.</p><a name="character-25342"></a><h6>Example&nbsp;15-10 <tt>chpoll</tt>(9E) Routine</h6><pre>static int
xxchpoll(dev_t dev, short events, int anyyet,
    short *reventsp, struct pollhead **phpp)
{
     uint8_t status;
     short revent;
     struct xxstate *xsp;

     xsp = ddi_get_soft_state(statep, getminor(dev));
     if (xsp == NULL)
         return (ENXIO);
     revent = 0;
     /*
      * Valid events are:
      * POLLIN | POLLOUT | POLLPRI | POLLHUP | POLLERR
      * This example checks only for POLLIN and POLLERR.
      */
     status = ddi_get8(xsp-&gt;data_access_handle, &amp;xsp-&gt;regp-&gt;csr);
     if ((events &amp; POLLIN) &amp;&amp; <i>data available to read</i>) {
        revent |= POLLIN;
     }
     if (status &amp; DEVICE_ERROR) {
        revent |= POLLERR;
     }
     /* if nothing has occurred */
     if (revent == 0) {
        if (!anyyet) {
        *phpp = &amp;xsp-&gt;pollhead;
        }
     }
       *reventsp = revent;
     return (0);
}</pre><p>The following example shows how to use the <a href="http://docs.sun.com/doc/819-2256/pollwakeup-9f?a=view"><tt>pollwakeup</tt>(9F)</a> function. The <tt>pollwakeup</tt>(9F)
function usually is called in the interrupt routine when a supported condition has
occurred. The interrupt routine reads the status from the status register and checks
for the conditions. The routine then calls <tt>pollwakeup</tt>(9F) for each event to
possibly notify polling threads that they should check again. Note that <tt>pollwakeup</tt>(9F) should
not be called with any locks held, since deadlock could result if another
routine tried to enter <a href="http://docs.sun.com/doc/819-2255/chpoll-9e?a=view"><tt>chpoll</tt>(9E)</a> and grab the same lock.</p><a name="character-38661"></a><h6>Example&nbsp;15-11 Interrupt Routine Supporting <tt>chpoll</tt>(9E)</h6><pre>static u_int
xxintr(caddr_t arg)
{
     struct xxstate *xsp = (struct xxstate *)arg;
     uint8_t    status;
     /* normal interrupt processing */
     /* ... */
     status = ddi_get8(xsp-&gt;data_access_handle, &amp;xsp-&gt;regp-&gt;csr);
     if (status &amp; DEVICE_ERROR) {
        pollwakeup(&amp;xsp-&gt;pollhead, POLLERR);
     }
     if ( /* just completed a read */ ) {
        pollwakeup(&amp;xsp-&gt;pollhead, POLLIN);
     }
     /* ... */
     return (DDI_INTR_CLAIMED);
}</pre>
         </div>
      </td>
   </tr>

   <tr class="PageControls" valign="top">
      <td></td>
      <td>
         <table width="100%">
      	   <tr>
      	     <td>
                 <a href="character-16543.html">Previous</a>
             </td>
             <td align="right">
                 <a href="character-23939.html">Next</a>
             </td>
           </tr>
         </table>
      </td>
   </tr>
</tbody>
</table>


</body>
</html>

