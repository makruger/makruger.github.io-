<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="en-US">
<head>
<meta http-equiv="Content-type" content="text/html; charset=iso-8859-1">
<title>Block Device Autoconfiguration - Writing Device Drivers</title>
<meta name="robots" content="index,follow">
<meta name="robots" content="index,follow">
<meta name="date" content="2008-08-01">
<meta name="collection" content="reference">
<link rel="stylesheet" type="text/css" href="css/elements.css">
<link rel="stylesheet" type="text/css" href="css/indiana.css">
</head>

<body>


<div class="Masthead">
   <div class="MastheadLogo">
      <a href="http://www.opensolaris.org"><img border="0" src="graphics/header.png"></img></a>
   </div>
   <div class="Title">Writing Device Drivers</div>
</div>

<table class="Layout" border="0" cellspacing="0" width="100%">
<tbody>

   <tr valign="top" class="PageControls">
      <td></td>
      <td>
         <table width="100%">
      	   <tr>
      	     <td>
                 <a href="block-82249.html">Previous</a>
             </td>
             <td align="right">
                 <a href="block-6.html">Next</a>
             </td>
           </tr>
         </table>
      </td>
   </tr>
   
   <tr valign="top">
      <td class="Navigation" width="200px"><p class="toc level1"><a href="docinfo.html">Document Information</a></p>
<p class="toc level1 tocsp"><a href="preface-1.html">Preface</a></p>
<p class="toc level1 tocsp"><a href="eqbvu.html">Part&nbsp;I&nbsp;Designing Device Drivers for the Solaris Platform</a></p>
<p class="toc level2"><a href="eqbqn.html">1.&nbsp;&nbsp;Overview of Solaris Device Drivers</a></p>
<p class="toc level2"><a href="kernelovr-77198.html">2.&nbsp;&nbsp;Solaris Kernel and Device Tree</a></p>
<p class="toc level2"><a href="mt-17026.html">3.&nbsp;&nbsp;Multithreading</a></p>
<p class="toc level2"><a href="properties-1.html">4.&nbsp;&nbsp;Properties</a></p>
<p class="toc level2"><a href="events-1.html">5.&nbsp;&nbsp;Managing Events and Queueing Tasks</a></p>
<p class="toc level2"><a href="autoconf-17.html">6.&nbsp;&nbsp;Driver Autoconfiguration</a></p>
<p class="toc level2"><a href="devaccess-3.html">7.&nbsp;&nbsp;Device Access: Programmed I/O</a></p>
<p class="toc level2"><a href="interrupt-15678.html">8.&nbsp;&nbsp;Interrupt Handlers</a></p>
<p class="toc level2"><a href="dma-29901.html">9.&nbsp;&nbsp;Direct Memory Access (DMA)</a></p>
<p class="toc level2"><a href="devmap-24338.html">10.&nbsp;&nbsp;Mapping Device and Kernel Memory</a></p>
<p class="toc level2"><a href="devcnmgt-19679.html">11.&nbsp;&nbsp;Device Context Management</a></p>
<p class="toc level2"><a href="powermgt-37437.html">12.&nbsp;&nbsp;Power Management</a></p>
<p class="toc level2"><a href="gevsi.html">13.&nbsp;&nbsp;Hardening Solaris Drivers</a></p>
<p class="toc level2"><a href="ldi-1.html">14.&nbsp;&nbsp;Layered Driver Interface (LDI)</a></p>
<p class="toc level1 tocsp"><a href="eqbvb.html">Part&nbsp;II&nbsp;Designing Specific Kinds of Device Drivers</a></p>
<p class="toc level2"><a href="character-21002.html">15.&nbsp;&nbsp;Drivers for Character Devices</a></p>
<p class="toc level2"><a href="block-34861.html">16.&nbsp;&nbsp;Drivers for Block Devices</a></p>
<p class="toc level3"><a href="block-1.html">Block Driver Structure Overview</a></p>
<p class="toc level3"><a href="block-82249.html">File I/O</a></p>
<div class="onpage">
<p class="toc level3"><a href="">Block Device Autoconfiguration</a></p>
</div>
<p class="toc level3"><a href="block-6.html">Controlling Device Access</a></p>
<p class="toc level3"><a href="block-78892.html">Synchronous Data Transfers (Block Drivers)</a></p>
<p class="toc level3"><a href="block-54698.html">Asynchronous Data Transfers (Block Drivers)</a></p>
<p class="toc level3"><a href="block-25.html"><tt>dump()</tt> and <tt>print()</tt> Entry Points</a></p>
<p class="toc level3"><a href="advanced-7.html">Disk Device Drivers</a></p>
<p class="toc level2 tocsp"><a href="scsi-36812.html">17.&nbsp;&nbsp;SCSI Target Drivers</a></p>
<p class="toc level2"><a href="scsihba-32898.html">18.&nbsp;&nbsp;SCSI Host Bus Adapter Drivers</a></p>
<p class="toc level2"><a href="gld-1.html">19.&nbsp;&nbsp;Drivers for Network Devices</a></p>
<p class="toc level2"><a href="usb-1.html">20.&nbsp;&nbsp;USB Drivers</a></p>
<p class="toc level1 tocsp"><a href="eqbvo.html">Part&nbsp;III&nbsp;Building a Device Driver</a></p>
<p class="toc level2"><a href="loading-15035.html">21.&nbsp;&nbsp;Compiling, Loading, Packaging, and Testing Drivers</a></p>
<p class="toc level2"><a href="debug-60.html">22.&nbsp;&nbsp;Debugging, Testing, and Tuning Device Drivers</a></p>
<p class="toc level2"><a href="coding-practices.html">23.&nbsp;&nbsp;Recommended Coding Practices</a></p>
<p class="toc level1 tocsp"><a href="eqbva.html">Part&nbsp;IV&nbsp;Appendixes</a></p>
<p class="toc level2"><a href="hwovr-18191.html">A.&nbsp;&nbsp;Hardware Overview</a></p>
<p class="toc level2"><a href="ddidkisvc-29227.html">B.&nbsp;&nbsp;Summary of Solaris DDI/DKI Services</a></p>
<p class="toc level2"><a href="lp64-35004.html">C.&nbsp;&nbsp;Making a Device Driver 64-Bit Ready</a></p>
<p class="toc level2"><a href="euazz.html">D.&nbsp;&nbsp;Console Frame Buffer Drivers</a></p>
<p class="toc level1 tocsp"><a href="idx-1.html">Index</a></p>
</td>
      <td class="ContentPane" width="705px">

	 <div class="MainContent">      	 
             

<a name="block-5"></a><h3>Block Device Autoconfiguration</h3>
<a name="block-ix422"></a><p><a href="http://docs.sun.com/doc/819-2255/attach-9e?a=view"><tt>attach</tt>(9E)</a> should perform the common initialization tasks for each instance of a device:</p>
<ul><li><p>Allocating per-instance state structures</p></li>
<li><p>Mapping the device's registers</p></li>
<li><p>Registering device interrupts</p></li>
<li><p>Initializing mutex and condition variables</p></li>
<li><p>Creating power manageable components</p></li>
<li><p>Creating minor nodes</p></li></ul>
<p>Block device drivers create minor nodes of type <tt>S_IFBLK</tt>. As a result, 
a block special file that represents the node appears in the <tt>/devices</tt>
hierarchy.</p><p><a name="block-ix423"></a><a name="block-ix424"></a><a name="block-ix425"></a>Logical device names for block devices appear in the <tt>/dev/dsk</tt> directory, and consist of
a controller number, bus-address number, disk number, and slice number. These names are
created by the <a href="http://docs.sun.com/doc/819-2240/devfsadm-1m?a=view"><tt>devfsadm</tt>(1M)</a> program if the node type is set to <tt>DDI_NT_BLOCK</tt>
or <tt>DDI_NT_BLOCK_CHAN</tt>. <tt>DDI_NT_BLOCK_CHAN</tt> should be specified if the device communicates on a channel,
that is, a bus with an additional level of addressability.  SCSI disks
are a good example. <tt>DDI_NT_BLOCK_CHAN</tt> causes a bus-address field (t<b>N</b>) to appear in
the logical name. <tt>DDI_NT_BLOCK</tt> should be used for most other devices.</p><p><a name="indexterm-573"></a><a name="indexterm-574"></a><a name="indexterm-575"></a><a name="indexterm-576"></a>A minor device refers to a partition on the disk. For each
minor device, the driver must create an <tt>nblocks</tt> or <tt>Nblocks</tt> property. This integer property
gives the number of blocks supported by the minor device expressed in units
of <tt>DEV_BSIZE</tt>, that is, 512 bytes. The file system uses the <tt>nblocks</tt> and
<tt>Nblocks</tt> properties to determine device limits. <tt>Nblocks</tt> is the 64-bit version of <tt>nblocks</tt>. <tt>Nblocks</tt>
should be used with storage devices that can hold over 1 Tbyte of
storage per disk. See <a href="properties-8.html">Device Properties</a> for more information.</p><p><a href="#block-29600">Example&nbsp;16-1</a> shows a typical <a href="http://docs.sun.com/doc/819-2255/attach-9e?a=view"><tt>attach</tt>(9E)</a> entry point with emphasis on creating the device's minor
node and the <tt>Nblocks</tt> property. Note that because this example uses <tt>Nblocks</tt> and
not <tt>nblocks</tt>,  <a href="http://docs.sun.com/doc/819-2256/ddi-prop-update-int64-9f?a=view"><tt>ddi_prop_update_int64</tt>(9F)</a> is called instead of <a href="http://docs.sun.com/doc/819-2256/ddi-prop-update-int-9f?a=view"><tt>ddi_prop_update_int</tt>(9F)</a>.</p><p><a name="indexterm-577"></a><a name="indexterm-578"></a><a name="indexterm-579"></a><a name="indexterm-580"></a><a name="indexterm-581"></a><a name="indexterm-582"></a>As a side note, this example shows the use of <a href="http://docs.sun.com/doc/819-2256/makedevice-9f?a=view"><tt>makedevice</tt>(9F)</a> to
create a device number for <tt>ddi_prop_update_int64()</tt>. The <tt>makedevice</tt> function makes use of <a href="http://docs.sun.com/doc/819-2256/ddi-driver-major-9f?a=view"><tt>ddi_driver_major</tt>(9F)</a>,
which generates a major number from a pointer to a <tt>dev_info_t</tt> structure. Using <tt>ddi_driver_major()</tt>
is similar to using <a href="http://docs.sun.com/doc/819-2256/getmajor-9f?a=view"><tt>getmajor</tt>(9F)</a>, which gets a <tt>dev_t</tt> structure pointer.</p><a name="block-29600"></a><h6>Example&nbsp;16-1 Block Driver <tt>attach()</tt> Routine</h6><pre>static int
xxattach(dev_info_t *dip, ddi_attach_cmd_t cmd)
{
    int instance = ddi_get_instance(dip);
    switch (cmd) {
      case DDI_ATTACH:
      /*
       * allocate a state structure and initialize it
       * map the devices registers
       * add the device driver's interrupt handler(s)
       * initialize any mutexes and condition variables
       * read label information if the device is a disk
       * create power manageable components
       *
       * Create the device minor node. Note that the node_type
       * argument is set to DDI_NT_BLOCK.
       */
      if (ddi_create_minor_node(dip, "<i>minor_name</i>", S_IFBLK,
          instance, DDI_NT_BLOCK, 0) == DDI_FAILURE) {
          /* free resources allocated so far */
          /* Remove any previously allocated minor nodes */
          ddi_remove_minor_node(dip, NULL);
          return (DDI_FAILURE);
      }
      /*
       * Create driver properties like "Nblocks". If the device
       * is a disk, the Nblocks property is usually calculated from
       * information in the disk label.  Use "Nblocks" instead of
       * "nblocks" to ensure the property works for large disks.
       */
      xsp-&gt;Nblocks = <i>size</i>;
      /* size is the size of the device in 512 byte blocks */
      maj_number = ddi_driver_major(dip);
      if (ddi_prop_update_int64(makedevice(maj_number, instance), dip, 
          "Nblocks", xsp-&gt;Nblocks) != DDI_PROP_SUCCESS) {
          cmn_err(CE_CONT, "%s: cannot create Nblocks property\n",
              ddi_get_name(dip));
          /* free resources allocated so far */
          return (DDI_FAILURE);
      }
      xsp-&gt;open = 0;
      xsp-&gt;nlayered = 0;
      /* ... */
      return (DDI_SUCCESS);

      case DDI_RESUME:
          /* For information, see Chapter 12, "Power Management," in this book. */
      default:
          return (DDI_FAILURE);
    }
}</pre>
         </div>
      </td>
   </tr>

   <tr class="PageControls" valign="top">
      <td></td>
      <td>
         <table width="100%">
      	   <tr>
      	     <td>
                 <a href="block-82249.html">Previous</a>
             </td>
             <td align="right">
                 <a href="block-6.html">Next</a>
             </td>
           </tr>
         </table>
      </td>
   </tr>
</tbody>
</table>


</body>
</html>

