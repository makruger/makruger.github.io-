<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="en-US">
<head>
<meta http-equiv="Content-type" content="text/html; charset=iso-8859-1">
<title>Entry Points for SCSA HBA Drivers - Writing Device Drivers</title>
<meta name="robots" content="index,follow">
<meta name="robots" content="index,follow">
<meta name="date" content="2008-08-01">
<meta name="collection" content="reference">
<link rel="stylesheet" type="text/css" href="css/elements.css">
<link rel="stylesheet" type="text/css" href="css/indiana.css">
</head>

<body>


<div class="Masthead">
   <div class="MastheadLogo">
      <a href="http://www.opensolaris.org"><img border="0" src="graphics/header.png"></img></a>
   </div>
   <div class="Title">Writing Device Drivers</div>
</div>

<table class="Layout" border="0" cellspacing="0" width="100%">
<tbody>

   <tr valign="top" class="PageControls">
      <td></td>
      <td>
         <table width="100%">
      	   <tr>
      	     <td>
                 <a href="scsihba-32.html">Previous</a>
             </td>
             <td align="right">
                 <a href="scsihba-88.html">Next</a>
             </td>
           </tr>
         </table>
      </td>
   </tr>
   
   <tr valign="top">
      <td class="Navigation" width="200px"><p class="toc level1"><a href="docinfo.html">Document Information</a></p>
<p class="toc level1 tocsp"><a href="preface-1.html">Preface</a></p>
<p class="toc level1 tocsp"><a href="eqbvu.html">Part&nbsp;I&nbsp;Designing Device Drivers for the Solaris Platform</a></p>
<p class="toc level2"><a href="eqbqn.html">1.&nbsp;&nbsp;Overview of Solaris Device Drivers</a></p>
<p class="toc level2"><a href="kernelovr-77198.html">2.&nbsp;&nbsp;Solaris Kernel and Device Tree</a></p>
<p class="toc level2"><a href="mt-17026.html">3.&nbsp;&nbsp;Multithreading</a></p>
<p class="toc level2"><a href="properties-1.html">4.&nbsp;&nbsp;Properties</a></p>
<p class="toc level2"><a href="events-1.html">5.&nbsp;&nbsp;Managing Events and Queueing Tasks</a></p>
<p class="toc level2"><a href="autoconf-17.html">6.&nbsp;&nbsp;Driver Autoconfiguration</a></p>
<p class="toc level2"><a href="devaccess-3.html">7.&nbsp;&nbsp;Device Access: Programmed I/O</a></p>
<p class="toc level2"><a href="interrupt-15678.html">8.&nbsp;&nbsp;Interrupt Handlers</a></p>
<p class="toc level2"><a href="dma-29901.html">9.&nbsp;&nbsp;Direct Memory Access (DMA)</a></p>
<p class="toc level2"><a href="devmap-24338.html">10.&nbsp;&nbsp;Mapping Device and Kernel Memory</a></p>
<p class="toc level2"><a href="devcnmgt-19679.html">11.&nbsp;&nbsp;Device Context Management</a></p>
<p class="toc level2"><a href="powermgt-37437.html">12.&nbsp;&nbsp;Power Management</a></p>
<p class="toc level2"><a href="gevsi.html">13.&nbsp;&nbsp;Hardening Solaris Drivers</a></p>
<p class="toc level2"><a href="ldi-1.html">14.&nbsp;&nbsp;Layered Driver Interface (LDI)</a></p>
<p class="toc level1 tocsp"><a href="eqbvb.html">Part&nbsp;II&nbsp;Designing Specific Kinds of Device Drivers</a></p>
<p class="toc level2"><a href="character-21002.html">15.&nbsp;&nbsp;Drivers for Character Devices</a></p>
<p class="toc level2"><a href="block-34861.html">16.&nbsp;&nbsp;Drivers for Block Devices</a></p>
<p class="toc level2"><a href="scsi-36812.html">17.&nbsp;&nbsp;SCSI Target Drivers</a></p>
<p class="toc level2"><a href="scsihba-32898.html">18.&nbsp;&nbsp;SCSI Host Bus Adapter Drivers</a></p>
<p class="toc level3"><a href="scsihba-105.html">Introduction to Host Bus Adapter Drivers</a></p>
<p class="toc level3"><a href="scsihba-10.html">SCSI Interface</a></p>
<p class="toc level3"><a href="scsihba-16.html">SCSA HBA Interfaces</a></p>
<p class="toc level3"><a href="scsihba-32.html">HBA Driver Dependency and Configuration Issues</a></p>
<div class="onpage">
<p class="toc level3"><a href="">Entry Points for SCSA HBA Drivers</a></p>
</div>
<p class="toc level3"><a href="scsihba-88.html">SCSI HBA Driver Specific Issues</a></p>
<p class="toc level3"><a href="scsihba-100.html">Support for Queuing</a></p>
<p class="toc level2 tocsp"><a href="gld-1.html">19.&nbsp;&nbsp;Drivers for Network Devices</a></p>
<p class="toc level2"><a href="usb-1.html">20.&nbsp;&nbsp;USB Drivers</a></p>
<p class="toc level1 tocsp"><a href="eqbvo.html">Part&nbsp;III&nbsp;Building a Device Driver</a></p>
<p class="toc level2"><a href="loading-15035.html">21.&nbsp;&nbsp;Compiling, Loading, Packaging, and Testing Drivers</a></p>
<p class="toc level2"><a href="debug-60.html">22.&nbsp;&nbsp;Debugging, Testing, and Tuning Device Drivers</a></p>
<p class="toc level2"><a href="coding-practices.html">23.&nbsp;&nbsp;Recommended Coding Practices</a></p>
<p class="toc level1 tocsp"><a href="eqbva.html">Part&nbsp;IV&nbsp;Appendixes</a></p>
<p class="toc level2"><a href="hwovr-18191.html">A.&nbsp;&nbsp;Hardware Overview</a></p>
<p class="toc level2"><a href="ddidkisvc-29227.html">B.&nbsp;&nbsp;Summary of Solaris DDI/DKI Services</a></p>
<p class="toc level2"><a href="lp64-35004.html">C.&nbsp;&nbsp;Making a Device Driver 64-Bit Ready</a></p>
<p class="toc level2"><a href="euazz.html">D.&nbsp;&nbsp;Console Frame Buffer Drivers</a></p>
<p class="toc level1 tocsp"><a href="idx-1.html">Index</a></p>
</td>
      <td class="ContentPane" width="705px">

	 <div class="MainContent">      	 
             

<a name="scsihba-50"></a><h3>Entry Points for SCSA HBA Drivers</h3>
<p>An HBA driver can work with target drivers through the SCSA interface. The
SCSA interfaces require the HBA driver to supply a number of entry
points that are callable through the <a href="http://docs.sun.com/doc/819-2257/scsi-hba-tran-9s?a=view"><tt>scsi_hba_tran</tt>(9S)</a> structure.</p><p>These entry points fall into five functional groups:</p>
<ul><li><p>Target driver instance initialization</p></li>
<li><p>Resource allocation and deallocation</p></li>
<li><p>Command transport</p></li>
<li><p>Capability management</p></li>
<li><p>Abort and reset handling</p></li>
<li><p>Dynamic reconfiguration</p></li></ul>
<p><a name="indexterm-621"></a>The following table lists the entry points for SCSA HBA by function groups.</p><a name="scsihba-tbl-51"></a><h6>Table&nbsp;18-3 SCSA Entry Points</h6><table><col width="30%"><col width="30%"><col width="40%"><tr><th align="left" valign="top" scope="column"><p>Function
Groups</p></th>
<th align="left" valign="top" scope="column"><p>Entry Points Within Group</p></th>
<th align="left" valign="top" scope="column"><p>Description</p></th>
</tr>
<tr><td align="left" valign="top" scope="row"><p>Target Driver Instance Initialization</p></td>
<td align="left" valign="top" scope="row"><p><a href="http://docs.sun.com/doc/819-2255/tran-tgt-init-9e?a=view"><tt>tran_tgt_init</tt>(9E)</a></p></td>
<td align="left" valign="top" scope="row"><p>Performs per-target initialization (optional)</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p></p></td>
<td align="left" valign="top" scope="row"><p><a href="http://docs.sun.com/doc/819-2255/tran-tgt-probe-9e?a=view"><tt>tran_tgt_probe</tt>(9E)</a></p></td>
<td align="left" valign="top" scope="row"><p>Probes SCSI bus
for existence of a target (optional)</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p></p></td>
<td align="left" valign="top" scope="row"><p><a href="http://docs.sun.com/doc/819-2255/tran-tgt-free-9e?a=view"><tt>tran_tgt_free</tt>(9E)</a></p></td>
<td align="left" valign="top" scope="row"><p>Performs per-target deallocation (optional)</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p>Resource Allocation</p></td>
<td align="left" valign="top" scope="row"><p><a href="http://docs.sun.com/doc/819-2255/tran-init-pkt-9e?a=view"><tt>tran_init_pkt</tt>(9E)</a></p></td>
<td align="left" valign="top" scope="row"><p>Allocates SCSI packet
and DMA resources</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p></p></td>
<td align="left" valign="top" scope="row"><p><a href="http://docs.sun.com/doc/819-2255/tran-destroy-pkt-9e?a=view"><tt>tran_destroy_pkt</tt>(9E)</a></p></td>
<td align="left" valign="top" scope="row"><p>Frees SCSI packet and DMA resources</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p></p></td>
<td align="left" valign="top" scope="row"><p><a href="http://docs.sun.com/doc/819-2255/tran-sync-pkt-9e?a=view"><tt>tran_sync_pkt</tt>(9E)</a></p></td>
<td align="left" valign="top" scope="row"><p>Synchronizes memory before and after
DMA</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p></p></td>
<td align="left" valign="top" scope="row"><p><a href="http://docs.sun.com/doc/819-2255/tran-dmafree-9e?a=view"><tt>tran_dmafree</tt>(9E)</a></p></td>
<td align="left" valign="top" scope="row"><p>Frees DMA resources</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p>Command Transport</p></td>
<td align="left" valign="top" scope="row"><p><a href="http://docs.sun.com/doc/819-2255/tran-start-9e?a=view"><tt>tran_start</tt>(9E)</a></p></td>
<td align="left" valign="top" scope="row"><p>Transports a SCSI command</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p>Capability Management</p></td>
<td align="left" valign="top" scope="row"><p><a href="http://docs.sun.com/doc/819-2255/tran-getcap-9e?a=view"><tt>tran_getcap</tt>(9E)</a></p></td>
<td align="left" valign="top" scope="row"><p>Inquires about a capability's value</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p></p></td>
<td align="left" valign="top" scope="row"><p><a href="http://docs.sun.com/doc/819-2255/tran-setcap-9e?a=view"><tt>tran_setcap</tt>(9E)</a></p></td>
<td align="left" valign="top" scope="row"><p>Sets
a capability's value</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p>Abort and Reset</p></td>
<td align="left" valign="top" scope="row"><p><a href="http://docs.sun.com/doc/819-2255/tran-abort-9e?a=view"><tt>tran_abort</tt>(9E)</a></p></td>
<td align="left" valign="top" scope="row"><p>Aborts outstanding SCSI commands</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p></p></td>
<td align="left" valign="top" scope="row"><p><a href="http://docs.sun.com/doc/819-2255/tran-reset-9e?a=view"><tt>tran_reset</tt>(9E)</a></p></td>
<td align="left" valign="top" scope="row"><p>Resets a target device or
the SCSI bus</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p></p></td>
<td align="left" valign="top" scope="row"><p><a href="http://docs.sun.com/doc/819-2255/tran-bus-reset-9e?a=view"><tt>tran_bus_reset</tt>(9E)</a></p></td>
<td align="left" valign="top" scope="row"><p>Resets the SCSI bus</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p></p></td>
<td align="left" valign="top" scope="row"><p><a href="http://docs.sun.com/doc/819-2255/tran-reset-notify-9e?a=view"><tt>tran_reset_notify</tt>(9E)</a></p></td>
<td align="left" valign="top" scope="row"><p>Request to notify target of bus reset
(optional)</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p>Dynamic Reconfiguration</p></td>
<td align="left" valign="top" scope="row"><p><a href="http://docs.sun.com/doc/819-2255/tran-quiesce-9e?a=view"><tt>tran_quiesce</tt>(9E)</a></p></td>
<td align="left" valign="top" scope="row"><p>Stops activity on the bus</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p></p></td>
<td align="left" valign="top" scope="row"><p><a href="http://docs.sun.com/doc/819-2255/tran-unquiesce-9e?a=view"><tt>tran_unquiesce</tt>(9E)</a></p></td>
<td align="left" valign="top" scope="row"><p>Resumes activity on the bus</p></td>
</tr>
</table>

<a name="scsihba-52"></a><h4>Target Driver Instance Initialization</h4>
<p>The following sections describe target entry points.</p>

<a name="scsihba-53"></a><h5><tt>tran_tgt_init()</tt> Entry Point</h5>
<p><a name="indexterm-622"></a><a name="indexterm-623"></a>The <a href="http://docs.sun.com/doc/819-2255/tran-tgt-init-9e?a=view"><tt>tran_tgt_init</tt>(9E)</a> entry point enables the HBA to allocate and initialize any per-target
resources. <tt>tran_tgt_init()</tt> also enables the HBA to qualify the device's address as valid
and supportable for that particular HBA. By returning <tt>DDI_FAILURE</tt>, the instance of the target
driver for that device is not probed or attached.</p><p><tt>tran_tgt_init()</tt> is not required. If <tt>tran_tgt_init()</tt> is not supplied, the framework attempts
to probe and attach all possible instances of the appropriate target drivers.</p><pre>static int
isp_tran_tgt_init(
    dev_info_t            *hba_dip,
    dev_info_t            *tgt_dip,
    scsi_hba_tran_t       *tran,
    struct scsi_device    *sd)
{
    return ((sd-&gt;sd_address.a_target &lt; N_ISP_TARGETS_WIDE &amp;&amp;
        sd-&gt;sd_address.a_lun &lt; 8) ? DDI_SUCCESS : DDI_FAILURE);
}</pre>

<a name="scsihba-54"></a><h5><tt>tran_tgt_probe()</tt> Entry Point</h5>
<p><a name="indexterm-624"></a>The <a href="http://docs.sun.com/doc/819-2255/tran-tgt-probe-9e?a=view"><tt>tran_tgt_probe</tt>(9E)</a> entry point enables the HBA to customize the operation of 
<a href="http://docs.sun.com/doc/819-2256/scsi-probe-9f?a=view"><tt>scsi_probe</tt>(9F)</a>, if necessary. This entry point is called only when the target driver
calls <tt>scsi_probe()</tt>.</p><p><a name="indexterm-625"></a><a name="indexterm-626"></a>The HBA driver can retain the normal operation of <tt>scsi_probe()</tt> by calling 
<a href="http://docs.sun.com/doc/819-2256/scsi-hba-probe-9f?a=view"><tt>scsi_hba_probe</tt>(9F)</a> and returning its return value.</p><p>This entry point is not required, and if not needed, the HBA
driver should set the <tt>tran_tgt_probe</tt> vector in the <a href="http://docs.sun.com/doc/819-2257/scsi-hba-tran-9s?a=view"><tt>scsi_hba_tran</tt>(9S)</a> structure to point to <tt>scsi_hba_probe()</tt>.</p><p><a name="indexterm-627"></a><tt>scsi_probe()</tt> allocates a <a href="http://docs.sun.com/doc/819-2257/scsi-inquiry-9s?a=view"><tt>scsi_inquiry</tt>(9S)</a> structure and sets the <tt>sd_inq</tt> field of the
<a href="http://docs.sun.com/doc/819-2257/scsi-device-9s?a=view"><tt>scsi_device</tt>(9S)</a> structure to point to the data in <tt>scsi_inquiry</tt>. <tt>scsi_hba_probe()</tt> handles this task automatically.
 <a href="http://docs.sun.com/doc/819-2256/scsi-unprobe-9f?a=view"><tt>scsi_unprobe</tt>(9F)</a> then frees the <tt>scsi_inquiry</tt> data.</p><p>Except for the allocation of <tt>scsi_inquiry</tt> data, <tt>tran_tgt_probe()</tt> must be stateless, because
the same SCSI device might call <tt>tran_tgt_probe()</tt> several times. Normally, allocation of <tt>scsi_inquiry</tt> data
is handled by  <tt>scsi_hba_probe()</tt>.</p>
<hr><p><b>Note - </b>The allocation of the <a href="http://docs.sun.com/doc/819-2257/scsi-inquiry-9s?a=view"><tt>scsi_inquiry</tt>(9S)</a> structure is handled automatically by  <tt>scsi_hba_probe()</tt>. This
information is only of concern if you want custom <tt>scsi_probe()</tt> handling.</p>
<hr>
<pre>static int
isp_tran_tgt_probe(
    struct scsi_device    *sd,
    int                   (*callback)())
{
    /*
     * Perform any special probe customization needed.
     * Normal probe handling.
     */
    return (scsi_hba_probe(sd, callback));
}</pre>

<a name="scsihba-55"></a><h5><tt>tran_tgt_free()</tt> Entry Point</h5>
<p><a name="indexterm-628"></a>The <a href="http://docs.sun.com/doc/819-2255/tran-tgt-free-9e?a=view"><tt>tran_tgt_free</tt>(9E)</a> entry point enables the HBA to perform any deallocation or clean-up
procedures for an instance of a target. This entry point is optional.</p><pre>static void
isp_tran_tgt_free(
    dev_info_t            *hba_dip,
    dev_info_t            *tgt_dip,
    scsi_hba_tran_t       *hba_tran,
    struct scsi_device    *sd)
{
    /*
     * Undo any special per-target initialization done
     * earlier in tran_tgt_init(9F) and tran_tgt_probe(9F)
     */
}</pre>

<a name="scsihba-56"></a><h4>Resource Allocation</h4>
<p>The following sections discuss resource allocation.</p>

<a name="scsihba-57"></a><h5><tt>tran_init_pkt()</tt> Entry Point</h5>
<p><a name="indexterm-629"></a><a name="indexterm-630"></a><a name="indexterm-631"></a>The <a href="http://docs.sun.com/doc/819-2255/tran-init-pkt-9e?a=view"><tt>tran_init_pkt</tt>(9E)</a> entry point allocates and initializes a <a href="http://docs.sun.com/doc/819-2257/scsi-pkt-9s?a=view"><tt>scsi_pkt</tt>(9S)</a> structure and DMA resources for
a target driver request.</p><p>The  <a href="http://docs.sun.com/doc/819-2255/tran-init-pkt-9e?a=view"><tt>tran_init_pkt</tt>(9E)</a> entry point is called when the target driver calls the
SCSA function  <a href="http://docs.sun.com/doc/819-2256/scsi-init-pkt-9f?a=view"><tt>scsi_init_pkt</tt>(9F)</a>.</p><p>Each call of the  <a href="http://docs.sun.com/doc/819-2255/tran-init-pkt-9e?a=view"><tt>tran_init_pkt</tt>(9E)</a> entry point is a request to
perform one or more of three possible services:</p>
<ul><li><p>Allocation and initialization of a <a href="http://docs.sun.com/doc/819-2257/scsi-pkt-9s?a=view"><tt>scsi_pkt</tt>(9S)</a> structure</p></li>
<li><p>Allocation of DMA resources for data transfer</p></li>
<li><p>Reallocation of DMA resources for the next portion of the data transfer</p></li></ul>


<a name="scsihba-58"></a><h5>Allocation and Initialization of a <tt>scsi_pkt</tt>(9S) Structure</h5>
<p>The  <a href="http://docs.sun.com/doc/819-2255/tran-init-pkt-9e?a=view"><tt>tran_init_pkt</tt>(9E)</a> entry point must allocate a <a href="http://docs.sun.com/doc/819-2257/scsi-pkt-9s?a=view"><tt>scsi_pkt</tt>(9S)</a> structure through <a href="http://docs.sun.com/doc/819-2256/scsi-hba-pkt-alloc-9f?a=view"><tt>scsi_hba_pkt_alloc</tt>(9F)</a>
if <tt>pkt</tt> is <tt>NULL</tt>.</p><p><a name="indexterm-632"></a><a href="http://docs.sun.com/doc/819-2256/scsi-hba-pkt-alloc-9f?a=view"><tt>scsi_hba_pkt_alloc</tt>(9F)</a> allocates space for the following items:</p>
<ul><li><p><a href="http://docs.sun.com/doc/819-2257/scsi-pkt-9s?a=view"><tt>scsi_pkt</tt>(9S)</a></p></li>
<li><p>SCSI CDB of length <tt>cmdlen</tt></p></li>
<li><p>Completion area for SCSI status of length <tt>statuslen</tt></p></li>
<li><p>Per-packet target driver private data area of length <tt>tgtlen</tt></p></li>
<li><p>Per-packet HBA driver private data area of length <tt>hbalen</tt></p></li></ul>
<p>The <a href="http://docs.sun.com/doc/819-2257/scsi-pkt-9s?a=view"><tt>scsi_pkt</tt>(9S)</a> structure members, including <tt>pkt</tt>, must be initialized to zero except for the
following members:</p>
<ul><li><p><tt>pkt_scbp</tt> &ndash; Status completion</p></li>
<li><p><tt>pkt_cdbp</tt> &ndash; CDB</p></li>
<li><p><tt>pkt_ha_private</tt> &ndash; HBA driver private data</p></li>
<li><p><tt>pkt_private</tt> &ndash; Target driver private data</p></li></ul>
<p>These members are pointers to memory space where the values of the
fields are stored, as shown in the following figure. For more information, refer to
<a href="scsihba-16.html#scsihba-23"><tt>scsi_pkt</tt> Structure (HBA)</a>.</p><a name="scsihba-fig-59"></a><h6>Figure&nbsp;18-5 <tt>scsi_pkt</tt>(9S) Structure Pointers</h6><img src="figures/scsihba.structptrs.gif" alt="Diagram shows the scsi_pkt structure with those members that point to values rather than being initialized to zero."></img><p>The following example shows allocation and initialization of a <tt>scsi_pkt</tt> structure.</p><a name="scsihba-ex-61"></a><h6>Example&nbsp;18-2 HBA Driver Initialization of a SCSI Packet Structure</h6><pre>static struct scsi_pkt                 *
isp_scsi_init_pkt(
    struct scsi_address    *ap,
    struct scsi_pkt        *pkt,
    struct buf             *bp,
    int                    cmdlen,
    int                    statuslen,
    int                    tgtlen,
    int                    flags,
    int                    (*callback)(),
    caddr_t                arg)
{
    struct isp_cmd         *sp;
    struct isp             *isp;
    struct scsi_pkt        *new_pkt;

    ASSERT(callback == NULL_FUNC || callback == SLEEP_FUNC);

    isp = (struct isp *)ap-&gt;a_hba_tran-&gt;tran_hba_private;
    /*
     * First step of isp_scsi_init_pkt:  pkt allocation
     */
    if (pkt == NULL) {
        pkt = scsi_hba_pkt_alloc(isp-&gt;isp_dip, ap, cmdlen,
            statuslen, tgtlen, sizeof (struct isp_cmd),
            callback, arg);
        if (pkt == NULL) {
            return (NULL);
        }

        sp = (struct isp_cmd *)pkt-&gt;pkt_ha_private;
        /*
         * Initialize the new pkt
         */
        sp-&gt;cmd_pkt         = pkt;
        sp-&gt;cmd_flags       = 0;
        sp-&gt;cmd_scblen      = statuslen;
        sp-&gt;cmd_cdblen      = cmdlen;
        sp-&gt;cmd_dmahandle   = NULL;
        sp-&gt;cmd_ncookies    = 0;
        sp-&gt;cmd_cookie      = 0; 
        sp-&gt;cmd_cookiecnt   = 0;
        sp-&gt;cmd_nwin        = 0;
        pkt-&gt;pkt_address    = *ap;
        pkt-&gt;pkt_comp       = (void (*)())NULL;
        pkt-&gt;pkt_flags      = 0;
        pkt-&gt;pkt_time       = 0;
        pkt-&gt;pkt_resid      = 0;
        pkt-&gt;pkt_statistics = 0;
        pkt-&gt;pkt_reason     = 0;
        new_pkt = pkt;
    } else {
        sp = (struct isp_cmd *)pkt-&gt;pkt_ha_private;
        new_pkt = NULL;
    }
    /*
     * Second step of isp_scsi_init_pkt:  dma allocation/move
     */
    if (bp &amp;&amp; bp-&gt;b_bcount != 0) {
        if (sp-&gt;cmd_dmahandle == NULL) {
            if (isp_i_dma_alloc(isp, pkt, bp, flags, callback) == 0) {
                if (new_pkt) {
                    scsi_hba_pkt_free(ap, new_pkt);
                }
                return ((struct scsi_pkt *)NULL);
            }
        } else {
            ASSERT(new_pkt == NULL);
            if (isp_i_dma_move(isp, pkt, bp) == 0) {
                return ((struct scsi_pkt *)NULL);
            }
        }
    }
    return (pkt);
}</pre>

<a name="scsihba-62"></a><h5>Allocation of DMA Resources</h5>
<p>The  <a href="http://docs.sun.com/doc/819-2255/tran-init-pkt-9e?a=view"><tt>tran_init_pkt</tt>(9E)</a> entry point must allocate DMA resources for a data transfer
if the following conditions are true:</p>
<ul><li><p><tt>bp</tt> is not null.</p></li>
<li><p><tt>bp-&gt;b_bcount</tt> is not zero.</p></li>
<li><p>DMA resources have not yet been allocated for this <a href="http://docs.sun.com/doc/819-2257/scsi-pkt-9s?a=view"><tt>scsi_pkt</tt>(9S)</a>.</p></li></ul>
<p><a name="indexterm-633"></a>The HBA driver needs to track how DMA resources are allocated for a
particular command. This allocation can take place with a flag bit or a
DMA handle in the per-packet HBA driver private data.</p><p>The <tt>PKT_DMA_PARTIAL</tt> flag in the <tt>pkt</tt> enables the target driver to break up
a data transfer into multiple SCSI commands to accommodate the complete request. This
approach is useful when the HBA hardware scatter-gather capabilities or system DMA resources
cannot complete a request in a single SCSI command.</p><p>The <tt>PKT_DMA_PARTIAL</tt> flag enables the HBA driver to set the <tt>DDI_DMA_PARTIAL</tt> flag. The
<tt>DDI_DMA_PARTIAL</tt> flag is useful when the DMA resources for this SCSI command are
allocated. For example the <a href="http://docs.sun.com/doc/819-2256/ddi-dma-buf-bind-handle-9f?a=view"><tt>ddi_dma_buf_bind_handle</tt>(9F)</a>) command can be used to allocate DMA resources.
The DMA attributes used when allocating the DMA resources should accurately describe any constraints
placed on the ability of the HBA hardware to perform DMA. If the
system can only allocate DMA resources for part of the request, 
<a href="http://docs.sun.com/doc/819-2256/ddi-dma-buf-bind-handle-9f?a=view"><tt>ddi_dma_buf_bind_handle</tt>(9F)</a> returns <tt>DDI_DMA_PARTIAL_MAP</tt>. </p><p>The  <a href="http://docs.sun.com/doc/819-2255/tran-init-pkt-9e?a=view"><tt>tran_init_pkt</tt>(9E)</a> entry point must return the amount of DMA resources not
allocated for this transfer in the field <tt>pkt_resid</tt>. </p><p>A target driver can make one request to  <a href="http://docs.sun.com/doc/819-2255/tran-init-pkt-9e?a=view"><tt>tran_init_pkt</tt>(9E)</a> to simultaneously
allocate both a <a href="http://docs.sun.com/doc/819-2257/scsi-pkt-9s?a=view"><tt>scsi_pkt</tt>(9S)</a> structure and DMA resources for that <tt>pkt</tt>. In this case,
if the HBA driver is unable to allocate DMA resources, that driver must
free the allocated <a href="http://docs.sun.com/doc/819-2257/scsi-pkt-9s?a=view"><tt>scsi_pkt</tt>(9S)</a> before returning. The <a href="http://docs.sun.com/doc/819-2257/scsi-pkt-9s?a=view"><tt>scsi_pkt</tt>(9S)</a> must be freed by calling 
<a href="http://docs.sun.com/doc/819-2256/scsi-hba-pkt-free-9f?a=view"><tt>scsi_hba_pkt_free</tt>(9F)</a>.</p><p>The target driver might first allocate the <a href="http://docs.sun.com/doc/819-2257/scsi-pkt-9s?a=view"><tt>scsi_pkt</tt>(9S)</a> and allocate DMA resources for
this <tt>pkt</tt> at a later time. In this case, if the HBA driver
is unable to allocate DMA resources, the driver must <b>not</b> free <tt>pkt</tt>.
The target driver in this case is responsible for freeing the <tt>pkt</tt>.</p><a name="scsihba-ex-63"></a><h6>Example&nbsp;18-3 HBA Driver Allocation of DMA Resources</h6><pre>static int
isp_i_dma_alloc(
    struct isp         *isp,
    struct scsi_pkt    *pkt,
    struct buf         *bp,
    int                flags,
    int                (*callback)())
{
    struct isp_cmd     *sp  = (struct isp_cmd *)pkt-&gt;pkt_ha_private;
    int                dma_flags;
    ddi_dma_attr_t     tmp_dma_attr;
    int                (*cb)(caddr_t);
    int                i;

    ASSERT(callback == NULL_FUNC || callback == SLEEP_FUNC);

    if (bp-&gt;b_flags &amp; B_READ) {
        sp-&gt;cmd_flags &amp;= ~CFLAG_DMASEND;
        dma_flags = DDI_DMA_READ;
    } else {
        sp-&gt;cmd_flags |= CFLAG_DMASEND;
        dma_flags = DDI_DMA_WRITE;
    }
    if (flags &amp; PKT_CONSISTENT) {
        sp-&gt;cmd_flags |= CFLAG_CMDIOPB;
        dma_flags |= DDI_DMA_CONSISTENT;
    }
    if (flags &amp; PKT_DMA_PARTIAL) {
        dma_flags |= DDI_DMA_PARTIAL;
    }

    tmp_dma_attr = isp_dma_attr;
    tmp_dma_attr.dma_attr_burstsizes = isp-&gt;isp_burst_size;

    cb = (callback == NULL_FUNC) ? DDI_DMA_DONTWAIT : DDI_DMA_SLEEP;

    if ((i = ddi_dma_alloc_handle(isp-&gt;isp_dip, &amp;tmp_dma_attr,
      cb, 0, &amp;sp-&gt;cmd_dmahandle)) != DDI_SUCCESS) {
        switch (i) {
          case DDI_DMA_BADATTR:
              bioerror(bp, EFAULT);
              return (0);
          case DDI_DMA_NORESOURCES:
              bioerror(bp, 0);
              return (0);
        }
    }

    i = ddi_dma_buf_bind_handle(sp-&gt;cmd_dmahandle, bp, dma_flags,
    cb, 0, &amp;sp-&gt;cmd_dmacookies[0], &amp;sp-&gt;cmd_ncookies);

    switch (i) {
      case DDI_DMA_PARTIAL_MAP:
          if (ddi_dma_numwin(sp-&gt;cmd_dmahandle, &amp;sp-&gt;cmd_nwin) == DDI_FAILURE) {
              cmn_err(CE_PANIC, "ddi_dma_numwin() failed\n");
          }

          if (ddi_dma_getwin(sp-&gt;cmd_dmahandle, sp-&gt;cmd_curwin,
            &amp;sp-&gt;cmd_dma_offset, &amp;sp-&gt;cmd_dma_len, &amp;sp-&gt;cmd_dmacookies[0], 
            &amp;sp-&gt;cmd_ncookies) == DDI_FAILURE) {
              cmn_err(CE_PANIC, "ddi_dma_getwin() failed\n");
          }
          goto get_dma_cookies;

      case DDI_DMA_MAPPED:
          sp-&gt;cmd_nwin = 1;
          sp-&gt;cmd_dma_len = 0;
          sp-&gt;cmd_dma_offset = 0;

      get_dma_cookies:
          i = 0;
          sp-&gt;cmd_dmacount = 0;
          for (;;) {
              sp-&gt;cmd_dmacount += sp-&gt;cmd_dmacookies[i++].dmac_size;
              if (i == ISP_NDATASEGS || i == sp-&gt;cmd_ncookies)
                  break;
              ddi_dma_nextcookie(sp-&gt;cmd_dmahandle,
              &amp;sp-&gt;cmd_dmacookies[i]);
          }
          sp-&gt;cmd_cookie = i;
          sp-&gt;cmd_cookiecnt = i;
          sp-&gt;cmd_flags |= CFLAG_DMAVALID;
          pkt-&gt;pkt_resid = bp-&gt;b_bcount - sp-&gt;cmd_dmacount;
          return (1);

      case DDI_DMA_NORESOURCES:
          bioerror(bp, 0);
          break;

      case DDI_DMA_NOMAPPING:
          bioerror(bp, EFAULT);
          break;

      case DDI_DMA_TOOBIG:
          bioerror(bp, EINVAL);
          break;

      case DDI_DMA_INUSE:
          cmn_err(CE_PANIC, "ddi_dma_buf_bind_handle:"
            " DDI_DMA_INUSE impossible\n");

      default:
          cmn_err(CE_PANIC, "ddi_dma_buf_bind_handle:"
            " 0x%x impossible\n", i);
    }
    ddi_dma_free_handle(&amp;sp-&gt;cmd_dmahandle);
    sp-&gt;cmd_dmahandle = NULL;
    sp-&gt;cmd_flags &amp;= ~CFLAG_DMAVALID;
    return (0);
}</pre>

<a name="scsihba-64"></a><h5>Reallocation of DMA Resources for Data Transfer</h5>
<p>For a previously allocated packet with data remaining to be transferred, the 
<a href="http://docs.sun.com/doc/819-2255/tran-init-pkt-9e?a=view"><tt>tran_init_pkt</tt>(9E)</a> entry point must reallocate DMA resources when the following conditions apply:</p>
<ul><li><p>Partial DMA resources have already been allocated.</p></li>
<li><p>A non-zero <tt>pkt_resid</tt> was returned in the previous call to <a href="http://docs.sun.com/doc/819-2255/tran-init-pkt-9e?a=view"><tt>tran_init_pkt</tt>(9E)</a>.</p></li>
<li><p><tt>bp</tt> is not null.</p></li>
<li><p><tt>bp-&gt;b_bcount</tt> is not zero.</p></li></ul>
<p>When reallocating DMA resources to the next portion of the transfer,  <a href="http://docs.sun.com/doc/819-2255/tran-init-pkt-9e?a=view"><tt>tran_init_pkt</tt>(9E)</a>
 must return the amount of DMA resources not allocated for this transfer
in the field <tt>pkt_resid</tt>.</p><p>If an error occurs while attempting to move DMA resources, <a href="http://docs.sun.com/doc/819-2255/tran-init-pkt-9e?a=view"><tt>tran_init_pkt</tt>(9E)</a> must
not free the <a href="http://docs.sun.com/doc/819-2257/scsi-pkt-9s?a=view"><tt>scsi_pkt</tt>(9S)</a>. The target driver in this case is responsible for freeing
the packet.</p><p>If the callback parameter is <tt>NULL_FUNC</tt>, the  <a href="http://docs.sun.com/doc/819-2255/tran-init-pkt-9e?a=view"><tt>tran_init_pkt</tt>(9E)</a> entry point must not
sleep or call any function that might sleep. If the callback parameter is
<tt>SLEEP_FUNC</tt> and resources are not immediately available, the  <a href="http://docs.sun.com/doc/819-2255/tran-init-pkt-9e?a=view"><tt>tran_init_pkt</tt>(9E)</a> entry point should
sleep. Unless the request is impossible to satisfy, <tt>tran_init_pkt()</tt> should sleep until resources become
available.</p><a name="scsihba-ex-65"></a><h6>Example&nbsp;18-4 DMA Resource Reallocation for HBA Drivers</h6><pre>static int
isp_i_dma_move(
    struct isp         *isp,
    struct scsi_pkt    *pkt,
    struct buf         *bp)
{
    struct isp_cmd     *sp  = (struct isp_cmd *)pkt-&gt;pkt_ha_private;
    int                i;

    ASSERT(sp-&gt;cmd_flags &amp; CFLAG_COMPLETED);
    sp-&gt;cmd_flags &amp;= ~CFLAG_COMPLETED;
    /*
     * If there are no more cookies remaining in this window,
     * must move to the next window first.
     */
    if (sp-&gt;cmd_cookie == sp-&gt;cmd_ncookies) {
        /*
         * For small pkts, leave things where they are
         */
        if (sp-&gt;cmd_curwin == sp-&gt;cmd_nwin &amp;&amp; sp-&gt;cmd_nwin == 1)
            return (1);
        /*
         * At last window, cannot move
         */
        if (++sp-&gt;cmd_curwin &gt;= sp-&gt;cmd_nwin)
            return (0);
        if (ddi_dma_getwin(sp-&gt;cmd_dmahandle, sp-&gt;cmd_curwin,
          &amp;sp-&gt;cmd_dma_offset, &amp;sp-&gt;cmd_dma_len,
          &amp;sp-&gt;cmd_dmacookies[0], &amp;sp-&gt;cmd_ncookies) == DDI_FAILURE)
            return (0);
        sp-&gt;cmd_cookie = 0;
    } else {
        /*
         * Still more cookies in this window - get the next one
         */
        ddi_dma_nextcookie(sp-&gt;cmd_dmahandle, &amp;sp-&gt;cmd_dmacookies[0]);
    }
    /*
     * Get remaining cookies in this window, up to our maximum
     */
    i = 0;
    for (;;) {
        sp-&gt;cmd_dmacount += sp-&gt;cmd_dmacookies[i++].dmac_size;
        sp-&gt;cmd_cookie++;
        if (i == ISP_NDATASEGS || sp-&gt;cmd_cookie == sp-&gt;cmd_ncookies)
            break;
        ddi_dma_nextcookie(sp-&gt;cmd_dmahandle, &amp;sp-&gt;cmd_dmacookies[i]);
    }
    sp-&gt;cmd_cookiecnt = i;
    pkt-&gt;pkt_resid = bp-&gt;b_bcount - sp-&gt;cmd_dmacount;
    return (1);
}</pre>

<a name="scsihba-66"></a><h5><tt>tran_destroy_pkt()</tt> Entry Point</h5>
<p><a name="indexterm-634"></a>The <a href="http://docs.sun.com/doc/819-2255/tran-destroy-pkt-9e?a=view"><tt>tran_destroy_pkt</tt>(9E)</a> entry point is the HBA driver function that deallocates <a href="http://docs.sun.com/doc/819-2257/scsi-pkt-9s?a=view"><tt>scsi_pkt</tt>(9S)</a>
structures. The <tt>tran_destroy_pkt()</tt> entry point is called when the target driver calls <a href="http://docs.sun.com/doc/819-2256/scsi-destroy-pkt-9f?a=view"><tt>scsi_destroy_pkt</tt>(9F)</a>.</p><p><a name="indexterm-635"></a>The <tt>tran_destroy_pkt()</tt> entry point must free any DMA resources that have been allocated
for the packet. An implicit DMA synchronization occurs if the DMA resources are
freed and any cached data remains after the completion of the transfer. The
<tt>tran_destroy_pkt()</tt> entry point frees the SCSI packet by calling  <a href="http://docs.sun.com/doc/819-2256/scsi-hba-pkt-free-9f?a=view"><tt>scsi_hba_pkt_free</tt>(9F)</a>.</p><a name="scsihba-ex-67"></a><h6>Example&nbsp;18-5 HBA Driver <tt>tran_destroy_pkt</tt>(9E) Entry Point</h6><pre>static void
isp_scsi_destroy_pkt(
    struct scsi_address    *ap,
    struct scsi_pkt    *pkt)
{
    struct isp_cmd *sp = (struct isp_cmd *)pkt-&gt;pkt_ha_private;
    /*
     * Free the DMA, if any
     */
    if (sp-&gt;cmd_flags &amp; CFLAG_DMAVALID) {
        sp-&gt;cmd_flags &amp;= ~CFLAG_DMAVALID;
        (void) ddi_dma_unbind_handle(sp-&gt;cmd_dmahandle);
        ddi_dma_free_handle(&amp;sp-&gt;cmd_dmahandle);
        sp-&gt;cmd_dmahandle = NULL;
    }
    /*
     * Free the pkt
     */
    scsi_hba_pkt_free(ap, pkt);
}</pre>

<a name="scsihba-68"></a><h5><tt>tran_sync_pkt()</tt> Entry Point</h5>
<p><a name="indexterm-636"></a><a name="indexterm-637"></a>The <a href="http://docs.sun.com/doc/819-2255/tran-sync-pkt-9e?a=view"><tt>tran_sync_pkt</tt>(9E)</a> entry point synchronizes the DMA object allocated for the <a href="http://docs.sun.com/doc/819-2257/scsi-pkt-9s?a=view"><tt>scsi_pkt</tt>(9S)</a> structure before
or after a DMA transfer. The <tt>tran_sync_pkt()</tt> entry point is called when the
target driver calls  <a href="http://docs.sun.com/doc/819-2256/scsi-sync-pkt-9f?a=view"><tt>scsi_sync_pkt</tt>(9F)</a>.</p><p>If the data transfer direction is a DMA read from device to
memory, <tt>tran_sync_pkt()</tt> must synchronize the CPU's view of the data. If the data
transfer direction is a DMA write from memory to device, <tt>tran_sync_pkt()</tt> must
synchronize the device's view of the data.</p><a name="scsihba-ex-69"></a><h6>Example&nbsp;18-6 HBA Driver <tt>tran_sync_pkt</tt>(9E) Entry Point</h6><pre>static void
isp_scsi_sync_pkt(
    struct scsi_address    *ap,
    struct scsi_pkt        *pkt)
{
    struct isp_cmd *sp = (struct isp_cmd *)pkt-&gt;pkt_ha_private;

    if (sp-&gt;cmd_flags &amp; CFLAG_DMAVALID) {
        (void)ddi_dma_sync(sp-&gt;cmd_dmahandle, sp-&gt;cmd_dma_offset,
        sp-&gt;cmd_dma_len,
        (sp-&gt;cmd_flags &amp; CFLAG_DMASEND) ?
        DDI_DMA_SYNC_FORDEV : DDI_DMA_SYNC_FORCPU);
    }
}</pre>

<a name="scsihba-70"></a><h5><tt>tran_dmafree()</tt> Entry Point</h5>
<p><a name="indexterm-638"></a><a name="indexterm-639"></a>The <a href="http://docs.sun.com/doc/819-2255/tran-dmafree-9e?a=view"><tt>tran_dmafree</tt>(9E)</a> entry point deallocates DMA resources that have been allocated for a
<a href="http://docs.sun.com/doc/819-2257/scsi-pkt-9s?a=view"><tt>scsi_pkt</tt>(9S)</a> structure. The <tt>tran_dmafree()</tt> entry point is called when the target driver calls 
<a href="http://docs.sun.com/doc/819-2256/scsi-dmafree-9f?a=view"><tt>scsi_dmafree</tt>(9F)</a>.</p><p><tt>tran_dmafree()</tt> must free only DMA resources allocated for a <a href="http://docs.sun.com/doc/819-2257/scsi-pkt-9s?a=view"><tt>scsi_pkt</tt>(9S)</a> structure, not the <a href="http://docs.sun.com/doc/819-2257/scsi-pkt-9s?a=view"><tt>scsi_pkt</tt>(9S)</a>
itself. When DMA resources are freed,  a DMA synchronization is implicitly performed.</p>
<hr><p><b>Note - </b>The <a href="http://docs.sun.com/doc/819-2257/scsi-pkt-9s?a=view"><tt>scsi_pkt</tt>(9S)</a> is freed in a separate request to  <a href="http://docs.sun.com/doc/819-2255/tran-destroy-pkt-9e?a=view"><tt>tran_destroy_pkt</tt>(9E)</a>. Because 
<tt>tran_destroy_pkt()</tt> must also free DMA resources, the HBA driver must keep accurate note
of whether <tt>scsi_pkt()</tt> structures have DMA resources allocated.</p>
<hr>
<a name="scsihba-ex-71"></a><h6>Example&nbsp;18-7 HBA Driver <tt>tran_dmafree</tt>(9E) Entry Point</h6><pre>static void
isp_scsi_dmafree(
    struct scsi_address    *ap,
    struct scsi_pkt        *pkt)
{
    struct isp_cmd    *sp = (struct isp_cmd *)pkt-&gt;pkt_ha_private;

    if (sp-&gt;cmd_flags &amp; CFLAG_DMAVALID) {
        sp-&gt;cmd_flags &amp;= ~CFLAG_DMAVALID;
        (void)ddi_dma_unbind_handle(sp-&gt;cmd_dmahandle);
        ddi_dma_free_handle(&amp;sp-&gt;cmd_dmahandle);
        sp-&gt;cmd_dmahandle = NULL;
    }
}</pre>

<a name="scsihba-72"></a><h4>Command Transport</h4>
<p>An HBA driver goes through the following steps as part of command
transport:</p>
<ol><li><p>Accept a command from the target driver.</p></li>
<li><p>Issue the command to the device hardware.</p></li>
<li><p>Service any interrupts that occur.</p></li>
<li><p><a name="indexterm-640"></a>Manage time outs.</p></li></ol>


<a name="scsihba-73"></a><h5><tt>tran_start()</tt> Entry Point</h5>
<p><a name="indexterm-641"></a><a name="indexterm-642"></a>The <a href="http://docs.sun.com/doc/819-2255/tran-start-9e?a=view"><tt>tran_start</tt>(9E)</a> entry point for a SCSI HBA driver is called to
transport a SCSI command to the addressed target. The SCSI command is described
entirely within the <a href="http://docs.sun.com/doc/819-2257/scsi-pkt-9s?a=view"><tt>scsi_pkt</tt>(9S)</a> structure, which the target driver allocated through the HBA driver's
 <a href="http://docs.sun.com/doc/819-2255/tran-init-pkt-9e?a=view"><tt>tran_init_pkt</tt>(9E)</a> entry point. If the command involves a data transfer, DMA resources
must also have been allocated for the <a href="http://docs.sun.com/doc/819-2257/scsi-pkt-9s?a=view"><tt>scsi_pkt</tt>(9S)</a> structure.</p><p>The <tt>tran_start()</tt> entry point is called when a target driver calls  <a href="http://docs.sun.com/doc/819-2256/scsi-transport-9f?a=view"><tt>scsi_transport</tt>(9F)</a>.</p><p><tt>tran_start()</tt> should perform basic error checking along with any initialization that is required
by the command. The <tt>FLAG_NOINTR</tt> flag in the <tt>pkt_flags</tt> field of the
<a href="http://docs.sun.com/doc/819-2257/scsi-pkt-9s?a=view"><tt>scsi_pkt</tt>(9S)</a> structure can affect the behavior of <tt>tran_start()</tt>. If <tt>FLAG_NOINTR</tt> is not set,
<tt>tran_start()</tt> must queue the command for execution on the  hardware and return
immediately. Upon completion of the command,  the HBA driver should call the
<tt>pkt</tt> completion routine.</p><p>If the <tt>FLAG_NOINTR</tt> is set, then the HBA driver should not call the
<tt>pkt</tt> completion routine.</p><p>The following example demonstrates how to handle the  <a href="http://docs.sun.com/doc/819-2255/tran-start-9e?a=view"><tt>tran_start</tt>(9E)</a> entry point. The
ISP hardware provides a queue per-target device. For devices that can manage only
one active outstanding command, the driver is typically required to manage a per-target
queue. The driver then starts up a new command upon completion of the
current command in a round-robin fashion.</p><a name="scsihba-ex-74"></a><h6>Example&nbsp;18-8 HBA Driver <tt>tran_start</tt>(9E) Entry Point</h6><pre>static int
isp_scsi_start(
    struct scsi_address    *ap,
    struct scsi_pkt        *pkt)
{
    struct isp_cmd         *sp;
    struct isp             *isp;
    struct isp_request     *req;
    u_long                 cur_lbolt;
    int                    xfercount;
    int                    rval = TRAN_ACCEPT;
    int                    i;

    sp = (struct isp_cmd *)pkt-&gt;pkt_ha_private;
    isp = (struct isp *)ap-&gt;a_hba_tran-&gt;tran_hba_private;

    sp-&gt;cmd_flags = (sp-&gt;cmd_flags &amp; ~CFLAG_TRANFLAG) |
                CFLAG_IN_TRANSPORT;
    pkt-&gt;pkt_reason = CMD_CMPLT;
    /*
     * set up request in cmd_isp_request area so it is ready to
     * go once we have the request mutex
     */
    req = &amp;sp-&gt;cmd_isp_request;

    req-&gt;req_header.cq_entry_type = CQ_TYPE_REQUEST;
    req-&gt;req_header.cq_entry_count = 1;
    req-&gt;req_header.cq_flags        = 0;
    req-&gt;req_header.cq_seqno = 0;
    req-&gt;req_reserved = 0;
    req-&gt;req_token = (opaque_t)sp;
    req-&gt;req_target = TGT(sp);
    req-&gt;req_lun_trn = LUN(sp);
    req-&gt;req_time = pkt-&gt;pkt_time;
    ISP_SET_PKT_FLAGS(pkt-&gt;pkt_flags, req-&gt;req_flags);
    /*
     * Set up data segments for dma transfers.
     */
    if (sp-&gt;cmd_flags &amp; CFLAG_DMAVALID) {
        if (sp-&gt;cmd_flags &amp; CFLAG_CMDIOPB) {
            (void) ddi_dma_sync(sp-&gt;cmd_dmahandle,
            sp-&gt;cmd_dma_offset, sp-&gt;cmd_dma_len,
            DDI_DMA_SYNC_FORDEV);
        }

        ASSERT(sp-&gt;cmd_cookiecnt &gt; 0 &amp;&amp;
            sp-&gt;cmd_cookiecnt &lt;= ISP_NDATASEGS);

        xfercount = 0;
        req-&gt;req_seg_count = sp-&gt;cmd_cookiecnt;
        for (i = 0; i &lt; sp-&gt;cmd_cookiecnt; i++) {
            req-&gt;req_dataseg[i].d_count =
            sp-&gt;cmd_dmacookies[i].dmac_size;
            req-&gt;req_dataseg[i].d_base =
            sp-&gt;cmd_dmacookies[i].dmac_address;
            xfercount +=
            sp-&gt;cmd_dmacookies[i].dmac_size;
        }

        for (; i &lt; ISP_NDATASEGS; i++) {
            req-&gt;req_dataseg[i].d_count = 0;
            req-&gt;req_dataseg[i].d_base = 0;
        }

        pkt-&gt;pkt_resid = xfercount;

        if (sp-&gt;cmd_flags &amp; CFLAG_DMASEND) {
            req-&gt;req_flags |= ISP_REQ_FLAG_DATA_WRITE;
        } else {
            req-&gt;req_flags |= ISP_REQ_FLAG_DATA_READ;
        }
    } else {
        req-&gt;req_seg_count = 0;
        req-&gt;req_dataseg[0].d_count = 0;
    }
    /*
     * Set up cdb in the request
     */
    req-&gt;req_cdblen = sp-&gt;cmd_cdblen;
    bcopy((caddr_t)pkt-&gt;pkt_cdbp, (caddr_t)req-&gt;req_cdb,
    sp-&gt;cmd_cdblen);
    /*
     * Start the cmd.  If NO_INTR, must poll for cmd completion.
     */
    if ((pkt-&gt;pkt_flags &amp; FLAG_NOINTR) == 0) {
        mutex_enter(ISP_REQ_MUTEX(isp));
        rval = isp_i_start_cmd(isp, sp);
        mutex_exit(ISP_REQ_MUTEX(isp));
    } else {
        rval = isp_i_polled_cmd_start(isp, sp);
    }
    return (rval);
}</pre>

<a name="scsihba-75"></a><h5>Interrupt Handler and Command Completion</h5>
<p><a name="indexterm-643"></a>The interrupt handler must check the status of the device to be sure
the device is generating the interrupt in question. The interrupt handler must also
check for any errors that have occurred and service any interrupts generated by
the device.</p><p>If data is transferred, the hardware should be checked to determine how much
data was actually transferred. The <tt>pkt_resid</tt> field in the <a href="http://docs.sun.com/doc/819-2257/scsi-pkt-9s?a=view"><tt>scsi_pkt</tt>(9S)</a> structure should be set
to the residual of the transfer.</p><p>Commands that are marked with the <tt>PKT_CONSISTENT</tt> flag when DMA resources are allocated
through  <a href="http://docs.sun.com/doc/819-2255/tran-init-pkt-9e?a=view"><tt>tran_init_pkt</tt>(9E)</a> take special handling. The HBA driver must ensure that the
data transfer for the command is correctly synchronized before the target driver's command
completion callback is performed.</p><p>Once a command has completed, you need to act on two requirements:</p>
<ul><li><p>If a new command is queued up, start the command on the hardware as quickly as possible.</p></li>
<li><p>Call the command completion callback. The callback has been set up in the <a href="http://docs.sun.com/doc/819-2257/scsi-pkt-9s?a=view"><tt>scsi_pkt</tt>(9S)</a> structure by the target driver to notify the target driver when the command is complete.</p></li></ul>
<p>Start a new command on the hardware, if possible, before calling the
<tt>PKT_COMP</tt> command completion callback. The command completion handling can take considerable time. Typically,
the target driver calls functions such as  <a href="http://docs.sun.com/doc/819-2256/biodone-9f?a=view"><tt>biodone</tt>(9F)</a> and possibly  <a href="http://docs.sun.com/doc/819-2256/scsi-transport-9f?a=view"><tt>scsi_transport</tt>(9F)</a> to
begin a new command.</p><p>The interrupt handler must return <tt>DDI_INTR_CLAIMED</tt> if this interrupt is claimed by this
driver. Otherwise, the handler returns <tt>DDI_INTR_UNCLAIMED</tt>.</p><p>The following example shows an interrupt handler for the SCSI HBA <tt>isp</tt>
driver. The <tt>caddr_t</tt> parameter is set up when the interrupt handler is added
in  <a href="http://docs.sun.com/doc/819-2255/attach-9e?a=view"><tt>attach</tt>(9E)</a>. This parameter is typically a pointer to the state structure,
which is allocated on a per instance basis.</p><a name="scsihba-ex-76"></a><h6>Example&nbsp;18-9 HBA Driver Interrupt Handler</h6><pre>static u_int
isp_intr(caddr_t arg)
{
    struct isp_cmd         *sp;
    struct isp_cmd         *head, *tail;
    u_short                response_in;
    struct isp_response    *resp;
    struct isp             *isp = (struct isp *)arg;
    struct isp_slot        *isp_slot;
    int                    n;

    if (ISP_INT_PENDING(isp) == 0) {
        return (DDI_INTR_UNCLAIMED);
    }

    do {
again:
        /*
         * head list collects completed packets for callback later
         */
        head = tail = NULL;
        /*
         * Assume no mailbox events (e.g., mailbox cmds, asynch
         * events, and isp dma errors) as common case.
         */
        if (ISP_CHECK_SEMAPHORE_LOCK(isp) == 0) {
            mutex_enter(ISP_RESP_MUTEX(isp));
            /*
             * Loop through completion response queue and post
             * completed pkts.  Check response queue again
             * afterwards in case there are more.
             */
            isp-&gt;isp_response_in =
            response_in = ISP_GET_RESPONSE_IN(isp);
            /*
             * Calculate the number of requests in the queue
             */
            n = response_in - isp-&gt;isp_response_out;
            if (n &lt; 0) {
                n = ISP_MAX_REQUESTS -
                isp-&gt;isp_response_out + response_in;
            }
            while (n-- &gt; 0) {
                ISP_GET_NEXT_RESPONSE_OUT(isp, resp);
                sp = (struct isp_cmd *)resp-&gt;resp_token;
                /*
                 * Copy over response packet in sp
                 */
                isp_i_get_response(isp, resp, sp);
            }
            if (head) {
                tail-&gt;cmd_forw = sp;
                tail = sp;
                tail-&gt;cmd_forw = NULL;
            } else {
                tail = head = sp;
                sp-&gt;cmd_forw = NULL;
            }
            ISP_SET_RESPONSE_OUT(isp);
            ISP_CLEAR_RISC_INT(isp);
            mutex_exit(ISP_RESP_MUTEX(isp));

            if (head) {
                isp_i_call_pkt_comp(isp, head);
            }
        } else {
            if (isp_i_handle_mbox_cmd(isp) != ISP_AEN_SUCCESS) {
                return (DDI_INTR_CLAIMED);
            }
            /*
             * if there was a reset then check the response
             * queue again
             */
            goto again;    
        }

    } while (ISP_INT_PENDING(isp));

    return (DDI_INTR_CLAIMED);
}

static void
isp_i_call_pkt_comp(
    struct isp             *isp,
    struct isp_cmd         *head)
{
    struct isp             *isp;
    struct isp_cmd         *sp;
    struct scsi_pkt        *pkt;
    struct isp_response    *resp;
    u_char                 status;

    while (head) {
        sp = head;
        pkt = sp-&gt;cmd_pkt;
        head = sp-&gt;cmd_forw;

        ASSERT(sp-&gt;cmd_flags &amp; CFLAG_FINISHED);

        resp = &amp;sp-&gt;cmd_isp_response;

        pkt-&gt;pkt_scbp[0] = (u_char)resp-&gt;resp_scb;
        pkt-&gt;pkt_state = ISP_GET_PKT_STATE(resp-&gt;resp_state);
        pkt-&gt;pkt_statistics = (u_long)
            ISP_GET_PKT_STATS(resp-&gt;resp_status_flags);
        pkt-&gt;pkt_resid = (long)resp-&gt;resp_resid;
        /*
         * If data was xferred and this is a consistent pkt,
         * do a dma sync
         */
        if ((sp-&gt;cmd_flags &amp; CFLAG_CMDIOPB) &amp;&amp;
            (pkt-&gt;pkt_state &amp; STATE_XFERRED_DATA)) {
                (void) ddi_dma_sync(sp-&gt;cmd_dmahandle,
                sp-&gt;cmd_dma_offset, sp-&gt;cmd_dma_len,
                DDI_DMA_SYNC_FORCPU);
        }

        sp-&gt;cmd_flags = (sp-&gt;cmd_flags &amp; ~CFLAG_IN_TRANSPORT) |
            CFLAG_COMPLETED;
        /*
         * Call packet completion routine if FLAG_NOINTR is not set.
         */
        if (((pkt-&gt;pkt_flags &amp; FLAG_NOINTR) == 0) &amp;&amp;
            pkt-&gt;pkt_comp) {
                (*pkt-&gt;pkt_comp)(pkt);
        }
    }
}</pre>

<a name="scsihba-77"></a><h5>Timeout Handler</h5>
<p><a name="indexterm-644"></a>The HBA driver is responsible for enforcing time outs. A command must be
complete within a specified time unless a zero time out has been
specified in the <a href="http://docs.sun.com/doc/819-2257/scsi-pkt-9s?a=view"><tt>scsi_pkt</tt>(9S)</a> structure.</p><p>When a command times out, the HBA driver should mark the <a href="http://docs.sun.com/doc/819-2257/scsi-pkt-9s?a=view"><tt>scsi_pkt</tt>(9S)</a>
with <tt>pkt_reason</tt> set to <tt>CMD_TIMEOUT</tt> and <tt>pkt_statistics</tt> OR'd with <tt>STAT_TIMEOUT</tt>. The HBA driver
should also attempt to recover the target and bus. If this recovery can
be performed successfully, the driver should mark the <a href="http://docs.sun.com/doc/819-2257/scsi-pkt-9s?a=view"><tt>scsi_pkt</tt>(9S)</a> using <tt>pkt_statistics</tt> OR'd with
either <tt>STAT_BUS_RESET</tt> or <tt>STAT_DEV_RESET</tt>.</p><p>After the recovery attempt has completed, the HBA driver should call the command
completion callback.</p>
<hr><p><b>Note - </b>If recovery was unsuccessful or not attempted, the target driver might attempt to
recover from the timeout by calling  <a href="http://docs.sun.com/doc/819-2256/scsi-reset-9f?a=view"><tt>scsi_reset</tt>(9F)</a>.</p>
<hr>
<p>The ISP hardware manages command timeout directly and returns timed-out commands with the
necessary status. The timeout handler for the <tt>isp</tt> sample driver checks active commands
for the time out state only once every 60 seconds.</p><p>The <tt>isp</tt> sample driver uses the  <a href="http://docs.sun.com/doc/819-2256/timeout-9f?a=view"><tt>timeout</tt>(9F)</a> facility to arrange for
the kernel to call the timeout handler every 60 seconds. The <tt>caddr_t</tt> argument is
the parameter set up when the timeout is initialized at  <a href="http://docs.sun.com/doc/819-2255/attach-9e?a=view"><tt>attach</tt>(9E)</a>
time. In this case, the <tt>caddr_t</tt> argument is a pointer to the
state structure allocated per driver instance.</p><p>If timed-out commands have not been returned as timed-out by the ISP hardware,
a problem has occurred. The hardware is not functioning correctly and needs to
be reset.</p>

<a name="scsihba-78"></a><h4>Capability Management</h4>
<p>The following sections discuss capability management.</p>

<a name="scsihba-79"></a><h5><tt>tran_getcap()</tt> Entry Point</h5>
<p><a name="indexterm-645"></a><a name="indexterm-646"></a><a name="indexterm-647"></a>The <a href="http://docs.sun.com/doc/819-2255/tran-getcap-9e?a=view"><tt>tran_getcap</tt>(9E)</a> entry point for a SCSI HBA driver is called by 
<a href="http://docs.sun.com/doc/819-2256/scsi-ifgetcap-9f?a=view"><tt>scsi_ifgetcap</tt>(9F)</a>. The target driver calls <tt>scsi_ifgetcap()</tt> to determine the current value of one
of a set of SCSA-defined capabilities.</p><p>The target driver can request the current setting of the capability for a
particular target by setting the <tt>whom</tt> parameter to nonzero. A <tt>whom</tt> value of
zero indicates a request for the current setting of the general capability for
the SCSI bus or for adapter hardware.</p><p>The <tt>tran_getcap()</tt> entry point should return <tt>-1</tt> for undefined capabilities or the current
value of the requested capability.</p><p><a name="indexterm-648"></a>The HBA driver can use the function  <a href="http://docs.sun.com/doc/819-2256/scsi-hba-lookup-capstr-9f?a=view"><tt>scsi_hba_lookup_capstr</tt>(9F)</a> to compare the capability
string against the canonical set of defined capabilities.</p><a name="scsihba-ex-80"></a><h6>Example&nbsp;18-10 HBA Driver <tt>tran_getcap</tt>(9E) Entry Point</h6><pre>static int
isp_scsi_getcap(
    struct scsi_address    *ap,
    char                   *cap,
    int                    whom)
{
    struct isp             *isp;
    int                    rval = 0;
    u_char                 tgt = ap-&gt;a_target;
    /*
      * We don't allow getting capabilities for other targets
    */
    if (cap == NULL || whom  == 0) {
        return (-1);
    }
    isp = (struct isp *)ap-&gt;a_hba_tran-&gt;tran_hba_private;
    ISP_MUTEX_ENTER(isp);

    switch (scsi_hba_lookup_capstr(cap)) {
      case SCSI_CAP_DMA_MAX:
          rval = 1 &lt;&lt; 24; /* Limit to 16MB max transfer */
          break;
      case SCSI_CAP_MSG_OUT:
          rval = 1;
          break;
      case SCSI_CAP_DISCONNECT:
          if ((isp-&gt;isp_target_scsi_options[tgt] &amp;
            SCSI_OPTIONS_DR) == 0) {
              break;
          } else if (
              (isp-&gt;isp_cap[tgt] &amp; ISP_CAP_DISCONNECT) == 0) {
                  break;
          }
          rval = 1;
          break;
      case SCSI_CAP_SYNCHRONOUS:
          if ((isp-&gt;isp_target_scsi_options[tgt] &amp;
            SCSI_OPTIONS_SYNC) == 0) {
              break;
          } else if (
              (isp-&gt;isp_cap[tgt] &amp; ISP_CAP_SYNC) == 0) {
                  break;
          }
          rval = 1;
          break;
      case SCSI_CAP_WIDE_XFER:
          if ((isp-&gt;isp_target_scsi_options[tgt] &amp;
            SCSI_OPTIONS_WIDE) == 0) {
              break;
          } else if (
              (isp-&gt;isp_cap[tgt] &amp; ISP_CAP_WIDE) == 0) {
                  break;
          }
          rval = 1;
          break;
      case SCSI_CAP_TAGGED_QING:
          if ((isp-&gt;isp_target_scsi_options[tgt] &amp;
            SCSI_OPTIONS_DR) == 0 ||
            (isp-&gt;isp_target_scsi_options[tgt] &amp;
            SCSI_OPTIONS_TAG) == 0) {
              break;
          } else if (
              (isp-&gt;isp_cap[tgt] &amp; ISP_CAP_TAG) == 0) {
                  break;
          }
          rval = 1;
          break;
      case SCSI_CAP_UNTAGGED_QING:
          rval = 1;
          break;
      case SCSI_CAP_PARITY:
          if (isp-&gt;isp_target_scsi_options[tgt] &amp;
            SCSI_OPTIONS_PARITY) {
              rval = 1;
          }
          break;
      case SCSI_CAP_INITIATOR_ID:
          rval = isp-&gt;isp_initiator_id;
          break;
      case SCSI_CAP_ARQ:
          if (isp-&gt;isp_cap[tgt] &amp; ISP_CAP_AUTOSENSE) {
              rval = 1;
          }
          break;
      case SCSI_CAP_LINKED_CMDS:
          break;
      case SCSI_CAP_RESET_NOTIFICATION:
         rval = 1;
          break;
      case SCSI_CAP_GEOMETRY:
          rval = (64 &lt;&lt; 16) | 32;
          break;
      default:
          rval = -1;
          break;
    }
    ISP_MUTEX_EXIT(isp);
    return (rval);
}</pre>

<a name="scsihba-81"></a><h5><tt>tran_setcap()</tt> Entry Point</h5>
<p><a name="indexterm-649"></a><a name="indexterm-650"></a>The <a href="http://docs.sun.com/doc/819-2255/tran-setcap-9e?a=view"><tt>tran_setcap</tt>(9E)</a> entry point for a SCSI HBA driver is called by
 <a href="http://docs.sun.com/doc/819-2256/scsi-ifsetcap-9f?a=view"><tt>scsi_ifsetcap</tt>(9F)</a>. A target driver calls <tt>scsi_ifsetcap()</tt> to change the current one of a
set of SCSA-defined capabilities.</p><p>The target driver might request that the new value be set for
a particular target by setting the <tt>whom</tt> parameter to nonzero. A <tt>whom</tt> value
of zero means the request is to set the new value for
the SCSI bus or for adapter hardware in general.</p><p><tt>tran_setcap()</tt> should return the following values as appropriate:</p>
<ul><li><p><tt>-1</tt> for undefined capabilities</p></li>
<li><p><tt>0</tt> if the HBA driver cannot set the capability to the requested value</p></li>
<li><p><tt>1</tt> if the HBA driver is able to set the capability to the requested value</p></li></ul>
<p>The HBA driver can use the function  <a href="http://docs.sun.com/doc/819-2256/scsi-hba-lookup-capstr-9f?a=view"><tt>scsi_hba_lookup_capstr</tt>(9F)</a> to compare the capability
string against the canonical set of defined capabilities. </p><a name="scsihba-ex-82"></a><h6>Example&nbsp;18-11 HBA Driver <tt>tran_setcap</tt>(9E) Entry Point</h6><pre>static int
isp_scsi_setcap(
    struct scsi_address    *ap,
    char                   *cap,
    int                    value,
    int                    whom)
{
    struct isp             *isp;
    int                    rval = 0;
    u_char                 tgt = ap-&gt;a_target;
    int                    update_isp = 0;
    /*
     * We don't allow setting capabilities for other targets
     */
    if (cap == NULL || whom == 0) {
        return (-1);
    }

    isp = (struct isp *)ap-&gt;a_hba_tran-&gt;tran_hba_private;
    ISP_MUTEX_ENTER(isp);

    switch (scsi_hba_lookup_capstr(cap)) {
      case SCSI_CAP_DMA_MAX:
      case SCSI_CAP_MSG_OUT:
      case SCSI_CAP_PARITY:
      case SCSI_CAP_UNTAGGED_QING:
      case SCSI_CAP_LINKED_CMDS:
      case SCSI_CAP_RESET_NOTIFICATION:
          /*
           * None of these are settable through
           * the capability interface.
           */
          break;
      case SCSI_CAP_DISCONNECT:
          if ((isp-&gt;isp_target_scsi_options[tgt] &amp;
            SCSI_OPTIONS_DR) == 0) {
                break;
          } else {
              if (value) {
                  isp-&gt;isp_cap[tgt] |= ISP_CAP_DISCONNECT;
              } else {
                isp-&gt;isp_cap[tgt] &amp;= ~ISP_CAP_DISCONNECT;
              }
          }
          rval = 1;
          break;
      case SCSI_CAP_SYNCHRONOUS:
          if ((isp-&gt;isp_target_scsi_options[tgt] &amp;
            SCSI_OPTIONS_SYNC) == 0) {
                break;
          } else {
              if (value) {
                  isp-&gt;isp_cap[tgt] |= ISP_CAP_SYNC;
              } else {
                  isp-&gt;isp_cap[tgt] &amp;= ~ISP_CAP_SYNC;
              }
          }
          rval = 1;
          break;
      case SCSI_CAP_TAGGED_QING:
          if ((isp-&gt;isp_target_scsi_options[tgt] &amp;
            SCSI_OPTIONS_DR) == 0 ||
            (isp-&gt;isp_target_scsi_options[tgt] &amp;
            SCSI_OPTIONS_TAG) == 0) {
                break;
          } else {
              if (value) {
                  isp-&gt;isp_cap[tgt] |= ISP_CAP_TAG;
              } else {
                  isp-&gt;isp_cap[tgt] &amp;= ~ISP_CAP_TAG;
              }
          }
          rval = 1;
          break;
      case SCSI_CAP_WIDE_XFER:
          if ((isp-&gt;isp_target_scsi_options[tgt] &amp;
            SCSI_OPTIONS_WIDE) == 0) {
                break;
          } else {
              if (value) {
                  isp-&gt;isp_cap[tgt] |= ISP_CAP_WIDE;
              } else {
                  isp-&gt;isp_cap[tgt] &amp;= ~ISP_CAP_WIDE;
              }
          }
          rval = 1;
          break;
      case SCSI_CAP_INITIATOR_ID:
          if (value &lt; N_ISP_TARGETS_WIDE) {
              struct isp_mbox_cmd mbox_cmd;
              isp-&gt;isp_initiator_id = (u_short) value;
              /*
               * set Initiator SCSI ID
               */
              isp_i_mbox_cmd_init(isp, &amp;mbox_cmd, 2, 2,
                ISP_MBOX_CMD_SET_SCSI_ID,
                isp-&gt;isp_initiator_id,
                0, 0, 0, 0);
              if (isp_i_mbox_cmd_start(isp, &amp;mbox_cmd) == 0) {
                  rval = 1;
              }
          }
          break;
      case SCSI_CAP_ARQ:
          if (value) {
              isp-&gt;isp_cap[tgt] |= ISP_CAP_AUTOSENSE;
          } else {
              isp-&gt;isp_cap[tgt] &amp;= ~ISP_CAP_AUTOSENSE;
          }
          rval = 1;
          break;
      default:
          rval = -1;
          break;
    }
    ISP_MUTEX_EXIT(isp);
    return (rval);
}</pre>

<a name="scsihba-83"></a><h4>Abort and Reset Management</h4>
<p>The following sections discuss the abort and reset entry points for SCSI HBA.</p>

<a name="scsihba-84"></a><h5><tt>tran_abort()</tt> Entry Point</h5>
<p><a name="indexterm-651"></a><a name="indexterm-652"></a><a name="indexterm-653"></a>The <a href="http://docs.sun.com/doc/819-2255/tran-abort-9e?a=view"><tt>tran_abort</tt>(9E)</a> entry point for a SCSI HBA driver is called to
abort any commands that are currently in transport for a particular target. This entry
point is called when a target driver calls <a href="http://docs.sun.com/doc/819-2256/scsi-abort-9f?a=view"><tt>scsi_abort</tt>(9F)</a>.</p><p>The <tt>tran_abort()</tt> entry point should attempt to abort the command denoted by the
<tt>pkt</tt> parameter. If the <tt>pkt</tt> parameter is <tt>NULL</tt>, <tt>tran_abort()</tt> should attempt to abort all
outstanding commands in the transport layer for the particular target or logical unit.</p><p>Each command successfully aborted must be marked with <tt>pkt_reason</tt> <tt>CMD_ABORTED</tt> and <tt>pkt_statistics</tt>
OR'd with <tt>STAT_ABORTED</tt>.</p>

<a name="scsihba-85"></a><h5><tt>tran_reset()</tt> Entry Point</h5>
<p><a name="indexterm-654"></a><a name="indexterm-655"></a>The <a href="http://docs.sun.com/doc/819-2255/tran-reset-9e?a=view"><tt>tran_reset</tt>(9E)</a> entry point for a SCSI HBA driver is called to
reset either the SCSI bus or a particular SCSI target device. This entry
point is called when a target driver calls  <a href="http://docs.sun.com/doc/819-2256/scsi-reset-9f?a=view"><tt>scsi_reset</tt>(9F)</a>.</p><p>The <tt>tran_reset()</tt> entry point must reset the SCSI bus if level is <tt>RESET_ALL</tt>.
If level is <tt>RESET_TARGET</tt>, just the particular target or logical unit must be
reset.</p><p>Active commands affected by the reset must be marked with <tt>pkt_reason</tt> <tt>CMD_RESET</tt>.
The type of reset determines whether <tt>STAT_BUS_RESET</tt> or <tt>STAT_DEV_RESET</tt> should be used to
OR <tt>pkt_statistics</tt>.</p><p>Commands in the transport layer, but not yet active on the target,
must be marked with <tt>pkt_reason</tt> <tt>CMD_RESET</tt>, and <tt>pkt_statistics</tt> OR'd with <tt>STAT_ABORTED</tt>.</p>

<a name="scsihba-9"></a><h5><tt>tran_bus_reset()</tt> Entry Point</h5>
<p><a href="http://docs.sun.com/doc/819-2255/tran-bus-reset-9e?a=view"><tt>tran_bus_reset</tt>(9E)</a> must reset the SCSI bus without resetting targets.</p><pre>#include &lt;sys/scsi/scsi.h&gt;

int tran_bus_reset(dev_info_t <i>*hba-dip</i>, int <i>level</i>);</pre><p>where:</p><dl><dt><i>*hba-dip</i></dt>
<dd><p>Pointer associated with the SCSI HBA</p></dd>
<dt><i>level</i></dt>
<dd><p>Must be set to <tt>RESET_BUS</tt> so that only the SCSI bus is reset, not the targets</p></dd>
</dl>
<p>The <tt>tran_bus_reset()</tt> vector in the  <a href="http://docs.sun.com/doc/819-2257/scsi-hba-tran-9s?a=view"><tt>scsi_hba_tran</tt>(9S)</a> structure should be initialized during the
HBA driver's <a href="http://docs.sun.com/doc/819-2255/attach-9e?a=view"><tt>attach</tt>(9E)</a>. The vector should point to an HBA entry point that
is to be called when a user initiates a bus reset.</p><p>Implementation is hardware specific. If the HBA driver cannot reset the SCSI bus
without affecting the targets, the driver should fail <tt>RESET_BUS</tt> or not initialize
this vector.</p>

<a name="scsihba-86"></a><h5><tt>tran_reset_notify()</tt> Entry Point</h5>
<p><a name="indexterm-656"></a><a name="indexterm-657"></a>Use the <a href="http://docs.sun.com/doc/819-2255/tran-reset-notify-9e?a=view"><tt>tran_reset_notify</tt>(9E)</a> entry point when a SCSI bus reset occurs. This function
requests the SCSI HBA driver to notify the target driver by callback.</p><a name="scsihba-ex-87"></a><h6>Example&nbsp;18-12 HBA Driver <tt>tran_reset_notify</tt>(9E) Entry Point</h6><pre>isp_scsi_reset_notify(
    struct scsi_address    *ap,
    int                    flag,
    void                   (*callback)(caddr_t),
    caddr_t                arg)
{
    struct isp                       *isp;
    struct isp_reset_notify_entry    *p, *beforep;
    int                              rval = DDI_FAILURE;

    isp = (struct isp *)ap-&gt;a_hba_tran-&gt;tran_hba_private;
    mutex_enter(ISP_REQ_MUTEX(isp));
    /*
     * Try to find an existing entry for this target
     */
    p = isp-&gt;isp_reset_notify_listf;
    beforep = NULL;

    while (p) {
        if (p-&gt;ap == ap)
            break;
        beforep = p;
        p = p-&gt;next;
    }

    if ((flag &amp; SCSI_RESET_CANCEL) &amp;&amp; (p != NULL)) {
        if (beforep == NULL) {
            isp-&gt;isp_reset_notify_listf = p-&gt;next;
        } else {
            beforep-&gt;next = p-&gt;next;
        }
        kmem_free((caddr_t)p, sizeof (struct isp_reset_notify_entry));
        rval = DDI_SUCCESS;
    } else if ((flag &amp; SCSI_RESET_NOTIFY) &amp;&amp; (p == NULL)) {
        p = kmem_zalloc(sizeof (struct isp_reset_notify_entry),
          KM_SLEEP);
        p-&gt;ap = ap;
        p-&gt;callback = callback;
        p-&gt;arg = arg;
        p-&gt;next = isp-&gt;isp_reset_notify_listf;
        isp-&gt;isp_reset_notify_listf = p;
        rval = DDI_SUCCESS;
    }
    mutex_exit(ISP_REQ_MUTEX(isp));
    return (rval);
}</pre>

<a name="scsihba-96"></a><h4>Dynamic Reconfiguration</h4>
<a name="indexterm-658"></a><a name="indexterm-659"></a><p>To support the minimal set of hot-plugging operations, drivers might need to implement
support for bus <b>quiesce</b>, bus <b>unquiesce</b>, and bus <b>reset</b>. The <a href="http://docs.sun.com/doc/819-2257/scsi-hba-tran-9s?a=view"><tt>scsi_hba_tran</tt>(9S)</a> structure
supports these operations. If quiesce, unquiesce, or reset are not required by hardware, no
driver changes are needed.</p><p>The <tt>scsi_hba_tran</tt> structure includes the following fields:</p><pre>int (*tran_quiesce)(dev_info_t *<i>hba-dip</i>);
int (*tran_unquiesce)(dev_info_t *<i>hba-dip</i>);
int (*tran_bus_reset)(dev_info_t *<i>hba-dip</i>, int <i>level</i>);</pre><p>These interfaces quiesce and unquiesce a SCSI bus.</p><pre>#include &lt;sys/scsi/scsi.h&gt;

int prefixtran_quiesce(dev_info_t *<i>hba-dip</i>);
int prefixtran_unquiesce(dev_info_t *<i>hba-dip</i>);</pre><p><a href="http://docs.sun.com/doc/819-2255/tran-quiesce-9e?a=view"><tt>tran_quiesce</tt>(9E)</a> and <a href="http://docs.sun.com/doc/819-2255/tran-unquiesce-9e?a=view"><tt>tran_unquiesce</tt>(9E)</a> are used for SCSI devices that are not designed for
hot-plugging. These functions must be implemented by an HBA driver to support dynamic
reconfiguration (DR).</p><p>The <tt>tran_quiesce()</tt> and <tt>tran_unquiesce()</tt> vectors in the <a href="http://docs.sun.com/doc/819-2257/scsi-hba-tran-9s?a=view"><tt>scsi_hba_tran</tt>(9S)</a> structure should be initialized to
point to HBA entry points during <a href="http://docs.sun.com/doc/819-2255/attach-9e?a=view"><tt>attach</tt>(9E)</a>. These functions are called when a user
initiates quiesce and unquiesce operations.</p><p>The <tt>tran_quiesce()</tt> entry point stops all activity on a SCSI bus prior to
and during the reconfiguration of devices that are  attached to the SCSI
bus.  The <tt>tran_unquiesce()</tt> entry point is called by the SCSA framework to
resume activity on the SCSI bus after the reconfiguration operation has been completed.</p><p>HBA drivers are required to handle <tt>tran_quiesce()</tt> by waiting for all outstanding commands
to complete before returning success.  After the driver has quiesced the bus,
any new I/O requests must be queued until the SCSA framework calls the
corresponding <tt>tran_unquiesce()</tt> entry point.</p><p>HBA drivers handle calls to <tt>tran_unquiesce()</tt> by starting any target driver I/O requests
in the queue.</p>
         </div>
      </td>
   </tr>

   <tr class="PageControls" valign="top">
      <td></td>
      <td>
         <table width="100%">
      	   <tr>
      	     <td>
                 <a href="scsihba-32.html">Previous</a>
             </td>
             <td align="right">
                 <a href="scsihba-88.html">Next</a>
             </td>
           </tr>
         </table>
      </td>
   </tr>
</tbody>
</table>


</body>
</html>

