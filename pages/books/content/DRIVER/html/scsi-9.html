<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="en-US">
<head>
<meta http-equiv="Content-type" content="text/html; charset=iso-8859-1">
<title>Declarations and Data Structures - Writing Device Drivers</title>
<meta name="robots" content="index,follow">
<meta name="robots" content="index,follow">
<meta name="date" content="2008-08-01">
<meta name="collection" content="reference">
<link rel="stylesheet" type="text/css" href="css/elements.css">
<link rel="stylesheet" type="text/css" href="css/indiana.css">
</head>

<body>


<div class="Masthead">
   <div class="MastheadLogo">
      <a href="http://www.opensolaris.org"><img border="0" src="graphics/header.png"></img></a>
   </div>
   <div class="Title">Writing Device Drivers</div>
</div>

<table class="Layout" border="0" cellspacing="0" width="100%">
<tbody>

   <tr valign="top" class="PageControls">
      <td></td>
      <td>
         <table width="100%">
      	   <tr>
      	     <td>
                 <a href="scsi-37210.html">Previous</a>
             </td>
             <td align="right">
                 <a href="scsi-11.html">Next</a>
             </td>
           </tr>
         </table>
      </td>
   </tr>
   
   <tr valign="top">
      <td class="Navigation" width="200px"><p class="toc level1"><a href="docinfo.html">Document Information</a></p>
<p class="toc level1 tocsp"><a href="preface-1.html">Preface</a></p>
<p class="toc level1 tocsp"><a href="eqbvu.html">Part&nbsp;I&nbsp;Designing Device Drivers for the Solaris Platform</a></p>
<p class="toc level2"><a href="eqbqn.html">1.&nbsp;&nbsp;Overview of Solaris Device Drivers</a></p>
<p class="toc level2"><a href="kernelovr-77198.html">2.&nbsp;&nbsp;Solaris Kernel and Device Tree</a></p>
<p class="toc level2"><a href="mt-17026.html">3.&nbsp;&nbsp;Multithreading</a></p>
<p class="toc level2"><a href="properties-1.html">4.&nbsp;&nbsp;Properties</a></p>
<p class="toc level2"><a href="events-1.html">5.&nbsp;&nbsp;Managing Events and Queueing Tasks</a></p>
<p class="toc level2"><a href="autoconf-17.html">6.&nbsp;&nbsp;Driver Autoconfiguration</a></p>
<p class="toc level2"><a href="devaccess-3.html">7.&nbsp;&nbsp;Device Access: Programmed I/O</a></p>
<p class="toc level2"><a href="interrupt-15678.html">8.&nbsp;&nbsp;Interrupt Handlers</a></p>
<p class="toc level2"><a href="dma-29901.html">9.&nbsp;&nbsp;Direct Memory Access (DMA)</a></p>
<p class="toc level2"><a href="devmap-24338.html">10.&nbsp;&nbsp;Mapping Device and Kernel Memory</a></p>
<p class="toc level2"><a href="devcnmgt-19679.html">11.&nbsp;&nbsp;Device Context Management</a></p>
<p class="toc level2"><a href="powermgt-37437.html">12.&nbsp;&nbsp;Power Management</a></p>
<p class="toc level2"><a href="gevsi.html">13.&nbsp;&nbsp;Hardening Solaris Drivers</a></p>
<p class="toc level2"><a href="ldi-1.html">14.&nbsp;&nbsp;Layered Driver Interface (LDI)</a></p>
<p class="toc level1 tocsp"><a href="eqbvb.html">Part&nbsp;II&nbsp;Designing Specific Kinds of Device Drivers</a></p>
<p class="toc level2"><a href="character-21002.html">15.&nbsp;&nbsp;Drivers for Character Devices</a></p>
<p class="toc level2"><a href="block-34861.html">16.&nbsp;&nbsp;Drivers for Block Devices</a></p>
<p class="toc level2"><a href="scsi-36812.html">17.&nbsp;&nbsp;SCSI Target Drivers</a></p>
<p class="toc level3"><a href="scsi-6a.html">Introduction to Target Drivers</a></p>
<p class="toc level3"><a href="scsi-3.html">Sun Common SCSI Architecture Overview</a></p>
<p class="toc level3"><a href="scsi-37210.html">Hardware Configuration File</a></p>
<div class="onpage">
<p class="toc level3"><a href="">Declarations and Data Structures</a></p>
</div>
<p class="toc level3"><a href="scsi-11.html">Autoconfiguration for SCSI Target Drivers</a></p>
<p class="toc level3"><a href="scsi-12.html">Resource Allocation</a></p>
<p class="toc level3"><a href="scsi-15.html">Building and Transporting a Command</a></p>
<p class="toc level3"><a href="scsi-100.html">SCSI Options</a></p>
<p class="toc level2 tocsp"><a href="scsihba-32898.html">18.&nbsp;&nbsp;SCSI Host Bus Adapter Drivers</a></p>
<p class="toc level2"><a href="gld-1.html">19.&nbsp;&nbsp;Drivers for Network Devices</a></p>
<p class="toc level2"><a href="usb-1.html">20.&nbsp;&nbsp;USB Drivers</a></p>
<p class="toc level1 tocsp"><a href="eqbvo.html">Part&nbsp;III&nbsp;Building a Device Driver</a></p>
<p class="toc level2"><a href="loading-15035.html">21.&nbsp;&nbsp;Compiling, Loading, Packaging, and Testing Drivers</a></p>
<p class="toc level2"><a href="debug-60.html">22.&nbsp;&nbsp;Debugging, Testing, and Tuning Device Drivers</a></p>
<p class="toc level2"><a href="coding-practices.html">23.&nbsp;&nbsp;Recommended Coding Practices</a></p>
<p class="toc level1 tocsp"><a href="eqbva.html">Part&nbsp;IV&nbsp;Appendixes</a></p>
<p class="toc level2"><a href="hwovr-18191.html">A.&nbsp;&nbsp;Hardware Overview</a></p>
<p class="toc level2"><a href="ddidkisvc-29227.html">B.&nbsp;&nbsp;Summary of Solaris DDI/DKI Services</a></p>
<p class="toc level2"><a href="lp64-35004.html">C.&nbsp;&nbsp;Making a Device Driver 64-Bit Ready</a></p>
<p class="toc level2"><a href="euazz.html">D.&nbsp;&nbsp;Console Frame Buffer Drivers</a></p>
<p class="toc level1 tocsp"><a href="idx-1.html">Index</a></p>
</td>
      <td class="ContentPane" width="705px">

	 <div class="MainContent">      	 
             

<a name="scsi-9"></a><h3>Declarations and Data Structures</h3>
<p><a name="scsi-ix482"></a>Target drivers must include the header file <tt>&lt;sys/scsi/scsi.h&gt;</tt>.</p><p>SCSI target drivers must use the following command to generate a binary module:</p><pre>ld -r <i>xx</i> <i>xx</i>.o -N"misc/scsi"</pre>

<a name="scsi-53524"></a><h4><tt>scsi_device</tt> Structure</h4>
<p><a name="scsi-ix483"></a><a name="indexterm-590"></a>The host bus adapter driver allocates and initializes a <a href="http://docs.sun.com/doc/819-2257/scsi-device-9s?a=view"><tt>scsi_device</tt>(9S)</a> structure for the
target driver before either the  <a href="http://docs.sun.com/doc/819-2255/probe-9e?a=view"><tt>probe</tt>(9E)</a> or <a href="http://docs.sun.com/doc/819-2255/attach-9e?a=view"><tt>attach</tt>(9E)</a> routine is called. This
structure stores information about each SCSI logical unit, including pointers to information areas that
contain both generic and device-specific information. One <a href="http://docs.sun.com/doc/819-2257/scsi-device-9s?a=view"><tt>scsi_device</tt>(9S)</a> structure exists for each logical
unit that is attached to the system. The target driver can retrieve a
pointer to this structure by calling <a href="http://docs.sun.com/doc/819-2256/ddi-get-driver-private-9f?a=view"><tt>ddi_get_driver_private</tt>(9F)</a>.</p>
<hr><p><b>Caution - </b><a name="indexterm-591"></a>Because the host bus adapter driver uses the private field in the target
device's <tt>dev_info</tt> structure, target drivers must not use <a href="http://docs.sun.com/doc/819-2256/ddi-set-driver-private-9f?a=view"><tt>ddi_set_driver_private</tt>(9F)</a>.</p>
<hr>
<p>The <a href="http://docs.sun.com/doc/819-2257/scsi-device-9s?a=view"><tt>scsi_device</tt>(9S)</a> structure contains the following fields:</p><pre>struct scsi_device {
    struct scsi_address           sd_address;    /* opaque address */
    dev_info_t                    *sd_dev;       /* device node */
    kmutex_t                      sd_mutex;
    void                          *sd_reserved;
    struct scsi_inquiry           *sd_inq;
    struct scsi_extended_sense    *sd_sense;
    caddr_t                       sd_private;
};</pre><p>where:</p><dl><dt><tt>sd_address</tt></dt>
<dd><p>Data structure that is passed to the routines for SCSI resource allocation.</p></dd>
<dt><tt>sd_dev</tt></dt>
<dd><p>Pointer to the target's <tt>dev_info</tt> structure.</p></dd>
<dt><tt>sd_mutex</tt></dt>
<dd><p>Mutex for use by the target driver. This mutex is initialized by the host bus adapter driver and can be used by the target driver as a per-device mutex. Do not hold this mutex across a call to <a href="http://docs.sun.com/doc/819-2256/scsi-transport-9f?a=view"><tt>scsi_transport</tt>(9F)</a> or <a href="http://docs.sun.com/doc/819-2256/scsi-poll-9f?a=view"><tt>scsi_poll</tt>(9F)</a>. See <a href="mt-17026.html">Chapter&nbsp;3, Multithreading</a> for more information on mutexes.</p></dd>
<dt><tt>sd_inq</tt></dt>
<dd><p>Pointer for the target device's SCSI inquiry data. The <a href="http://docs.sun.com/doc/819-2256/scsi-probe-9f?a=view"><tt>scsi_probe</tt>(9F)</a> routine allocates a buffer, fills the buffer in with inquiry data, and attaches the buffer to this field.</p></dd>
<dt><tt>sd_sense</tt></dt>
<dd><p>Pointer to a buffer to contain SCSI request sense data from the device. The target driver must allocate and manage this buffer. See <a href="scsi-11.html#scsi-38411"><tt>attach()</tt> Entry Point (SCSI Target Drivers)</a>.</p></dd>
<dt><tt>sd_private</tt></dt>
<dd><p>Pointer field for use by the target driver. This field is commonly used to store a pointer to a private target driver state structure.</p></dd>
</dl>


<a name="scsi-39157"></a><h4><tt>scsi_pkt</tt> Structure (Target Drivers)</h4>
<p><a name="scsi-ix484"></a>The <tt>scsi_pkt</tt> structure contains the following fields:</p><pre>struct scsi_pkt {
    opaque_t  pkt_ha_private;         /* private data for host adapter */
    struct scsi_address pkt_address;  /* destination packet is for */
    opaque_t  pkt_private;            /* private data for target driver */
    void     (*pkt_comp)(struct scsi_pkt *);  /* completion routine */
    uint_t   pkt_flags;               /* flags */
    int      pkt_time;                /* time allotted to complete command */
    uchar_t  *pkt_scbp;               /* pointer to status block */
    uchar_t  *pkt_cdbp;               /* pointer to command block */
    ssize_t  pkt_resid;               /* data bytes not transferred */
    uint_t   pkt_state;               /* state of command */
    uint_t   pkt_statistics;          /* statistics */
    uchar_t  pkt_reason;              /* reason completion called */
};</pre><p>where:</p><dl><dt><tt>pkt_address</tt></dt>
<dd><p>Target device's address set by <a href="http://docs.sun.com/doc/819-2256/scsi-init-pkt-9f?a=view"><tt>scsi_init_pkt</tt>(9F)</a>.</p></dd>
<dt><tt>pkt_private</tt></dt>
<dd><p>Place to store private data for the target driver. <i>pkt_private</i> is commonly used to save the <a href="http://docs.sun.com/doc/819-2257/buf-9s?a=view"><tt>buf</tt>(9S)</a> pointer for the command.</p></dd>
<dt><tt>pkt_comp</tt></dt>
<dd><p>Address of the completion routine. The host bus adapter driver calls this routine when the driver has transported the command. Transporting the command does not mean that the command succeeded. The target might have been busy. Another possibility is that the target might not have responded before the time out period elapsed. See the description for <tt>pkt_time</tt> field. The target driver must supply a valid value in this field. This value can be <tt>NULL</tt> if the driver does not want to be notified.</p></dd>
</dl>

<hr><p><b>Note - </b>Two different SCSI callback routines are provided. The <tt>pkt_comp</tt> field identifies a
<b>completion callback</b> routine, which is called when the host bus adapter completes its processing.
A <b>resource callback</b> routine is also available, which is called when currently unavailable resources
are likely to be available. See the <a href="http://docs.sun.com/doc/819-2256/scsi-init-pkt-9f?a=view"><tt>scsi_init_pkt</tt>(9F)</a> man page.</p>
<hr>
<dl><dt><tt>pkt_flags</tt></dt>
<dd><p>Provides additional control information, for example, to transport the command without disconnect privileges (<tt>FLAG_NODISCON</tt>) or to disable callbacks (<tt>FLAG_NOINTR</tt>). See the <a href="http://docs.sun.com/doc/819-2257/scsi-pkt-9s?a=view"><tt>scsi_pkt</tt>(9S)</a> man page for details.</p></dd>
<dt><tt>pkt_time</tt></dt>
<dd><p>Time out value in seconds. If the command is not completed within this time, the host bus adapter calls the completion routine with <tt>pkt_reason</tt> set to <tt>CMD_TIMEOUT</tt>. The target driver should set this field to longer than the maximum time the command might take. If the timeout is zero, no timeout is requested. Timeout starts when the command is transmitted on the SCSI bus.</p></dd>
<dt><tt>pkt_scbp</tt></dt>
<dd><p>Pointer to the block for SCSI status completion. This field is filled in by the host bus adapter driver.</p></dd>
<dt><tt>pkt_cdbp</tt></dt>
<dd><p>Pointer to the SCSI command descriptor block, the actual command to be sent to the target device. The host bus adapter driver does not interpret this field. The target driver must fill the field in with a command that the target device can process.</p></dd>
<dt><tt>pkt_resid</tt></dt>
<dd><p>Residual of the operation. The <tt>pkt_resid</tt> field has two different uses depending on how <tt>pkt_resid</tt> is used. When <tt>pkt_resid</tt> is used to allocate DMA resources for a command <a href="http://docs.sun.com/doc/819-2256/scsi-init-pkt-9f?a=view"><tt>scsi_init_pkt</tt>(9F)</a>, <tt>pkt_resid</tt> indicates the number of unallocable bytes. DMA resources might <b>not</b> be allocated due to DMA hardware scatter-gather or other device limitations. After command transport, <tt>pkt_resid</tt> indicates the number of non-transferable data bytes. The field is filled in by the host bus adapter driver before the completion routine is called.</p></dd>
<dt><tt>pkt_state</tt></dt>
<dd><p>Indicates the state of the command. The host bus adapter driver fills in this field as the command progresses. One bit is set in this field for each of the five following command states:</p>
<ul><li><p><tt>STATE_GOT_BUS</tt> &ndash; Acquired the bus</p></li>
<li><p><tt>STATE_GOT_TARGET</tt> &ndash; Selected the target</p></li>
<li><p><tt>STATE_SENT_CMD</tt> &ndash; Sent the command</p></li>
<li><p><tt>STATE_XFERRED_DATA</tt> &ndash; Transferred data, if appropriate</p></li>
<li><p><tt>STATE_GOT_STATUS</tt> &ndash; Received status from the device</p></li></ul>
</dd>
<dt><tt>pkt_statistics</tt></dt>
<dd><p>Contains transport-related statistics set by the host bus adapter driver.</p></dd>
<dt><tt>pkt_reason</tt></dt>
<dd><p>Gives the reason the completion routine was called. The completion routine decodes this field. The routine then takes the appropriate action. If the command completes, that is, no transport errors occur, this field is set to <tt>CMD_CMPLT</tt>. Other values in this field indicate an error. After a command is completed, the target driver should examine the <tt>pkt_scbp</tt> field for a check condition status. See the <a href="http://docs.sun.com/doc/819-2257/scsi-pkt-9s?a=view"><tt>scsi_pkt</tt>(9S)</a> man page for more information.</p></dd>
</dl>

         </div>
      </td>
   </tr>

   <tr class="PageControls" valign="top">
      <td></td>
      <td>
         <table width="100%">
      	   <tr>
      	     <td>
                 <a href="scsi-37210.html">Previous</a>
             </td>
             <td align="right">
                 <a href="scsi-11.html">Next</a>
             </td>
           </tr>
         </table>
      </td>
   </tr>
</tbody>
</table>


</body>
</html>

