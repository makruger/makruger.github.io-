<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="en-US">
<head>
<meta http-equiv="Content-type" content="text/html; charset=iso-8859-1">
<title>Sun Fault Management Architecture I/O Fault Services - Writing Device Drivers</title>
<meta name="robots" content="index,follow">
<meta name="robots" content="index,follow">
<meta name="date" content="2008-08-01">
<meta name="collection" content="reference">
<link rel="stylesheet" type="text/css" href="css/elements.css">
<link rel="stylesheet" type="text/css" href="css/indiana.css">
</head>

<body>


<div class="Masthead">
   <div class="MastheadLogo">
      <a href="http://www.opensolaris.org"><img border="0" src="graphics/header.png"></img></a>
   </div>
   <div class="Title">Writing Device Drivers</div>
</div>

<table class="Layout" border="0" cellspacing="0" width="100%">
<tbody>

   <tr valign="top" class="PageControls">
      <td></td>
      <td>
         <table width="100%">
      	   <tr>
      	     <td>
                 <a href="gevsi.html">Previous</a>
             </td>
             <td align="right">
                 <a href="defensive-programming.html">Next</a>
             </td>
           </tr>
         </table>
      </td>
   </tr>
   
   <tr valign="top">
      <td class="Navigation" width="200px"><p class="toc level1"><a href="docinfo.html">Document Information</a></p>
<p class="toc level1 tocsp"><a href="preface-1.html">Preface</a></p>
<p class="toc level1 tocsp"><a href="eqbvu.html">Part&nbsp;I&nbsp;Designing Device Drivers for the Solaris Platform</a></p>
<p class="toc level2"><a href="eqbqn.html">1.&nbsp;&nbsp;Overview of Solaris Device Drivers</a></p>
<p class="toc level2"><a href="kernelovr-77198.html">2.&nbsp;&nbsp;Solaris Kernel and Device Tree</a></p>
<p class="toc level2"><a href="mt-17026.html">3.&nbsp;&nbsp;Multithreading</a></p>
<p class="toc level2"><a href="properties-1.html">4.&nbsp;&nbsp;Properties</a></p>
<p class="toc level2"><a href="events-1.html">5.&nbsp;&nbsp;Managing Events and Queueing Tasks</a></p>
<p class="toc level2"><a href="autoconf-17.html">6.&nbsp;&nbsp;Driver Autoconfiguration</a></p>
<p class="toc level2"><a href="devaccess-3.html">7.&nbsp;&nbsp;Device Access: Programmed I/O</a></p>
<p class="toc level2"><a href="interrupt-15678.html">8.&nbsp;&nbsp;Interrupt Handlers</a></p>
<p class="toc level2"><a href="dma-29901.html">9.&nbsp;&nbsp;Direct Memory Access (DMA)</a></p>
<p class="toc level2"><a href="devmap-24338.html">10.&nbsp;&nbsp;Mapping Device and Kernel Memory</a></p>
<p class="toc level2"><a href="devcnmgt-19679.html">11.&nbsp;&nbsp;Device Context Management</a></p>
<p class="toc level2"><a href="powermgt-37437.html">12.&nbsp;&nbsp;Power Management</a></p>
<p class="toc level2"><a href="gevsi.html">13.&nbsp;&nbsp;Hardening Solaris Drivers</a></p>
<div class="onpage">
<p class="toc level3"><a href="">Sun Fault Management Architecture I/O Fault Services</a></p>
</div>
<p class="toc level3"><a href="defensive-programming.html">Defensive Programming Techniques for Solaris Device Drivers</a></p>
<p class="toc level3"><a href="gemgi.html">Driver Hardening Test Harness</a></p>
<p class="toc level2 tocsp"><a href="ldi-1.html">14.&nbsp;&nbsp;Layered Driver Interface (LDI)</a></p>
<p class="toc level1 tocsp"><a href="eqbvb.html">Part&nbsp;II&nbsp;Designing Specific Kinds of Device Drivers</a></p>
<p class="toc level2"><a href="character-21002.html">15.&nbsp;&nbsp;Drivers for Character Devices</a></p>
<p class="toc level2"><a href="block-34861.html">16.&nbsp;&nbsp;Drivers for Block Devices</a></p>
<p class="toc level2"><a href="scsi-36812.html">17.&nbsp;&nbsp;SCSI Target Drivers</a></p>
<p class="toc level2"><a href="scsihba-32898.html">18.&nbsp;&nbsp;SCSI Host Bus Adapter Drivers</a></p>
<p class="toc level2"><a href="gld-1.html">19.&nbsp;&nbsp;Drivers for Network Devices</a></p>
<p class="toc level2"><a href="usb-1.html">20.&nbsp;&nbsp;USB Drivers</a></p>
<p class="toc level1 tocsp"><a href="eqbvo.html">Part&nbsp;III&nbsp;Building a Device Driver</a></p>
<p class="toc level2"><a href="loading-15035.html">21.&nbsp;&nbsp;Compiling, Loading, Packaging, and Testing Drivers</a></p>
<p class="toc level2"><a href="debug-60.html">22.&nbsp;&nbsp;Debugging, Testing, and Tuning Device Drivers</a></p>
<p class="toc level2"><a href="coding-practices.html">23.&nbsp;&nbsp;Recommended Coding Practices</a></p>
<p class="toc level1 tocsp"><a href="eqbva.html">Part&nbsp;IV&nbsp;Appendixes</a></p>
<p class="toc level2"><a href="hwovr-18191.html">A.&nbsp;&nbsp;Hardware Overview</a></p>
<p class="toc level2"><a href="ddidkisvc-29227.html">B.&nbsp;&nbsp;Summary of Solaris DDI/DKI Services</a></p>
<p class="toc level2"><a href="lp64-35004.html">C.&nbsp;&nbsp;Making a Device Driver 64-Bit Ready</a></p>
<p class="toc level2"><a href="euazz.html">D.&nbsp;&nbsp;Console Frame Buffer Drivers</a></p>
<p class="toc level1 tocsp"><a href="idx-1.html">Index</a></p>
</td>
      <td class="ContentPane" width="705px">

	 <div class="MainContent">      	 
             

<a name="fmaiofs"></a><h3>Sun Fault Management Architecture I/O Fault Services</h3>
<p>This section explains how to integrate fault management error reporting, error handling, and
diagnosis for I/O device drivers. This section provides an in-depth examination of the
I/O fault services framework and how to utilize the I/O fault service APIs
within a device driver.</p><p>This section discusses the following topics:</p>
<ul><li><p><a href="#gemgv">What Is Predictive Self-Healing?</a> provides background and an overview of the Sun Fault Management Architecture.</p></li>
<li><p><a href="#gemgw">Solaris Fault Manager</a> describes additional background with a focus on a high-level overview of the Solaris Fault Manager, <tt>fmd</tt>(1M).</p></li>
<li><p><a href="#gemgl">Error Handling</a> is the primary section for driver developers. This section highlights the best practice coding techniques for high-availability and the use of I/O fault services in driver code to interact with the FMA.</p></li>
<li><p><a href="#gemfs">Diagnosing Faults</a> describes how faults are diagnosed from the errors detected by drivers.</p></li>
<li><p><a href="#gemhe">Event Registry</a> provides information on Sun's Event Registry.</p></li></ul>


<a name="gemgv"></a><h4>What Is Predictive Self-Healing?</h4>
<a name="indexterm-269"></a><a name="indexterm-270"></a><a name="indexterm-271"></a><a name="indexterm-272"></a><a name="indexterm-273"></a><a name="indexterm-274"></a><a name="indexterm-275"></a><a name="indexterm-276"></a><a name="indexterm-277"></a><a name="indexterm-278"></a><a name="indexterm-279"></a><a name="indexterm-280"></a><a name="indexterm-281"></a><p>Traditionally, systems have exported hardware and software error information directly to human administrators
and to management software in the form of syslog messages. Often, error detection,
diagnosis, reporting, and handling was embedded in the code of each driver.</p><p>A system like the Solaris OS predictive self-healing system is first and foremost
self-diagnosing. Self-diagnosing means the system provides technology to automatically diagnose problems from observed
symptoms, and the results of the diagnosis can then be used to trigger
automated response and recovery. A <b>fault</b> in hardware or a defect in software
can be associated with a set of possible observed symptoms called <b>errors</b>. The data
generated by the system as the result of observing an error is
called an error report or <b>ereport</b>.</p><p>In a system capable of self-healing, ereports are captured by the system and
are encoded as a set of name-value pairs described by an extensible
event protocol to form an <b>ereport event</b>. Ereport events and other data are gathered to
facilitate self-healing, and are dispatched to software components called diagnosis engines designed to
diagnose the underlying problems corresponding to the error symptoms observed by the system.
A <b>diagnosis engine</b> runs in the background and silently consumes error telemetry until it
can produce a diagnosis or predict a fault.</p><p>After processing sufficient telemetry to reach a conclusion, a diagnosis engine produces another
event called a <b>fault event</b>. The fault event is then broadcast to all agents
that are interested in the specific fault event. An <b>agent</b> is a software
component that initiates recovery and responds to specific fault events. A software component
known as the Solaris Fault Manager, <a href="http://docs.sun.com/doc/819-2240/fmd-1m?a=view"><tt>fmd</tt>(1M)</a>, manages the multiplexing of events between ereport
generators, diagnosis engines, and agent software.</p>

<a name="gemgw"></a><h4>Solaris Fault Manager</h4>
<a name="indexterm-282"></a><a name="indexterm-283"></a><p>The Solaris Fault Manager, <a href="http://docs.sun.com/doc/819-2240/fmd-1m?a=view"><tt>fmd</tt>(1M)</a>, is responsible for dispatching in-bound error telemetry events
to the appropriate diagnosis engines. The diagnosis engine is responsible for identifying the
underlying hardware faults or software defects that are producing the error symptoms. The
<tt>fmd</tt>(1M) daemon is the Solaris OS implementation of a fault manager. It starts
at boot time and loads all of the diagnosis engines and agents available
on the system. The Solaris Fault Manager also provides interfaces for system administrators
and service personnel to observe fault management activity.</p>

<a name="gemft"></a><h5>Diagnosis, Suspect Lists, and Fault Events</h5>
<a name="indexterm-284"></a><a name="indexterm-285"></a><a name="indexterm-286"></a><a name="indexterm-287"></a><p>Once a diagnosis has been made, the diagnosis is output in the
form of a <b>list.suspect</b> event. A list.suspect event is an event comprised of one
or more possible fault or defect events. Sometimes the diagnosis cannot narrow the
cause of errors to a single fault or defect. For example, the underlying
problem might be a broken wire connecting controllers to the main system bus.
The problem might be with a component on the bus or with the
bus itself. In this specific case, the list.suspect event will contain multiple fault
events: one for each controller attached to the bus, and one for the
bus itself.</p><p><a name="indexterm-288"></a><a name="indexterm-289"></a><a name="indexterm-290"></a><a name="indexterm-291"></a><a name="indexterm-292"></a><a name="indexterm-293"></a>In addition to describing the fault that was diagnosed, a fault event also
contains four payload members for which the diagnosis is applicable.</p>
<ul><li><p>The <b>resource</b> is the component that was diagnosed as faulty. The <a href="http://docs.sun.com/doc/819-2240/fmdump-1m?a=view"><tt>fmdump</tt>(1M)</a> command shows this payload member as &ldquo;Problem in.&rdquo;</p></li>
<li><p>The <b>Automated System Recovery Unit</b> (ASRU) is the hardware or software component that must be disabled to prevent further error symptoms from occurring. The <tt>fmdump</tt>(1M) command shows this payload member as &ldquo;Affects.&rdquo;</p></li>
<li><p>The <b>Field Replaceable Unit</b> (FRU) is the component that must be replaced or repaired to fix the underlying problem.</p></li>
<li><p>The <b>Label</b> payload is a string that gives the location of the FRU in the same form as it is printed on the chassis or motherboard, for example next to a DIMM slot or PCI card slot. The <tt>fmdump</tt>command shows this payload member as &ldquo;Location.&rdquo;</p></li></ul>
<p>For example, after receiving a certain number of ECC correctable errors in a
given amount of time for a particular memory location, the CPU and
memory diagnosis engine issues a diagnosis (list.suspect event) for a faulty DIMM.</p><pre># <tt><b>fmdump -v -u 38bd6f1b-a4de-4c21-db4e-ccd26fa8573c</b></tt>
TIME                 UUID                                 SUNW-MSG-ID
Oct 31 13:40:18.1864 38bd6f1b-a4de-4c21-db4e-ccd26fa8573c AMD-8000-8L
100%  fault.cpu.amd.icachetag

Problem in: hc:///motherboard=0/chip=0/cpu=0
Affects: cpu:///cpuid=0
FRU: hc:///motherboard=0/chip=0
Location: SLOT 2</pre><p>In this example, <a href="http://docs.sun.com/doc/819-2240/fmd-1m?a=view"><tt>fmd</tt>(1M)</a> has identified a problem in a resource, specifically a
CPU (<tt>hc:///motherboard=0/chip=0/cpu=0</tt>). To suppress further error symptoms and to prevent an uncorrectable error
from occurring, an ASRU, (<tt>cpu:///cpuid=0</tt>), is identified for retirement. The component that needs
to be replaced is the FRU (<tt>hc:///motherboard=0/chip=0</tt>).</p>

<a name="gemgg"></a><h5>Response Agents</h5>
<a name="indexterm-294"></a><a name="indexterm-295"></a><a name="indexterm-296"></a><a name="indexterm-297"></a><a name="indexterm-298"></a><p>An agent is a software component that takes action in response to
a diagnosis or repair. For example, the CPU and memory retire agent is
designed to act on list.suspects that contain a fault.cpu.* event. The <tt>cpumem-retire</tt> agent
will attempt to off-line a CPU or retire a physical memory page from
service. If the agent is successful, an entry in the fault manager's ASRU
cache is added for the page or CPU that was successfully retired.
The <a href="http://docs.sun.com/doc/819-2240/fmadm-1m?a=view"><tt>fmadm</tt>(1M)</a> utility, as shown in the example below, shows an entry for
a memory rank that has been diagnosed as having a fault. ASRUs that
the system does not have the ability to off-line, retire, or disable, will
also have an entry in the ASRU cache, but they will be seen
as degraded. Degraded means the resource associated with the ASRU is faulty, but
the ASRU is unable to be removed from service. Currently Solaris agent software
cannot act upon I/O ASRUs (device instances). All faulty I/O resource entries in
the cache are in the degraded state.</p><pre># <tt><b>fmadm faulty</b></tt>
   STATE RESOURCE / UUID
-------- ----------------------------------------------------------------------
degraded mem:///motherboard=0/chip=1/memory-controller=0/dimm=3/rank=0
         ccae89df-2217-4f5c-add4-d920f78b4faf
-------- ----------------------------------------------------------------------</pre><p>The primary purpose of a <b>retire agent</b> is to isolate (safely remove from service)
the piece of hardware or software that has been diagnosed as faulty.</p><p>Agents can also take other important actions such as the following actions:</p>
<ul><li><p>Send alerts via SNMP traps. This can translate a diagnosis into an alert for SNMP that plugs into existing software mechanisms.</p></li>
<li><p>Post a syslog message. Message specific diagnoses (for example, syslog message agent) can take the result of a diagnosis and translate it into a syslog message that administrators can use to take a specific action.</p></li>
<li><p>Other agent actions such as update the FRUID. Response agents can be platform-specific.</p></li></ul>


<a name="gemfg"></a><h5>Message IDs and Dictionary Files</h5>
<a name="indexterm-299"></a><a name="indexterm-300"></a><p>The syslog message agent takes the output of the diagnosis (the list.suspect event)
and writes specific messages to the console or <tt>/var/adm/messages</tt>. Often console messages
can be difficult to understand. FMA remedies this problem by providing a defined
fault message structure that is generated every time a list.suspect event is delivered
to a syslog message.</p><p><a name="indexterm-301"></a><a name="indexterm-302"></a><a name="indexterm-303"></a><a name="indexterm-304"></a><a name="indexterm-305"></a><a name="indexterm-306"></a>The syslog agent generates a message identifier (MSG ID). The event registry generates
dictionary files (<tt>.dict</tt> files) that map a list.suspect event to a structured message
identifier that should be used to identify and view the associated knowledge article.
Message files, (<tt>.po</tt> files) map the message ID to localized messages for every possible
list of suspected faults that the diagnosis engine can generate. The following is
an example of a fault message emitted on a test system.</p><pre>SUNW-MSG-ID: AMD-8000-7U, TYPE: Fault, VER: 1, SEVERITY: Major
EVENT-TIME: Fri Jul 28 04:26:51 PDT 2006
PLATFORM: Sun Fire V40z, CSN: XG051535088, HOSTNAME: parity
SOURCE: eft, REV: 1.16
EVENT-ID: add96f65-5473-69e6-dbe1-8b3d00d5c47b
DESC: The number of errors associated with this CPU has exceeded 
acceptable levels. Refer to http://sun.com/msg/AMD-8000-7U for 
more information.
AUTO-RESPONSE: An attempt will be made to remove this CPU from service.
IMPACT: Performance of this system may be affected.
REC-ACTION: Schedule a repair procedure to replace the affected CPU. 
Use fmdump -v -u &lt;EVENT_ID&gt; to identify the module.</pre>

<a name="gemfo"></a><h5>System Topology</h5>
<a name="indexterm-307"></a><a name="indexterm-308"></a><p>To identify where a fault might have occurred, diagnosis engines need to have
the topology for a given software or hardware system represented. The <a href="http://docs.sun.com/doc/819-2240/fmd-1m?a=view"><tt>fmd</tt>(1M)</a> daemon provides
diagnosis engines with a handle to a topology snapshot that can be used
during diagnosis. Topology information is used to represent the resource, ASRU, and FRU
found in each fault event. The topology can also be used to store
the platform label, FRUID, and serial number identification.</p><p>The resource payload member in the fault event is always represented by the
physical path location from the platform chassis outward. For example, a PCI controller
function that is bridged from the main system bus to a PCI local
bus is represented by its <tt>hc</tt> scheme path name:</p><pre>hc:///motherboard=0/hostbridge=1/pcibus=0/pcidev=13/pcifn=0</pre><p>The ASRU payload member in the fault event is typically represented by the
Solaris device tree instance name that is bound to a hardware controller, device,
or function. FMA uses the <tt>dev</tt> scheme to represent the ASRU in its
native format for actions that might be taken by a future implementation of
a retire agent specifically designed for I/O devices:</p><pre>dev:////pci@1e,600000/ide@d</pre><p>The FRU payload representation in the fault event varies depending on the closest
replaceable component to the I/O resource that has been diagnosed as faulty. For
example, a fault event for a broken embedded PCI controller might name the
motherboard of the system as the FRU that needs to be replaced:</p><pre>hc:///motherboard=0</pre><p>The label payload is a string that gives the location of the
FRU in the same form as it is printed on the chassis or
motherboard, for example next to a DIMM slot or PCI card slot:</p><pre>Label: SLOT 2</pre>

<a name="gemgl"></a><h4>Error Handling</h4>
<a name="indexterm-309"></a><p>This section describes how to use I/O fault services APIs to handle errors
within a driver. This section discusses how drivers should indicate and initialize their
fault management capabilities, generate error reports, and register the driver's error handler routine.</p><p><a name="indexterm-310"></a>Excerpts are provided from source code examples that demonstrate the use of the
I/O fault services API from the Broadcom 1Gb NIC driver, <tt>bge</tt>. Follow
these examples as a model for how to integrate fault management capability into
your own drivers. Take the following steps to study the complete <tt>bge</tt> driver
code:</p>
<ul><li><p>Go to <a href="http://www.opensolaris.org/os/">OpenSolaris</a>.</p></li>
<li><p>Click <a href="http://cvs.opensolaris.org/source/">Source Browser</a> under the Code heading in the menu on the left side of the page.</p></li>
<li><p>Enter <tt>bge</tt> in the File Path field.</p></li>
<li><p>Click the Search button.</p></li></ul>
<p>Drivers that have been instrumented to provide FMA error report telemetry detect errors
and determine the impact of those errors on the services provided by the
driver. Following the detection of an error, the driver should determine when its
services have been impacted and to what degree.</p><p>An I/O driver must respond immediately to detected errors. Appropriate responses include:</p>
<ul><li><p>Attempt recovery</p></li>
<li><p>Retry an I/O transaction</p></li>
<li><p>Attempt fail-over techniques</p></li>
<li><p>Report the error to the calling application/stack</p></li>
<li><p>If the error cannot be constrained any other way, then panic</p></li></ul>
<p><a name="indexterm-311"></a>Errors detected by the driver are communicated to the fault management daemon as
an <b>ereport</b>. An ereport is a structured event defined by the FMA event
protocol. The event protocol is a specification for a set of common data
fields that must be used to describe all possible error and fault events,
in addition to the list of suspected faults. Ereports are gathered into a
flow of error telemetry and dispatched to the diagnosis engine.</p>

<a name="gemfi"></a><h5>Declaring Fault Management Capabilities</h5>
<a name="indexterm-312"></a><a name="indexterm-313"></a><a name="indexterm-314"></a><p>A hardened device driver must declare its fault management capabilities to the I/O
Fault Management framework. Use the <tt>ddi_fm_init</tt>(9F) function to declare the fault management capabilities
of your driver.</p><pre>void ddi_fm_init(dev_info_t *<i>dip</i>, int *<i>fmcap</i>, ddi_iblock_cookie_t *<i>ibcp</i>)</pre><p><a name="indexterm-315"></a>The <tt>ddi_fm_init()</tt> function can be called from kernel context in a driver <a href="http://docs.sun.com/doc/819-2255/attach-9e?a=view"><tt>attach</tt>(9E)</a>
or <a href="http://docs.sun.com/doc/819-2255/detach-9e?a=view"><tt>detach</tt>(9E)</a> entry point. The <tt>ddi_fm_init()</tt> function usually is called from the
<tt>attach()</tt> entry point. The <tt>ddi_fm_init()</tt> function allocates and initializes resources according to <i>fmcap</i>. The
<i>fmcap</i> parameter must be set to the bitwise-inclusive-OR of the following fault management capabilities:</p>
<ul><li><p><tt>DDI_FM_EREPORT_CAPABLE</tt> - Driver is responsible for and capable of generating FMA protocol error events (ereports) upon detection of an error condition.</p></li>
<li><p><tt>DDI_FM_ACCCHK_CAPABLE</tt> - Driver is responsible for and capable of checking for errors upon completion of one or more access I/O transactions.</p></li>
<li><p><tt>DDI_FM_DMACHK_CAPABLE</tt> - Driver is responsible for and capable of checking for errors upon completion of one or more DMA I/O transactions.</p></li>
<li><p><tt>DDI_FM_ERRCB_CAPABLE</tt> - Driver has an error callback function.</p></li></ul>
<p><a name="indexterm-316"></a>A hardened leaf driver generally sets all these capabilities. However, if its parent
nexus is not capable of supporting any one of the requested capabilities, the
associated bit is cleared and returned as such to the driver. Before returning
from <tt>ddi_fm_init</tt>(9F), the I/O fault services framework creates a set of fault management
capability properties: <tt>fm-ereport-capable</tt>, <tt>fm-accchk-capable</tt>, <tt>fm-dmachk-capable</tt> and <tt>fm-errcb-capable</tt>. The currently supported fault management
capability level is observable by using the <a href="http://docs.sun.com/doc/819-2240/prtconf-1m?a=view"><tt>prtconf</tt>(1M)</a> command.</p><p>To make your driver support administrative selection of fault management capabilities, export and
set the fault management capability level properties to the values described above in
the <a href="http://docs.sun.com/doc/819-2251/driver.conf-4?a=view"><tt>driver.conf</tt>(4)</a> file. The <tt>fm-capable</tt> properties must be set and read prior to
calling <tt>ddi_fm_init()</tt> with the desired capability list.</p><p><a name="indexterm-317"></a><a name="indexterm-318"></a>The following example from the <tt>bge</tt> driver shows the <tt>bge_fm_init()</tt> function, which calls
the <tt>ddi_fm_init</tt>(9F) function. The <tt>bge_fm_init()</tt> function is called in the <tt>bge_attach()</tt> function.</p><pre>static void
bge_fm_init(bge_t *bgep)
{
        ddi_iblock_cookie_t iblk;

        /* Only register with IO Fault Services if we have some capability */
        if (bgep-&gt;fm_capabilities) {
                bge_reg_accattr.devacc_attr_access = DDI_FLAGERR_ACC;
                bge_desc_accattr.devacc_attr_access = DDI_FLAGERR_ACC;
                dma_attr.dma_attr_flags = DDI_DMA_FLAGERR;
                /* 
                 * Register capabilities with IO Fault Services
                 */
                ddi_fm_init(bgep-&gt;devinfo, &amp;bgep-&gt;fm_capabilities, &amp;iblk);
                /*
                 * Initialize pci ereport capabilities if ereport capable
                 */
                if (DDI_FM_EREPORT_CAP(bgep-&gt;fm_capabilities) ||
                    DDI_FM_ERRCB_CAP(bgep-&gt;fm_capabilities))
                        pci_ereport_setup(bgep-&gt;devinfo);
                /*
                 * Register error callback if error callback capable
                 */
                if (DDI_FM_ERRCB_CAP(bgep-&gt;fm_capabilities))
                        ddi_fm_handler_register(bgep-&gt;devinfo,
                        bge_fm_error_cb, (void*) bgep);
        } else {
                /*
                 * These fields have to be cleared of FMA if there are no
                 * FMA capabilities at runtime.
                 */
                bge_reg_accattr.devacc_attr_access = DDI_DEFAULT_ACC;
                bge_desc_accattr.devacc_attr_access = DDI_DEFAULT_ACC;
                dma_attr.dma_attr_flags = 0;
        }
}</pre>

<a name="gemhm"></a><h5>Cleaning Up Fault Management Resources</h5>
<a name="indexterm-319"></a><a name="indexterm-320"></a><a name="indexterm-321"></a><p>The <tt>ddi_fm_fini</tt>(9F) function cleans up resources allocated to support fault management for <i>dip</i>.</p><pre>void ddi_fm_fini(dev_info_t *<i>dip</i>)</pre><p>The <tt>ddi_fm_fini()</tt> function can be called from kernel context in a driver <a href="http://docs.sun.com/doc/819-2255/attach-9e?a=view"><tt>attach</tt>(9E)</a>
or <a href="http://docs.sun.com/doc/819-2255/detach-9e?a=view"><tt>detach</tt>(9E)</a> entry point.</p><p><a name="indexterm-322"></a><a name="indexterm-323"></a>The following example from the <tt>bge</tt> driver shows the <tt>bge_fm_fini()</tt> function, which calls
the <tt>ddi_fm_fini</tt>(9F) function. The <tt>bge_fm_fini()</tt> function is called in the <tt>bge_unattach()</tt> function, which
is called in both the <tt>bge_attach()</tt> and <tt>bge_detach()</tt> functions.</p><pre>static void
bge_fm_fini(bge_t *bgep)
{
        /* Only unregister FMA capabilities if we registered some */
        if (bgep-&gt;fm_capabilities) {
                /*
                 * Release any resources allocated by pci_ereport_setup()
                 */
                if (DDI_FM_EREPORT_CAP(bgep-&gt;fm_capabilities) ||
                    DDI_FM_ERRCB_CAP(bgep-&gt;fm_capabilities))
                        pci_ereport_teardown(bgep-&gt;devinfo);
                /*
                 * Un-register error callback if error callback capable
                 */
                if (DDI_FM_ERRCB_CAP(bgep-&gt;fm_capabilities))
                        ddi_fm_handler_unregister(bgep-&gt;devinfo);
                /*
                 * Unregister from IO Fault Services
                 */
                ddi_fm_fini(bgep-&gt;devinfo);
        }
}</pre>

<a name="gemgx"></a><h5>Getting the Fault Management Capability Bit Mask</h5>
<a name="indexterm-324"></a><a name="indexterm-325"></a><a name="indexterm-326"></a><p>The <tt>ddi_fm_capable</tt>(9F) function returns the capability bit mask currently set for <i>dip</i>.</p><pre>void ddi_fm_capable(dev_info_t *<i>dip</i>)</pre>

<a name="gemfl"></a><h5>Reporting Errors</h5>
<p>This section provides information about the following topics:</p>
<ul><li><p><a href="#gemfu">Queueing an Error Event</a> discusses how to queue error events.</p></li>
<li><p><a href="#gemfk">Detecting and Reporting PCI-Related Errors</a> describes how to report PCI-related errors.</p></li>
<li><p><a href="#gemha">Reporting Standard I/O Controller Errors</a> describes how to report standard I/O controller errors.</p></li>
<li><p><a href="#gemgp">Service Impact Function</a> discusses how to report whether an error has impacted the services provided by a device.</p></li></ul>


<a name="gemfu"></a><h5>Queueing an Error Event</h5>
<a name="indexterm-327"></a><a name="indexterm-328"></a><a name="indexterm-329"></a><a name="indexterm-330"></a><a name="indexterm-331"></a><p>The <tt>ddi_fm_ereport_post</tt>(9F) function causes an ereport event to be queued for delivery to
the fault manager daemon, <a href="http://docs.sun.com/doc/819-2240/fmd-1m?a=view"><tt>fmd</tt>(1M)</a>.</p><pre>void ddi_fm_ereport_post(dev_info_t *<i>dip</i>, 
                         const char *<i>error_class</i>, 
                         uint64_t <i>ena</i>, 
                         int <i>sflag</i>, ...)</pre><p>The <i>sflag</i> parameter indicates whether the caller is willing to wait for system
memory and event channel resources to become available.</p><p>The ENA indicates the <b>Error Numeric Association</b> (ENA) for this error report. The ENA might
have been initialized and obtained from another error detecting software module such as
a bus nexus driver. If the ENA is set to 0, it will
be initialized by <tt>ddi_fm_ereport_post()</tt>.</p><p>The name-value pair (<i>nvpair</i>) variable argument list contains one or more name, type,
value pointer <i>nvpair</i> tuples for non-array <tt>data_type_t</tt> types or one or more name,
type, number of element, value pointer tuples for <tt>data_type_t</tt> array types. The <i>nvpair</i> tuples
make up the ereport event payload required for diagnosis. The end of the
argument list is specified by <tt>NULL</tt>.</p><p><a name="indexterm-332"></a><a name="indexterm-333"></a><a name="indexterm-334"></a><a name="indexterm-335"></a>The ereport class names and payloads described in <a href="#gemha">Reporting Standard I/O Controller Errors</a> for I/O controllers are
used as appropriate for <i>error_class</i>. Other ereport class names and payloads can
be defined, but they must be registered in the Sun <b>event registry</b> and accompanied by
driver specific diagnosis engine software, or the Eversholt fault tree (eft) rules. For
more information about the Sun event registry and about Eversholt fault tree rules,
see the <a href="http://www.opensolaris.org/os/community/fm/">Fault Management community</a> on <a href="http://www.opensolaris.org/os/">OpenSolaris</a>.</p><pre>void
bge_fm_ereport(bge_t *bgep, char *detail)
{
        uint64_t ena;
        char buf[FM_MAX_CLASS];
        (void) snprintf(buf, FM_MAX_CLASS, "%s.%s", DDI_FM_DEVICE, detail);
        ena = fm_ena_generate(0, FM_ENA_FMT1);
        if (DDI_FM_EREPORT_CAP(bgep-&gt;fm_capabilities)) {
                ddi_fm_ereport_post(bgep-&gt;devinfo, buf, ena, DDI_NOSLEEP,
                    FM_VERSION, DATA_TYPE_UINT8, FM_EREPORT_VERS0, NULL);
        }
}</pre>

<a name="gemfk"></a><h5>Detecting and Reporting PCI-Related Errors</h5>
<a name="indexterm-336"></a><a name="indexterm-337"></a><a name="indexterm-338"></a><a name="indexterm-339"></a><a name="indexterm-340"></a><a name="indexterm-341"></a><p>PCI-related errors, including PCI, PCI-X, and PCI-E, are automatically detected and reported when
you use <tt>pci_ereport_post</tt>(9F).</p><pre>void pci_ereport_post(dev_info_t *<i>dip</i>, ddi_fm_error_t *<i>derr</i>, uint16_t *<i>xx_status</i>)</pre><p>Drivers do not need to generate driver-specific ereports for errors that occur in
the PCI Local Bus configuration status registers. The <tt>pci_ereport_post()</tt> function can report
data parity errors, master aborts, target aborts, signaled system errors, and much more.</p><p>If <tt>pci_ereport_post()</tt> is to be used by a driver, then <tt>pci_ereport_setup</tt>(9F) must have
been previously called during the driver's <tt>attach</tt>(9E) routine, and <tt>pci_ereport_teardown</tt>(9F) must subsequently be called during
the driver's <tt>detach</tt>(9E) routine.</p><p>The <tt>bge</tt> code samples below show the <tt>bge</tt> driver invoking the <tt>pci_ereport_post()</tt> function
from the driver's error handler. See also  <a href="#gemie">Registering an Error Handler</a>.</p><pre>/*
 * The I/O fault service error handling callback function
 */
/*ARGSUSED*/
static int
bge_fm_error_cb(dev_info_t *dip, ddi_fm_error_t *err, const void *impl_data)
{
     /*
      * as the driver can always deal with an error 
      * in any dma or access handle, we can just return 
      * the fme_status value.
      */
     pci_ereport_post(dip, err, NULL);
     return (err-&gt;fme_status);
}</pre>

<a name="gemha"></a><h5>Reporting Standard I/O Controller Errors</h5>
<a name="indexterm-342"></a><a name="indexterm-343"></a><a name="indexterm-344"></a><p>A standard set of device ereports is defined for commonly seen errors for
I/O controllers. These ereports should be generated whenever one of the error symptoms
described in this section is detected.</p><p>The ereports described in this section are dispatched for diagnosis to the eft
diagnosis engine, which uses a common set of standard rules to diagnose them.
Any other errors detected by device drivers must be defined as ereport events
in the Sun event registry and must be accompanied by device specific diagnosis
software or eft rules.</p><dl><dt>DDI_FM_DEVICE_INVAL_STATE</dt>
<dd><p>The driver has detected that the device is in an invalid state.</p><p>A driver should post an error when it detects that the data it transmits or receives appear to be invalid. For example, in the <tt>bge</tt> code, the <tt>bge_chip_reset()</tt> and <tt>bge_receive_ring()</tt> routines generate the <tt>ereport.io.device.inval_state</tt> error when these routines detect invalid data.</p><pre>/*
 * The SEND INDEX registers should be reset to zero by the
 * global chip reset; if they're not, there'll be trouble
 * later on.
 */
sx0 = bge_reg_get32(bgep, NIC_DIAG_SEND_INDEX_REG(0));
if (sx0 != 0) {
    BGE_REPORT((bgep, "SEND INDEX - device didn't RESET"));
    bge_fm_ereport(bgep, DDI_FM_DEVICE_INVAL_STATE);
    return (DDI_FAILURE);
}
/* ... */
/*
 * Sync (all) the receive ring descriptors
 * before accepting the packets they describe
 */
DMA_SYNC(rrp-&gt;desc, DDI_DMA_SYNC_FORKERNEL);
if (*rrp-&gt;prod_index_p &gt;= rrp-&gt;desc.nslots) {
    bgep-&gt;bge_chip_state = BGE_CHIP_ERROR;
    bge_fm_ereport(bgep, DDI_FM_DEVICE_INVAL_STATE);
    return (NULL);
}</pre></dd>
<dt>DDI_FM_DEVICE_INTERN_CORR</dt>
<dd><p>The device has reported a self-corrected internal error. For example, a correctable ECC error has been detected by the hardware in an internal buffer within the device.</p><p>This error flag is not used in the <tt>bge</tt> driver. See the <tt>nxge_fm.c</tt> file on OpenSolaris for examples that use this error. Take the following steps to study the <tt>nxge</tt> driver code:</p>
<ul><li><p>Go to <a href="http://www.opensolaris.org/os/">OpenSolaris</a>.</p></li>
<li><p>Click <a href="http://cvs.opensolaris.org/source/">Source Browser</a> under the Code heading in the menu on the left side of the page.</p></li>
<li><p>Enter <tt>nxge</tt> in the File Path field.</p></li>
<li><p>Click the Search button.</p></li></ul>
</dd>
<dt>DDI_FM_DEVICE_INTERN_UNCORR</dt>
<dd><p>The device has reported an uncorrectable internal error. For example, an uncorrectable ECC error has been detected by the hardware in an internal buffer within the device.</p><p>This error flag is not used in the <tt>bge</tt> driver. See the <tt>nxge_fm.c</tt> file on OpenSolaris for examples that use this error.</p></dd>
<dt>DDI_FM_DEVICE_STALL</dt>
<dd><p>The driver has detected that data transfer has stalled unexpectedly.</p><p>The <tt>bge_factotum_stall_check()</tt> routine provides an example of stall detection.</p><pre>dogval = bge_atomic_shl32(&amp;bgep-&gt;watchdog, 1);
if (dogval &lt; bge_watchdog_count)
    return (B_FALSE);

BGE_REPORT((bgep, "Tx stall detected, 
watchdog code 0x%x", dogval));
bge_fm_ereport(bgep, DDI_FM_DEVICE_STALL);
return (B_TRUE);</pre></dd>
<dt>DDI_FM_DEVICE_NO_RESPONSE</dt>
<dd><p>The device is not responding to a driver command.</p><pre>bge_chip_poll_engine(bge_t *bgep, bge_regno_t regno,
        uint32_t mask, uint32_t val)
{
        uint32_t regval;
        uint32_t n;

        for (n = 200; n; --n) {
                regval = bge_reg_get32(bgep, regno);
                if ((regval &amp; mask) == val)
                        return (B_TRUE);
                drv_usecwait(100);
        }
        bge_fm_ereport(bgep, DDI_FM_DEVICE_NO_RESPONSE);
        return (B_FALSE);
}</pre></dd>
<dt>DDI_FM_DEVICE_BADINT_LIMIT</dt>
<dd><p>The device has raised too many consecutive invalid interrupts.</p><p><a name="indexterm-345"></a><a name="indexterm-346"></a>The <tt>bge_intr()</tt> routine within the <tt>bge</tt> driver provides an example of stuck interrupt detection. The <tt>bge_fm_ereport()</tt> function is a wrapper for the <tt>ddi_fm_ereport_post</tt>(9F) function. See the <tt>bge_fm_ereport()</tt> example in <a href="#gemfu">Queueing an Error Event</a></p><pre>if (bgep-&gt;missed_dmas &gt;= bge_dma_miss_limit) {
    /*
     * If this happens multiple times in a row,
     * it means DMA is just not working.  Maybe
     * the chip has failed, or maybe there's a
     * problem on the PCI bus or in the host-PCI
     * bridge (Tomatillo).
     *
     * At all events, we want to stop further
     * interrupts and let the recovery code take
     * over to see whether anything can be done
     * about it ...
     */
    bge_fm_ereport(bgep,
        DDI_FM_DEVICE_BADINT_LIMIT);
    goto chip_stop;
}</pre></dd>
</dl>


<a name="gemgp"></a><h5>Service Impact Function</h5>
<a name="indexterm-347"></a><a name="indexterm-348"></a><a name="indexterm-349"></a><a name="indexterm-350"></a><p>A fault management capable driver must indicate whether or not an error has
impacted the services provided by a device. Following detection of an error and,
if necessary, a shutdown of services, the driver should invoke the <tt>ddi_fm_service_impact</tt>(9F) routine
to reflect the current service state of the device instance. The service state
can be used by diagnosis and recovery software to help identify or react
to the problem.</p><p>The <tt>ddi_fm_service_impact()</tt> routine should be called both when an error has been detected
by the driver itself, and when the framework has detected an error and
marked an access or DMA handle as faulty.</p><pre>void ddi_fm_service_impact(dev_info_t *<i>dip</i>, int <i>svc_impact</i>)</pre><p>The following service impact values (<i>svc_impact</i>) are accepted by <tt>ddi_fm_service_impact()</tt>:</p><dl><dt>DDI_SERVICE_LOST</dt>
<dd><p>The service provided by the device is unavailable due to a device fault or software defect.</p></dd>
<dt>DDI_SERVICE_DEGRADED</dt>
<dd><p>The driver is unable to provide normal service, but the driver can provide a partial or degraded level of service. For example, the driver might have to make repeated attempts to perform an operation before it succeeds, or it might be running at less that its configured speed.</p></dd>
<dt>DDI_SERVICE_UNAFFECTED</dt>
<dd><p>The driver has detected an error, but the services provided by the device instance are unaffected.</p></dd>
<dt>DDI_SERVICE_RESTORED</dt>
<dd><p>All of the device's services have been restored.</p></dd>
</dl>
<p>The call to <tt>ddi_fm_service_impact()</tt> generates the following ereports on behalf of the driver,
based on the service impact argument to the service impact routine:</p>
<ul><li><p><tt>ereport.io.service.lost</tt></p></li>
<li><p><tt>ereport.io.service.degraded</tt></p></li>
<li><p><tt>ereport.io.service.unaffected</tt></p></li>
<li><p><tt>ereport.io.service.restored</tt></p></li></ul>
<p>In the following <tt>bge</tt> code, the driver determines that it is unable to
successfully restart transmitting or receiving packets as the result of an error. The
service state of the device transitions to DDI_SERVICE_LOST.</p><pre>/*
 * All OK, reinitialize hardware and kick off GLD scheduling
 */
mutex_enter(bgep-&gt;genlock);
if (bge_restart(bgep, B_TRUE) != DDI_SUCCESS) {
    (void) bge_check_acc_handle(bgep, bgep-&gt;cfg_handle);
    (void) bge_check_acc_handle(bgep, bgep-&gt;io_handle);
    ddi_fm_service_impact(bgep-&gt;devinfo, DDI_SERVICE_LOST);
    mutex_exit(bgep-&gt;genlock);
    return (DDI_FAILURE);
}</pre>
<hr><p><b>Note - </b>The <tt>ddi_fm_service_impact()</tt> function should not be called from the registered callback routine.</p>
<hr>


<a name="gemhz"></a><h5>Access Attributes Structure</h5>
<a name="indexterm-351"></a><a name="indexterm-352"></a><a name="indexterm-353"></a><p>A <tt>DDI_FM_ACCCHK_CAPABLE</tt> device driver must set its access attributes to indicate that it
is capable of handling programmed I/O (PIO) access errors that occur during a
register read or write. The <tt>devacc_attr_access</tt> field in the <a href="http://docs.sun.com/doc/819-2257/ddi-device-acc-attr-9s?a=view"><tt>ddi_device_acc_attr</tt>(9S)</a> structure should be
set as an indicator to the system that the driver is capable
of checking for and handling data path errors. The <tt>ddi_device_acc_attr</tt> structure contains the following
members:</p><pre>ushort_t devacc_attr_version;
uchar_t devacc_attr_endian_flags;
uchar_t devacc_attr_dataorder;
uchar_t devacc_attr_access;             /* access error protection */</pre><p>Errors detected in the data path to or from a device can
be processed by one or more of the device driver's nexus parents.</p><p>The <tt>devacc_attr_access</tt> field can be set to the following values:</p><dl><dt>DDI_DEFAULT_ACC</dt>
<dd><p>This flag indicates the system will take the default action (panic if appropriate) when an error occurs. This attribute cannot be used by DDI_FM_ACCCHK_CAPABLE drivers.</p></dd>
<dt>DDI_FLAGERR_ACC</dt>
<dd><p><a name="indexterm-354"></a><a name="indexterm-355"></a>This flag indicates that the system will attempt to handle and recover from an error associated with the access handle. The driver should use the techniques described in <a href="defensive-programming.html">Defensive Programming Techniques for Solaris Device Drivers</a> and should use <tt>ddi_fm_acc_err_get</tt>(9F) to regularly check for errors before the driver allows data to be passed back to the calling application.</p><p>The DDI_FLAGERR_ACC flag provides:</p>
<ul><li><p>Error notification via the driver callback</p></li>
<li><p>An error condition observable via <tt>ddi_fm_acc_err_get</tt>(9F)</p></li></ul>
</dd>
<dt>DDI_CAUTIOUS_ACC</dt>
<dd><p><a name="indexterm-356"></a>The DDI_CAUTIOUS_ACC flag provides a high level of protection for each Programmed I/O access made by the driver.</p>
<hr><p><b>Note - </b><a name="indexterm-357"></a><a name="indexterm-358"></a><a name="indexterm-359"></a>Use of this flag will cause a significant impact on the performance of the driver.</p>
<hr>
<p>The DDI_CAUTIOUS_ACC flag signifies that an error is anticipated by the accessing driver. The system attempts to handle and recover from an error associated with this handle as gracefully as possible. No error reports are generated as a result, but the handle's <tt>fme_status</tt> flag is set to DDI_FM_NONFATAL. This flag is functionally equivalent to <a href="http://docs.sun.com/doc/819-2256/ddi-peek-9f?a=view"><tt>ddi_peek</tt>(9F)</a> and <a href="http://docs.sun.com/doc/819-2256/ddi-poke-9f?a=view"><tt>ddi_poke</tt>(9F)</a>.</p><p><a name="indexterm-360"></a><a name="indexterm-361"></a><a name="indexterm-362"></a><a name="indexterm-363"></a>The use of the DDI_CAUTIOUS_ACC provides:</p>
<ul><li><p>Exclusive access to the bus</p></li>
<li><p>On trap protection - (<tt>ddi_peek()</tt> and <tt>ddi_poke()</tt>)</p></li>
<li><p>Error notification through the driver callback registered with <tt>ddi_fm_handler_register</tt>(9F)</p></li>
<li><p>An error condition observable through <tt>ddi_fm_acc_err_get</tt>(9F)</p></li></ul>
</dd>
</dl>
<p>Generally, drivers should check for data path errors at appropriate junctures in the
code path to guarantee consistent data and to ensure that proper error status
is presented in the I/O software stack.</p><p>DDI_FM_ACCCHK_CAPABLE device drivers must set their <tt>devacc_attr_access</tt> field to DDI_FLAGERR_ACC or DDI_CAUTIOUS_ACC.</p>

<a name="gemhh"></a><h5>DMA Attributes Structure</h5>
<a name="indexterm-364"></a><a name="indexterm-365"></a><a name="indexterm-366"></a><a name="indexterm-367"></a><p>As with access handle setup, a DDI_FM_DMACHK_CAPABLE device driver must set the <tt>dma_attr_flag</tt>
field of its <a href="http://docs.sun.com/doc/819-2257/ddi-dma-attr-9s?a=view"><tt>ddi_dma_attr</tt>(9S)</a> structure to the DDI_DMA_FLAGERR flag. The system attempts to
recover from an error associated with a handle that has DDI_DMA_FLAGERR set. The
<tt>ddi_dma_attr</tt> structure contains the following members:</p><pre>uint_t          dma_attr_version;       /* version number */
uint64_t        dma_attr_addr_lo;       /* low DMA address range */
uint64_t        dma_attr_addr_hi;       /* high DMA address range */
uint64_t        dma_attr_count_max;     /* DMA counter register */
uint64_t        dma_attr_align;         /* DMA address alignment */
uint_t          dma_attr_burstsizes;    /* DMA burstsizes */
uint32_t        dma_attr_minxfer;       /* min effective DMA size */
uint64_t        dma_attr_maxxfer;       /* max DMA xfer size */
uint64_t        dma_attr_seg;           /* segment boundary */
int             dma_attr_sgllen;        /* s/g length */
uint32_t        dma_attr_granular;      /* granularity of device */
uint_t          dma_attr_flags;         /* Bus specific DMA flags */</pre><p><a name="indexterm-368"></a><a name="indexterm-369"></a>Drivers that set the DDI_DMA_FLAGERR flag should use the techniques described in <a href="defensive-programming.html">Defensive Programming Techniques for Solaris Device Drivers</a>
and should use <tt>ddi_fm_dma_err_get</tt>(9F) to check for data path errors whenever DMA transactions
are completed or at significant points within the code path. This ensures consistent
data and proper error status presented to the I/O software stack.</p><p>Use of DDI_DMA_FLAGERR provides:</p>
<ul><li><p>Error notification via the driver callback registered with <tt>ddi_fm_handler_register()</tt></p></li>
<li><p>An error condition observable by calling <tt>ddi_fm_dma_err_get()</tt></p></li></ul>


<a name="gemfy"></a><h5>Getting Error Status</h5>
<p>If a fault has occurred that affects the resource mapped by the
handle, the error status structure is updated to reflect error information captured during error
handling by a bus or other device driver in the I/O data
path.</p><pre>void ddi_fm_dma_err_get(ddi_dma_handle_t handle, ddi_fm_error_t *de, int version)

void ddi_fm_acc_err_get(ddi_acc_handle_t handle, ddi_fm_error_t *de, int version)</pre><p>The <tt>ddi_fm_acc_err_get</tt>(9F) and <tt>ddi_fm_dma_err_get</tt>(9F) functions return the error status for a DMA or
access handle respectively. The version field should be set to DDI_FME_VERSION.</p><p><a name="indexterm-370"></a><a name="indexterm-371"></a>An error for an access handle means that an error has been detected
that has affected PIO transactions to or from the device using that access
handle. Any data received by the driver, for example via a recent <a href="http://docs.sun.com/doc/819-2256/ddi-get8-9f?a=view"><tt>ddi_get8</tt>(9F)</a>
call, should be considered potentially corrupt. Any data sent to the device, for example
via a recent <a href="http://docs.sun.com/doc/819-2256/ddi-put32-9f?a=view"><tt>ddi_put32</tt>(9F)</a> call might also have been corrupted or might not
have been received at all. The underlying fault might, however, be transient, and
the driver can therefore attempt to recover by calling <tt>ddi_fm_acc_err_clear</tt>(9F), resetting the device to
get it back into a known state, and retrying any potentially failed transactions.</p><p>If an error is indicated for a DMA handle, it implies that
an error has been detected that has (or will) affect DMA transactions between
the device and the memory currently bound to the handle (or most recently
bound, if the handle is currently unbound). Possible causes include the failure of
a component in the DMA data path, or an attempt by the device
to make an invalid DMA access. The driver might be able to continue
by retrying and reallocating memory. The contents of the memory currently (or previously)
bound to the handle should be regarded as indeterminate and should be released
back to the system. The fault indication associated with the current transaction is
lost once the handle is bound or re-bound, but because the fault might
persist, future DMA operations might not succeed.</p>

<a name="gemfr"></a><h5>Clearing Errors</h5>
<p>These routines should be called when the driver wants to retry a
request after an error was detected by the handle without needing to free
and reallocate the handle first.</p><pre>void ddi_fm_acc_err_clear(ddi_acc_handle_t handle, int version)

void ddi_fm_dma_err_clear(ddi_dma_handle_t handle, int version)</pre>

<a name="gemie"></a><h5>Registering an Error Handler</h5>
<p>Error handling activity might begin at the time that the error is
detected by the operating system via a trap or error interrupt. If the
software responsible for handling the error (the error handler) cannot immediately isolate the device
that was involved in the failed I/O operation, it must attempt to
find a software module within the device tree that can perform the error
isolation. The Solaris device tree provides a structural means to propagate nexus driver error
handling activities to children who might have a more detailed understanding of the
error and can capture error state and isolate the problem device.</p><p><a name="indexterm-372"></a><a name="indexterm-373"></a><a name="indexterm-374"></a><a name="indexterm-375"></a>A driver can register an error handler callback with the I/O Fault Services
Framework. The error handler should be specific to the type of error and
subsystem where error detection has occurred. When the driver's error handler routine is
invoked, the driver must check for any outstanding errors associated with device transactions
and generate ereport events. The driver must also return error handler status in
its <tt>ddi_fm_error</tt> structure. For example, if it has been determined that the system's
integrity has been compromised, the most appropriate action might be for the error
handler to panic the system.</p><p>The callback is invoked by a parent nexus driver when an error
might be associated with a particular device instance. Device drivers that register error handlers
must be DDI_FM_ERRCB_CAPABLE.</p><pre>void ddi_fm_handler_register(dev_info_t *<i>dip</i>, ddi_err_func_t <i>handler</i>, void *<i>impl_data</i>)</pre><p><a name="indexterm-376"></a><a name="indexterm-377"></a>The <tt>ddi_fm_handler_register</tt>(9F) routine registers an error handler callback with the I/O fault services
framework. The <tt>ddi_fm_handler_register()</tt> function should be called in the driver's <a href="http://docs.sun.com/doc/819-2255/attach-9e?a=view"><tt>attach</tt>(9E)</a> entry point
for callback registration following driver fault management initialization (<tt>ddi_fm_init()</tt>).</p><p><a name="indexterm-378"></a><a name="indexterm-379"></a>The error handler callback function must do the following:</p>
<ul><li><p>Check for any outstanding hardware errors associated with device transactions, and generate ereport events for diagnosis. For a PCI, PCI-x, or PCI express device this can generally be done using <tt>pci_ereport_post()</tt> as described in <a href="#gemfk">Detecting and Reporting PCI-Related Errors</a>.</p></li>
<li><p><a name="indexterm-380"></a><a name="indexterm-381"></a>Return error handler status in its <tt>ddi_fm_error</tt> structure:</p>
<ul><li><p>DDI_FM_OK</p></li>
<li><p>DDI_FM_FATAL</p></li>
<li><p>DDI_FM_NONFATAL</p></li>
<li><p>DDI_FM_UNKNOWN</p></li></ul>
</li></ul>
<p>Driver error handlers receive the following:</p>
<ul><li><p>A pointer to a device instance (<i>dip</i>) under the driver's control</p></li>
<li><p>A data structure (<tt>ddi_fm_error</tt>) that contains common fault management data and status for error handling</p></li>
<li><p>A pointer to any implementation specific data (<i>impl_data</i>) specified at the time of the handler's registration</p></li></ul>
<p><a name="indexterm-382"></a><a name="indexterm-383"></a>The <tt>ddi_fm_handler_register()</tt> and <tt>ddi_fm_handler_unregister()</tt> routines must be called from kernel context in a
driver's <tt>attach</tt>(9E) or <tt>detach</tt>(9E) entry point. The registered error handler callback can be called
from kernel, interrupt, or high-level interrupt context. Therefore the error handler:</p>
<ul><li><p>Must not hold locks</p></li>
<li><p>Must not sleep waiting for resources</p></li></ul>
<p>A device driver is responsible for:</p>
<ul><li><p>Isolating the device instance that might have caused errors</p></li>
<li><p>Recovering transactions associated with errors</p></li>
<li><p>Reporting the service impact of errors</p></li>
<li><p>Scheduling device shutdown for errors considered fatal</p></li></ul>
<p>These actions can be carried out within the error handler function. However, because
of the restrictions on locking and because the error handler function does not
always know the context of what the driver was doing at the point
where the fault occurred, it is  more usual for these actions
to be carried out following inline calls to <tt>ddi_fm_acc_err_get</tt>(9F) and <tt>ddi_fm_dma_err_get</tt>(9F) within the normal paths
of the driver as described previously.</p><pre>/*
 * The I/O fault service error handling callback function
 */
/*ARGSUSED*/
static int
bge_fm_error_cb(dev_info_t *dip, ddi_fm_error_t *err, const void *impl_data)
{
     /*
      * as the driver can always deal with an error 
      * in any dma or access handle, we can just return 
      * the fme_status value.
      */
     pci_ereport_post(dip, err, NULL);
     return (err-&gt;fme_status);
}</pre>

<a name="gemhd"></a><h5>Fault Management Data and Status Structure</h5>
<a name="indexterm-384"></a><a name="indexterm-385"></a><a name="indexterm-386"></a><p>Driver error handling callbacks are passed a pointer to a data structure that
contains common fault management data and status for error handling.</p><p>The data structure <tt>ddi_fm_error</tt> contains an FMA protocol ENA for the current error,
the status of the error handler callback, an error expectation flag, and any
potential access or DMA handles associated with an error detected by the parent
nexus.</p><dl><dt><tt>fme_ena</tt></dt>
<dd><p>This field is initialized by the calling parent nexus and might have been incremented along the error handling propagation chain before reaching the driver's registered callback routine. If the driver detects a related error of its own, it should increment this ENA prior to calling <tt>ddi_fm_ereport_post()</tt>.</p></dd>
<dt><tt>fme_acc_handle</tt>, <tt>fme_dma_handle</tt></dt>
<dd><p>These fields contain a valid access or DMA handle if the parent was able to associate an error detected at its level to a handle mapped or bound by the device driver.</p></dd>
<dt><tt>fme_flag</tt></dt>
<dd><p>The <tt>fme_flag</tt> is set to DDI_FM_ERR_EXPECTED if the calling parent determines the error was the result of a DDI_CAUTIOUS_ACC protected operation. In this case, the <tt>fme_acc_handle</tt> is valid and the driver should check for and report only errors not associated with the DDI_CAUTIOUS_ACC protected operation. Otherwise, <tt>fme_flag</tt> is set to DDI_FM_ERR_UNEXPECTED and the driver must perform the full range of error handling tasks.</p></dd>
<dt><tt>fme_status</tt></dt>
<dd><p>Upon return from its error handler callback, the driver must set <tt>fme_status</tt> to one of the following values:</p>
<ul><li><p>DDI_FM_OK &ndash; No errors were detected and the operational state of this device instance remains the same.</p></li>
<li><p><a name="indexterm-387"></a><a name="indexterm-388"></a>DDI_FM_FATAL &ndash; An error has occurred and the driver considers it to be fatal to the system. For example, a call to <tt>pci_ereport_post</tt>(9F) might have detected a system fatal error. In this case, the driver should report any additional error information it might have in the context of the driver.</p></li>
<li><p>DDI_FM_NONFATAL &ndash; An error has been detected by the driver but is not considered fatal to the system. The driver has identified the error and has either isolated the error or is committing that it will isolate the error.</p></li>
<li><p>DDI_FM_UNKNOWN &ndash; An error has been detected, but the driver is unable to isolate the device or determine the impact of the error on the operational state of the system.</p></li></ul>
</dd>
</dl>


<a name="gemfs"></a><h4>Diagnosing Faults</h4>
<a name="indexterm-389"></a><a name="indexterm-390"></a><a name="indexterm-391"></a><a name="indexterm-392"></a><a name="indexterm-393"></a><a name="indexterm-394"></a><a name="indexterm-395"></a><a name="indexterm-396"></a><p>The fault management daemon, <a href="http://docs.sun.com/doc/819-2240/fmd-1m?a=view"><tt>fmd</tt>(1M)</a>, provides a programming interface for the development of
diagnosis engine (DE) plug-in modules. A DE can be written to consume
and diagnose any error telemetry or specific error telemetries. The eft DE was designed
to diagnose any number of ereport classes based on diagnosis rules specified in
the Eversholt language.</p>

<a name="gemge"></a><h5>Standard Leaf Device Diagnosis</h5>
<p>Most I/O subsystems use the eft DE and rules sets to diagnose
device and device driver related problems. A standard set of ereports, listed in
<a href="#gemha">Reporting Standard I/O Controller Errors</a>, has been specified for PCI leaf devices. Accompanying these ereports are eft
diagnosis rules that take the telemetry and identify the associated device fault. Drivers that
generate these ereports do not need to deliver any additional diagnosis software or
eft rules.</p><p>The detection and generation of these ereports produces the following fault events:</p><dl><dt><tt>fault.io.pci.bus-linkerr</tt></dt>
<dd><p>A hardware fault on the PCI bus</p></dd>
<dt><tt>fault.io.pci.device-interr</tt></dt>
<dd><p>A hardware fault within the device</p></dd>
<dt><tt>fault.io.pci.device-invreq</tt></dt>
<dd><p>A hardware fault in the device or a defect in the driver that causes the device to send an invalid request</p></dd>
<dt><tt>fault.io.pci.device-noresp</tt></dt>
<dd><p>A hardware fault in the device that causes the driver not to respond to a valid request</p></dd>
<dt><tt>fault.io.pciex.bus-linkerr</tt></dt>
<dd><p>A hardware fault on the link</p></dd>
<dt><tt>fault.io.pciex.bus-noresp</tt></dt>
<dd><p>The link going down so that a device cannot respond to a valid request</p></dd>
<dt><tt>fault.io.pciex.device-interr</tt></dt>
<dd><p>A hardware fault within the device</p></dd>
<dt><tt>fault.io.pciex.device-invreq</tt></dt>
<dd><p>A hardware fault in the device or a defect in the driver that causes the device to send an invalid request</p></dd>
<dt><tt>fault.io.pciex.device-noresp</tt></dt>
<dd><p>A hardware fault in the device causing it not to respond to a valid request</p></dd>
</dl>


<a name="gemia"></a><h5>Specialized Device Diagnosis</h5>
<p>Driver developers who want to generate additional ereports or provide more specialized diagnosis
software or eft rules can do so by writing a C-based DE or
an eft diagnosis rules set. See the  <a href="http://www.opensolaris.org/os/community/fm/">Fault Management community</a> on <a href="http://www.opensolaris.org/os/">OpenSolaris</a> for
information.</p>

<a name="gemhe"></a><h4>Event Registry</h4>
<a name="indexterm-397"></a><a name="indexterm-398"></a><a name="indexterm-399"></a><a name="indexterm-400"></a><a name="indexterm-401"></a><p>The Sun event registry is the central repository of all class names, ereports,
faults, defects, upsets and suspect lists (list.suspect) events. The event registry also contains
the current definitions of all event member payloads, as well as important non-payload
information like internal documentation, suspect lists, dictionaries, and knowledge articles. For example, <tt>ereport.io</tt>
and <tt>fault.io</tt> are two of the base class names that are of particular
importance to I/O driver developers.</p><p>The FMA event protocol defines a base set of payload members that
is supplied with each of the registered events. Developers can also define additional events
that help diagnosis engines (or eft rules) to narrow a suspect list down
to a specific fault.</p>

<a name="gemgu"></a><h4>Glossary</h4>
<p>This section uses the following terms:</p><?GT ELSE><b>Agent<?GT ELSE></b><dd><p>A generic term used to describe fault manager modules that subscribe to fault.*
or list.* events. Agents are used to retire faulty resources, communicate diagnosis results
to Administrators, and bridge to higher-level management frameworks.</p></dd><?GT ELSE><b>ASRU (Automated System Reconfiguration Unit)<?GT ELSE></b><dd><p>The ASRU is a resource that can be disabled by software or hardware
in order to isolate a problem in the system and suppress further error
reports.</p></dd><?GT ELSE><b>DE (Diagnosis Engine)<?GT ELSE></b><dd><p>A fault management module whose purpose is to diagnose problems by subscribing to
one or more classes of incoming error events and using these events to
solve cases associated with each problem on the system.</p></dd><?GT ELSE><b>ENA (Error Numeric Association)<?GT ELSE></b><dd><p>An Error Numeric Association (ENA) is an encoded integer that uniquely identifies an
error report within a given fault region and time period. The ENA also
indicates the relationship of the error to previous errors as a secondary effect.</p></dd><?GT ELSE><b>Error<?GT ELSE></b><dd><p>An unexpected condition, result, signal, or datum. An error is the symptom of
a problem on the system. Each problem typically produces many different kinds of
errors.</p></dd><?GT ELSE><b>ereport (Error Report)<?GT ELSE></b><dd><p>The data captured with a particular error. Error report formats are defined in
advance by creating a class naming the error report and defining a schema
using the Sun event registry.</p></dd><?GT ELSE><b>ereport event (Error Event)<?GT ELSE></b><dd><p>The data structure that represents an instance of an error report. Error events
are represented as name-value pair lists.</p></dd><?GT ELSE><b>Fault<?GT ELSE></b><dd><p>Malfunctioning behavior of a hardware component.</p></dd><?GT ELSE><b>Fault Boundary<?GT ELSE></b><dd><p>Logical partition of hardware or software elements for which a specific set of
faults can be enumerated.</p></dd><?GT ELSE><b>Fault Event<?GT ELSE></b><dd><p>An instance of a fault diagnosis encoded in the protocol.</p></dd><?GT ELSE><b>Fault Manager<?GT ELSE></b><dd><p>Software component responsible for fault diagnosis via one or more diagnosis engines and
state management.</p></dd><?GT ELSE><b>FMRI (Fault Managed Resource Identifier)<?GT ELSE></b><dd><p>An FMRI is a URL-like identifier that acts as the canonical name for
a particular resource in the fault management system. Each FMRI includes a scheme
that identifies the type of resource, and one or more values that are
specific to the scheme. An FMRI can be represented as URL-like string or
as a name-value pair list data structure.</p></dd><?GT ELSE><b>FRU (Field Replaceable Unit)<?GT ELSE></b><dd><p>The FRU is a resource that can be replaced in the field
by a customer or service provider. FRUs can be defined for hardware (for
example system boards) or for software (for example software packages or patches).</p></dd>

<a name="gemhq"></a><h4>Resources</h4>
<p>The following resources provide additional information:</p>
<ul><li><p><a href="http://www.opensolaris.org/os/community/fm/">Fault Management OpenSolaris community</a></p></li>
<li><p><a href="http://www.sun.com/msg/">FMA Messaging web site</a></p></li></ul>

         </div>
      </td>
   </tr>

   <tr class="PageControls" valign="top">
      <td></td>
      <td>
         <table width="100%">
      	   <tr>
      	     <td>
                 <a href="gevsi.html">Previous</a>
             </td>
             <td align="right">
                 <a href="defensive-programming.html">Next</a>
             </td>
           </tr>
         </table>
      </td>
   </tr>
</tbody>
</table>


</body>
</html>

