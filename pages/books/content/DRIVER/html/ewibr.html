<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="en-US">
<head>
<meta http-equiv="Content-type" content="text/html; charset=iso-8859-1">
<title>Implementing the Visual I/O Interfaces in Console Frame Buffer Drivers - Writing Device Drivers</title>
<meta name="robots" content="index,follow">
<meta name="robots" content="index,follow">
<meta name="date" content="2008-08-01">
<meta name="collection" content="reference">
<link rel="stylesheet" type="text/css" href="css/elements.css">
<link rel="stylesheet" type="text/css" href="css/indiana.css">
</head>

<body>


<div class="Masthead">
   <div class="MastheadLogo">
      <a href="http://www.opensolaris.org"><img border="0" src="graphics/header.png"></img></a>
   </div>
   <div class="Title">Writing Device Drivers</div>
</div>

<table class="Layout" border="0" cellspacing="0" width="100%">
<tbody>

   <tr valign="top" class="PageControls">
      <td></td>
      <td>
         <table width="100%">
      	   <tr>
      	     <td>
                 <a href="ewibs.html">Previous</a>
             </td>
             <td align="right">
                 <a href="gcbpn.html">Next</a>
             </td>
           </tr>
         </table>
      </td>
   </tr>
   
   <tr valign="top">
      <td class="Navigation" width="200px"><p class="toc level1"><a href="docinfo.html">Document Information</a></p>
<p class="toc level1 tocsp"><a href="preface-1.html">Preface</a></p>
<p class="toc level1 tocsp"><a href="eqbvu.html">Part&nbsp;I&nbsp;Designing Device Drivers for the Solaris Platform</a></p>
<p class="toc level2"><a href="eqbqn.html">1.&nbsp;&nbsp;Overview of Solaris Device Drivers</a></p>
<p class="toc level2"><a href="kernelovr-77198.html">2.&nbsp;&nbsp;Solaris Kernel and Device Tree</a></p>
<p class="toc level2"><a href="mt-17026.html">3.&nbsp;&nbsp;Multithreading</a></p>
<p class="toc level2"><a href="properties-1.html">4.&nbsp;&nbsp;Properties</a></p>
<p class="toc level2"><a href="events-1.html">5.&nbsp;&nbsp;Managing Events and Queueing Tasks</a></p>
<p class="toc level2"><a href="autoconf-17.html">6.&nbsp;&nbsp;Driver Autoconfiguration</a></p>
<p class="toc level2"><a href="devaccess-3.html">7.&nbsp;&nbsp;Device Access: Programmed I/O</a></p>
<p class="toc level2"><a href="interrupt-15678.html">8.&nbsp;&nbsp;Interrupt Handlers</a></p>
<p class="toc level2"><a href="dma-29901.html">9.&nbsp;&nbsp;Direct Memory Access (DMA)</a></p>
<p class="toc level2"><a href="devmap-24338.html">10.&nbsp;&nbsp;Mapping Device and Kernel Memory</a></p>
<p class="toc level2"><a href="devcnmgt-19679.html">11.&nbsp;&nbsp;Device Context Management</a></p>
<p class="toc level2"><a href="powermgt-37437.html">12.&nbsp;&nbsp;Power Management</a></p>
<p class="toc level2"><a href="gevsi.html">13.&nbsp;&nbsp;Hardening Solaris Drivers</a></p>
<p class="toc level2"><a href="ldi-1.html">14.&nbsp;&nbsp;Layered Driver Interface (LDI)</a></p>
<p class="toc level1 tocsp"><a href="eqbvb.html">Part&nbsp;II&nbsp;Designing Specific Kinds of Device Drivers</a></p>
<p class="toc level2"><a href="character-21002.html">15.&nbsp;&nbsp;Drivers for Character Devices</a></p>
<p class="toc level2"><a href="block-34861.html">16.&nbsp;&nbsp;Drivers for Block Devices</a></p>
<p class="toc level2"><a href="scsi-36812.html">17.&nbsp;&nbsp;SCSI Target Drivers</a></p>
<p class="toc level2"><a href="scsihba-32898.html">18.&nbsp;&nbsp;SCSI Host Bus Adapter Drivers</a></p>
<p class="toc level2"><a href="gld-1.html">19.&nbsp;&nbsp;Drivers for Network Devices</a></p>
<p class="toc level2"><a href="usb-1.html">20.&nbsp;&nbsp;USB Drivers</a></p>
<p class="toc level1 tocsp"><a href="eqbvo.html">Part&nbsp;III&nbsp;Building a Device Driver</a></p>
<p class="toc level2"><a href="loading-15035.html">21.&nbsp;&nbsp;Compiling, Loading, Packaging, and Testing Drivers</a></p>
<p class="toc level2"><a href="debug-60.html">22.&nbsp;&nbsp;Debugging, Testing, and Tuning Device Drivers</a></p>
<p class="toc level2"><a href="coding-practices.html">23.&nbsp;&nbsp;Recommended Coding Practices</a></p>
<p class="toc level1 tocsp"><a href="eqbva.html">Part&nbsp;IV&nbsp;Appendixes</a></p>
<p class="toc level2"><a href="hwovr-18191.html">A.&nbsp;&nbsp;Hardware Overview</a></p>
<p class="toc level2"><a href="ddidkisvc-29227.html">B.&nbsp;&nbsp;Summary of Solaris DDI/DKI Services</a></p>
<p class="toc level2"><a href="lp64-35004.html">C.&nbsp;&nbsp;Making a Device Driver 64-Bit Ready</a></p>
<p class="toc level2"><a href="euazz.html">D.&nbsp;&nbsp;Console Frame Buffer Drivers</a></p>
<p class="toc level3"><a href="eveno.html">Solaris Consoles and the Kernel Terminal Emulator</a></p>
<p class="toc level3"><a href="ewibs.html">Console Visual I/O Interfaces</a></p>
<div class="onpage">
<p class="toc level3"><a href="">Implementing the Visual I/O Interfaces in Console Frame Buffer Drivers</a></p>
</div>
<p class="toc level3"><a href="gcbpn.html">Implementing Polled I/O in Console Frame Buffer Drivers</a></p>
<p class="toc level3"><a href="gcbpl.html">Frame Buffer Specific Configuration Module</a></p>
<p class="toc level3"><a href="gcbrg.html">The X Window System Frame Buffer Specific DDX Module</a></p>
<p class="toc level3"><a href="ewibu.html">Developing, Testing, and Debugging Console Frame Buffer Drivers</a></p>
<p class="toc level1 tocsp"><a href="idx-1.html">Index</a></p>
</td>
      <td class="ContentPane" width="705px">

	 <div class="MainContent">      	 
             

<a name="ewibr"></a><h3>Implementing the Visual I/O Interfaces in Console Frame Buffer Drivers</h3>
<p>Except for the video mode change callback, all activity between the driver and
the kernel terminal emulator is initiated by the <tt>tem</tt> (terminal emulator module). This
means that the <tt>tem</tt> issues all of the <tt>ioctl</tt> commands described in this
document. The following sections provide implementation details for each <tt>ioctl</tt> command. For more information,
see the <a href="http://docs.sun.com/doc/819-2254/visual-io-7i?a=view"><tt>visual_io</tt>(7I)</a> man page and the <tt>/usr/include/sys/visual_io.h</tt> include file. See <a href="ewibs.html#ewprh">Video Mode Change Callback Interface</a>
for detailed information about the video mode change callback function.</p>
<hr><p><b>Note - </b>Each <tt>ioctl</tt> command should determine whether the <tt>FKIOCTL</tt> is set in the <tt>ioctl</tt>
flag argument and return <tt>EPERM</tt> if that bit is not set.</p>
<hr>


<a name="exehb"></a><h4><tt>VIS_DEVINIT</tt></h4>
<p>The <tt>VIS_DEVINIT</tt> <tt>ioctl</tt> command initializes the frame buffer driver as the system console
device. This <tt>ioctl</tt> passes the address of a <tt>vis_devinit</tt> structure.</p><p>The <tt>tem</tt> first loads the address of its video mode change callback function
into the <tt>modechg_cb</tt> field of the <tt>vis_devinit</tt> structure and loads its soft state into
the <tt>modechg_arg</tt> field. The <tt>tem</tt> then issues the <tt>VIS_DEVINIT</tt> <tt>ioctl</tt> command. The frame buffer
driver then initializes itself and returns a summary of its configuration back to
the <tt>tem</tt> by setting the <tt>version</tt>, <tt>width</tt>, <tt>height</tt>, <tt>linebytes</tt>, <tt>depth</tt>, <tt>mode</tt>, and <tt>polledio</tt>
fields in the <tt>vis_devinit</tt> structure. The <tt>vis_devinit</tt> structure is shown in the following code.</p><pre>struct vis_devinit {
      /*
       * This set of fields are used as parameters passed from the
       * layered frame buffer driver to the terminal emulator.
       */
      int             version;        /* Console IO interface rev */
      screen_size_t   width;          /* Width of the device */
      screen_size_t   height;         /* Height of the device */
      screen_size_t   linebytes;      /* Bytes per scan line */
      int             depth;          /* Device depth */
      short           mode;           /* Display mode Mode */
      struct vis_polledio *polledio;  /* Polled output routines */
      /*
       * The following fields are used as parameters passed from the
       * terminal emulator to the underlying frame buffer driver.
       */
      vis_modechg_cb_t modechg_cb;   /* Video mode change callback */
      struct vis_modechg_arg *modechg_arg;  /* Mode change cb arg */
};</pre><p>To implement the <tt>VIS_DEVINIT</tt> <tt>ioctl</tt> command in the console frame buffer driver,
follow these general steps:</p>
<ol><li><p>Define a <tt>struct</tt> to contain the console-specific state. This structure is private to the console frame buffer driver. This structure is referred to as <tt>consinfo</tt> in this appendix. The <tt>consinfo</tt> structure contains information such as:</p>
<ul><li><p>Current size of the blit buffer</p></li>
<li><p>Pointer to the blit buffer</p></li>
<li><p>Color map information</p></li>
<li><p>Driver rendering mode information such as line pitch</p></li>
<li><p>Background color</p></li>
<li><p>Video memory address</p></li>
<li><p>Terminal emulator callback address</p></li></ul>
</li>
<li><p>Allocate memory:</p>
<ol><li><p>Allocate a blit buffer large enough to store a reasonable default sized rectangle of pixels at the highest video depth. Additional memory can be allocated if an incoming request exceeds the size of the buffer. The frame buffer driver's largest font is 12&times;22. Assuming <tt>DEFAULT_HEIGHT</tt> is 12, <tt>DEFAULT_WIDTH</tt> is 22, and the maximum video depth is 32, the buffer size should be 8448 bytes (<tt>DEFAULT_HEIGHT</tt> &times; <tt>DEFAULT_WIDTH</tt> &times; 32).</p></li>
<li><p>Allocate a <tt>vis_polledio</tt> structure.</p></li>
<li><p>Allocate a buffer to hold a cursor. This buffer should be the size of the largest character. This buffer will not change size.</p></li></ol>
</li>
<li><p>Obtain the video change callback address and callback context of the <tt>tem</tt> from <tt>modechg_cb</tt> and <tt>modechg_ctx</tt> and store this information in the <tt>consinfo</tt> structure.</p></li>
<li><p>Populate the <tt>vis_polledio</tt> structure with entry point addresses for the polled display, copy, and cursor functions.</p></li>
<li><p>Provide the appropriate information in the fields of the <tt>vis_devinit</tt> structure that was passed to the driver by the <tt>tem</tt>:</p>
<ol><li><p>Set the <tt>version</tt> field to <tt>VIS_CONS_REV</tt>, which is a constant defined in the <tt>/usr/include/sys/visual_io.h</tt> header file.</p></li>
<li><p>Set the <tt>mode</tt> field to <tt>VIS_PIXEL</tt>.</p></li>
<li><p>Set the <tt>polledio</tt> field to the address of the <tt>vis_polledio</tt> structure.</p></li>
<li><p>Set the <tt>height</tt> field to the video mode height in pixels.</p></li>
<li><p>Set the <tt>width</tt> field to the video mode width in pixels.</p></li>
<li><p>Set the <tt>depth</tt> field to the frame buffer pixel depth in bytes (for example, a 32-bit pixel depth would be 4 bytes).</p></li>
<li><p>Set the <tt>linebytes</tt> field to the value of <tt>height</tt> &times; <tt>width</tt> &times; <tt>depth</tt>.</p><p>This information is sent from the driver to the <tt>tem</tt> by using the <tt>vis_devinit</tt> structure. This information tells the terminal emulator how to render information and pass it to the graphics driver.</p></li></ol>
<p><a name="indexterm-1391"></a><a name="indexterm-1392"></a>Whenever the console frame buffer driver changes its video mode (specifically <tt>height</tt>, <tt>width</tt>, or <tt>depth</tt>), the driver <b>must</b> call the video mode change callback function of the <tt>tem</tt> to update the <tt>vis_devinit</tt> structure and to pass this structure back to the terminal emulator. The terminal emulator passes its mode change callback function address in the <tt>modechg_cb</tt> field of the <tt>vis_devinit</tt> structure. The mode change callback function has the following function signature:</p><pre>typedef void (*vis_modechg_cb_t)
      (struct vis_modechg_arg *, struct vis_devinit *);</pre><p>As shown in the preceding <tt>typedef</tt>, the mode change callback function takes two arguments. The first argument is the <tt>modechg_arg</tt> and the second argument is the <tt>vis_devinit</tt> structure. The <tt>modechg_arg</tt> is sent from the <tt>tem</tt> to the driver during the <tt>VIS_DEVINIT</tt> <tt>ioctl</tt> command initialization. The driver must send the <tt>modechg_arg</tt> back to the <tt>tem</tt> with each video mode change callback.</p></li>
<li><p>Initialize the context of the kernel console. Specific requirements vary depending upon the capability of the graphics device. This initialization might include such steps as setting the draw engine state, initializing the palette, or locating and mapping video memory or the rendering engine so that data can be blitted onto the screen.</p></li>
<li><p>Return the <tt>vis_devinit</tt> structure to the caller.</p></li></ol>


<a name="exeht"></a><h4><tt>VIS_DEFINI</tt></h4>
<p>The <tt>VIS_DEFINI</tt> <tt>ioctl</tt> command releases the driver's console resources and finishes the session.</p><p>To implement the <tt>VIS_DEVFINI</tt> <tt>ioctl</tt> command in the console frame buffer driver,
follow these general steps:</p>
<ol><li><p>Reset the console frame buffer driver state.</p></li>
<li><p>Clear the polled I/O entry points and the kernel terminal emulator video change function callback address.</p></li>
<li><p>Release memory.</p></li></ol>


<a name="exehz"></a><h4><tt>VIS_CONSDISPLAY</tt></h4>
<a name="indexterm-1393"></a><p>The <tt>VIS_CONSDISPLAY</tt> <tt>ioctl</tt> command displays a rectangle of pixels at a specified location.
This display is also referred to as <b>blitting</b> a rectangle. The <tt>vis_consdisplay</tt> structure
contains the information necessary to render a rectangle at the video depth that
both the driver and the <tt>tem</tt> are using. The <tt>vis_consdisplay</tt> structure is shown
in the following code.</p><pre>struct vis_consdisplay {
      screen_pos_t    row;      /* Row (in pixels) to display data at */
      screen_pos_t    col;      /* Col (in pixels) to display data at */
      screen_size_t   width;    /* Width of data (in pixels) */
      screen_size_t   height;   /* Height of data (in pixels) */
      unsigned char   *data;    /* Address of pixels to display */
      unsigned char   fg_color; /* Foreground color */
      unsigned char   bg_color; /* Background color */
};</pre><p>To implement the <tt>VIS_CONSDISPLAY</tt> <tt>ioctl</tt> command in the console frame buffer driver,
follow these general steps:</p>
<ol><li><p>Copy the <tt>vis_consdisplay</tt> structure.</p></li>
<li><p>Validate the display parameters. Return an error if any of the display parameters is out of range.</p></li>
<li><p>Calculate the size of the rectangle to be blitted into video memory. Validate this size against the size of the blit buffer created during <tt>VIS_DEVINIT</tt>. Allocate additional memory for the blit buffer if necessary.</p></li>
<li><p>Retrieve the blit data. This data has been prepared by the kernel terminal emulator at the agreed upon pixel depth. That depth is the same pixel depth that was conveyed by the <tt>tem</tt> during <tt>VIS_DEVINIT</tt>. The pixel depth is updated whenever the device driver changes video modes through callback to the <tt>tem</tt>. Typical pixel depths are 8-bit color map indexed, and 32-bit TrueColor.</p></li>
<li><p>Invalidate any user context so that user applications cannot simultaneously access the frame buffer hardware through user memory mappings. This step is neither allowed nor necessary in polled I/O mode because user applications are not running. Be sure to hold a lock so that users cannot restore the mapping through a page fault until the <tt>VIS_CONSDISPLAY</tt> <tt>ioctl</tt> completes.</p></li>
<li><p>Establish the driver-specific console rendering context.</p></li>
<li><p>If the frame buffer is running in 8-bit color indexed mode, restore the kernel console color map that the <tt>tem</tt> set up through a previous <tt>VIS_PUTCMAP</tt> <tt>ioctl</tt>. A lazy color map loading scheme is recommended to optimize performance. In a <b>lazy</b> scheme, the console frame buffer only restores colors it has actually used since the <tt>VIS_DEVINIT</tt> <tt>ioctl</tt> was issued.</p></li>
<li><p>Display the data passed from the <tt>tem</tt> at the pixel coordinates sent by the <tt>tem</tt>. You might need to transform the RGB pixel data byte order.</p></li></ol>


<a name="exeib"></a><h4><tt>VIS_CONSCOPY</tt></h4>
<p>The <tt>VIS_CONSCOPY</tt> <tt>ioctl</tt> command copies a rectangular region of pixels from one location
to another location. One use for this <tt>ioctl</tt> is to scroll.</p><p>To implement the <tt>VIS_CONSCOPY</tt> <tt>ioctl</tt> command  in the console frame buffer
driver, follow these general steps:</p>
<ol><li><p>Copy the <tt>vis_conscopy</tt> structure. The <tt>vis_conscopy</tt> structure describes the source and target rectangle sizes and locations.</p></li>
<li><p>Validate the display parameters. Return an error if any of the display parameters is out of range.</p></li>
<li><p>Invalidate any user context so that user applications cannot simultaneously access the frame buffer hardware through user memory mappings. This step is neither allowed nor necessary in polled I/O mode because user applications are not running. Be sure to hold a lock so that users cannot restore the mapping through a page fault until the <tt>VIS_CONSDISPLAY</tt> <tt>ioctl</tt> completes.</p></li>
<li><p>Call the function to copy the rectangle.</p>
<hr><p><b>Note - </b>For optimal performance, use the rendering engine of the graphic device to implement the copy function. You need to decide how to do the context management within the driver to set up the rendering engine for best performance.</p>
<hr>
</li></ol>


<a name="exeix"></a><h4><tt>VIS_CONSCURSOR</tt></h4>
<p>The <tt>VIS_CONSCURSOR</tt> <tt>ioctl</tt> command displays or hides a cursor. The <tt>vis_conscursor</tt> structure is shown
in the following code.</p><pre>struct vis_conscursor {
      screen_pos_t    row;      /* Row to display cursor (in pixels) */
      screen_pos_t    col;      /* Col to display cursor (in pixels) */
      screen_size_t   width;    /* Width of cursor (in pixels) */
      screen_size_t   height;   /* Height of cursor (in pixels) */
      color_t         fg_color; /* Foreground color */
      color_t         bg_color; /* Background color */
      short           action;   /* Show or Hide cursor */
};</pre><p>To implement the <tt>VIS_CONSCOPY</tt> <tt>ioctl</tt> command in the console frame buffer driver,
follow these general steps:</p>
<ol><li><p>Copy the <tt>vis_conscursor</tt> structure from the kernel terminal emulator.</p></li>
<li><p>Validate the display parameters. Return an error if any of the display parameters are out of range.</p></li>
<li><p>Invalidate any user context so that user applications cannot simultaneously access the frame buffer hardware through user memory mappings. This step is neither allowed nor necessary in polled I/O mode because user applications are not running. Be sure to hold a lock so that users cannot restore the mapping through a page fault until the <tt>VIS_CONSDISPLAY</tt> <tt>ioctl</tt> completes.</p></li>
<li><p>The terminal emulator can call the <tt>VIS_CONSCOPY</tt> <tt>ioctl</tt> with one of the following two actions: <tt>SHOW_CURSOR</tt> and <tt>HIDE_CURSOR</tt>. The following steps describe how to implement this functionality by reading and writing video memory. You might also be able to use the rendering engine to do this work. Whether you can use the rendering engine depends on the frame buffer hardware.</p><p>Take these steps to implement the <tt>SHOW_CURSOR</tt> functionality:</p>
<ol><li><p>Save the pixels within the rectangle where the cursor will be drawn. These saved pixels will be needed to hide the cursor.</p></li>
<li><p>Scan all the pixels on the screen bounded by the rectangle where the cursor will be drawn. Within this rectangle, replace the pixels that match the specified cursor foreground color (<tt>fg_color</tt>) with white pixels. Replace the pixels that match the specified cursor background color (<tt>bg_color</tt>) with black pixels. The visual effect is of a black cursor over white text. This method works with any foreground and background color of text. Attempting to invert colors based upon color map position is not feasible. More sophisticated strategies, such as attempting color inversion using HSB coloring (Hue, Saturation, Brightness), are not necessary.</p></li></ol>
<p>To implement the <tt>HIDE_CURSOR</tt> functionality, replace the pixels beneath the cursor rectangle with the pixels saved from the previous <tt>SHOW_CURSOR</tt> action.</p></li></ol>


<a name="exejd"></a><h4><tt>VIS_PUTCMAP</tt></h4>
<p>The <tt>VIS_PUTCMAP</tt> <tt>ioctl</tt> command establishes the console color map. The terminal emulator calls
this function to set up the color map of the kernel. The <tt>vis_cmap</tt>
structure is shown in the following code. This structure only applies to 8-bit
color indexed mode.</p><pre>struct vis_cmap {
      int             index;  /* Index into colormap to start updating */
      int             count;  /* Number of entries to update */
      unsigned char   *red;   /* List of red values */
      unsigned char   *green; /* List of green values */
      unsigned char   *blue;  /* List of blue values */
};</pre><p>The <tt>VIS_PUTCMAP</tt> <tt>ioctl</tt> command is similar to the <tt>FBIOPUTCMAP</tt> command. The <tt>VIS_PUTCMAP</tt> command is
specific to the frame buffer terminal-emulator compatible console code.</p>

<a name="exlrl"></a><h4><tt>VIS_GETCMAP</tt></h4>
<p>The terminal emulator calls the <tt>VIS_GETCMAP</tt> <tt>ioctl</tt> command to retrieve the console
color map.</p>
         </div>
      </td>
   </tr>

   <tr class="PageControls" valign="top">
      <td></td>
      <td>
         <table width="100%">
      	   <tr>
      	     <td>
                 <a href="ewibs.html">Previous</a>
             </td>
             <td align="right">
                 <a href="gcbpn.html">Next</a>
             </td>
           </tr>
         </table>
      </td>
   </tr>
</tbody>
</table>


</body>
</html>

