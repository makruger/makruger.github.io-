<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="en-US">
<head>
<meta http-equiv="Content-type" content="text/html; charset=iso-8859-1">
<title>HBA Driver Dependency and Configuration Issues - Writing Device Drivers</title>
<meta name="robots" content="index,follow">
<meta name="robots" content="index,follow">
<meta name="date" content="2008-08-01">
<meta name="collection" content="reference">
<link rel="stylesheet" type="text/css" href="css/elements.css">
<link rel="stylesheet" type="text/css" href="css/indiana.css">
</head>

<body>


<div class="Masthead">
   <div class="MastheadLogo">
      <a href="http://www.opensolaris.org"><img border="0" src="graphics/header.png"></img></a>
   </div>
   <div class="Title">Writing Device Drivers</div>
</div>

<table class="Layout" border="0" cellspacing="0" width="100%">
<tbody>

   <tr valign="top" class="PageControls">
      <td></td>
      <td>
         <table width="100%">
      	   <tr>
      	     <td>
                 <a href="scsihba-16.html">Previous</a>
             </td>
             <td align="right">
                 <a href="scsihba-50.html">Next</a>
             </td>
           </tr>
         </table>
      </td>
   </tr>
   
   <tr valign="top">
      <td class="Navigation" width="200px"><p class="toc level1"><a href="docinfo.html">Document Information</a></p>
<p class="toc level1 tocsp"><a href="preface-1.html">Preface</a></p>
<p class="toc level1 tocsp"><a href="eqbvu.html">Part&nbsp;I&nbsp;Designing Device Drivers for the Solaris Platform</a></p>
<p class="toc level2"><a href="eqbqn.html">1.&nbsp;&nbsp;Overview of Solaris Device Drivers</a></p>
<p class="toc level2"><a href="kernelovr-77198.html">2.&nbsp;&nbsp;Solaris Kernel and Device Tree</a></p>
<p class="toc level2"><a href="mt-17026.html">3.&nbsp;&nbsp;Multithreading</a></p>
<p class="toc level2"><a href="properties-1.html">4.&nbsp;&nbsp;Properties</a></p>
<p class="toc level2"><a href="events-1.html">5.&nbsp;&nbsp;Managing Events and Queueing Tasks</a></p>
<p class="toc level2"><a href="autoconf-17.html">6.&nbsp;&nbsp;Driver Autoconfiguration</a></p>
<p class="toc level2"><a href="devaccess-3.html">7.&nbsp;&nbsp;Device Access: Programmed I/O</a></p>
<p class="toc level2"><a href="interrupt-15678.html">8.&nbsp;&nbsp;Interrupt Handlers</a></p>
<p class="toc level2"><a href="dma-29901.html">9.&nbsp;&nbsp;Direct Memory Access (DMA)</a></p>
<p class="toc level2"><a href="devmap-24338.html">10.&nbsp;&nbsp;Mapping Device and Kernel Memory</a></p>
<p class="toc level2"><a href="devcnmgt-19679.html">11.&nbsp;&nbsp;Device Context Management</a></p>
<p class="toc level2"><a href="powermgt-37437.html">12.&nbsp;&nbsp;Power Management</a></p>
<p class="toc level2"><a href="gevsi.html">13.&nbsp;&nbsp;Hardening Solaris Drivers</a></p>
<p class="toc level2"><a href="ldi-1.html">14.&nbsp;&nbsp;Layered Driver Interface (LDI)</a></p>
<p class="toc level1 tocsp"><a href="eqbvb.html">Part&nbsp;II&nbsp;Designing Specific Kinds of Device Drivers</a></p>
<p class="toc level2"><a href="character-21002.html">15.&nbsp;&nbsp;Drivers for Character Devices</a></p>
<p class="toc level2"><a href="block-34861.html">16.&nbsp;&nbsp;Drivers for Block Devices</a></p>
<p class="toc level2"><a href="scsi-36812.html">17.&nbsp;&nbsp;SCSI Target Drivers</a></p>
<p class="toc level2"><a href="scsihba-32898.html">18.&nbsp;&nbsp;SCSI Host Bus Adapter Drivers</a></p>
<p class="toc level3"><a href="scsihba-105.html">Introduction to Host Bus Adapter Drivers</a></p>
<p class="toc level3"><a href="scsihba-10.html">SCSI Interface</a></p>
<p class="toc level3"><a href="scsihba-16.html">SCSA HBA Interfaces</a></p>
<div class="onpage">
<p class="toc level3"><a href="">HBA Driver Dependency and Configuration Issues</a></p>
</div>
<p class="toc level3"><a href="scsihba-50.html">Entry Points for SCSA HBA Drivers</a></p>
<p class="toc level3"><a href="scsihba-88.html">SCSI HBA Driver Specific Issues</a></p>
<p class="toc level3"><a href="scsihba-100.html">Support for Queuing</a></p>
<p class="toc level2 tocsp"><a href="gld-1.html">19.&nbsp;&nbsp;Drivers for Network Devices</a></p>
<p class="toc level2"><a href="usb-1.html">20.&nbsp;&nbsp;USB Drivers</a></p>
<p class="toc level1 tocsp"><a href="eqbvo.html">Part&nbsp;III&nbsp;Building a Device Driver</a></p>
<p class="toc level2"><a href="loading-15035.html">21.&nbsp;&nbsp;Compiling, Loading, Packaging, and Testing Drivers</a></p>
<p class="toc level2"><a href="debug-60.html">22.&nbsp;&nbsp;Debugging, Testing, and Tuning Device Drivers</a></p>
<p class="toc level2"><a href="coding-practices.html">23.&nbsp;&nbsp;Recommended Coding Practices</a></p>
<p class="toc level1 tocsp"><a href="eqbva.html">Part&nbsp;IV&nbsp;Appendixes</a></p>
<p class="toc level2"><a href="hwovr-18191.html">A.&nbsp;&nbsp;Hardware Overview</a></p>
<p class="toc level2"><a href="ddidkisvc-29227.html">B.&nbsp;&nbsp;Summary of Solaris DDI/DKI Services</a></p>
<p class="toc level2"><a href="lp64-35004.html">C.&nbsp;&nbsp;Making a Device Driver 64-Bit Ready</a></p>
<p class="toc level2"><a href="euazz.html">D.&nbsp;&nbsp;Console Frame Buffer Drivers</a></p>
<p class="toc level1 tocsp"><a href="idx-1.html">Index</a></p>
</td>
      <td class="ContentPane" width="705px">

	 <div class="MainContent">      	 
             

<a name="scsihba-32"></a><h3>HBA Driver Dependency and Configuration Issues</h3>
<p>In addition to incorporating SCSA HBA entry points, structures, and functions into a
driver, a developer must deal with driver dependency and configuration issues. These issues
involve configuration properties, dependency declarations, state structure and per-command structure, entry points for module
initialization, and autoconfiguration entry points.</p>

<a name="scsihba-33"></a><h4>Declarations and Structures</h4>
<p><a name="indexterm-616"></a>HBA drivers must include the following header files:</p><pre>#include &lt;sys/scsi/scsi.h&gt;
#include &lt;sys/ddi.h&gt;
#include &lt;sys/sunddi.h&gt;</pre><p>To inform the system that the module depends on SCSA routines, the
driver binary must be generated with the following command. See <a href="scsihba-16.html">SCSA HBA Interfaces</a> for more
information on SCSA routines.</p><pre>% ld -r <i>xx</i>.o -o <i>xx</i> -N "misc/scsi"</pre><p>The code samples are derived from a simplified <tt>isp</tt> driver for the QLogic
Intelligent SCSI Peripheral device. The <tt>isp</tt> driver supports WIDE SCSI, with up to
15 target devices and 8 logical units (LUNs) per target.</p>

<a name="scsihba-34"></a><h5>Per-Command Structure</h5>
<p><a name="indexterm-617"></a>An HBA driver usually needs to define a structure to maintain state for
each command submitted by a target driver. The layout of this per-command structure
is entirely up to the device driver writer. The layout needs to reflect
the capabilities and features of the hardware and the software algorithms that are
used in the driver.</p><p>The following structure is an example of a per-command structure. The remaining code
fragments of this chapter use this structure to illustrate the HBA interfaces.</p><pre>struct isp_cmd {
     struct isp_request     cmd_isp_request;
     struct isp_response    cmd_isp_response;
     struct scsi_pkt        *cmd_pkt;
     struct isp_cmd         *cmd_forw;
     uint32_t               cmd_dmacount;
     ddi_dma_handle_t       cmd_dmahandle;
     uint_t                 cmd_cookie;
     uint_t                 cmd_ncookies;
     uint_t                 cmd_cookiecnt;
     uint_t                 cmd_nwin;
     uint_t                 cmd_curwin;
     off_t                  cmd_dma_offset;
     uint_t                 cmd_dma_len;
     ddi_dma_cookie_t       cmd_dmacookies[ISP_NDATASEGS];
     u_int                  cmd_flags;
     u_short                cmd_slot;
     u_int                  cmd_cdblen;
     u_int                  cmd_scblen;
 };</pre>

<a name="scsihba-35"></a><h4>Entry Points for Module Initialization</h4>
<p>This section describes the entry points for operations that are performed by SCSI
HBA drivers.</p><p>The following code for a SCSI HBA driver illustrates a representative <a href="http://docs.sun.com/doc/819-2257/dev-ops-9s?a=view"><tt>dev_ops</tt>(9S)</a>
structure. The driver must initialize the <tt>devo_bus_ops</tt> field in this structure to <tt>NULL</tt>. A
SCSI HBA driver can provide leaf driver interfaces for special purposes, in which
case the <tt>devo_cb_ops</tt> field might point to a <a href="http://docs.sun.com/doc/819-2257/cb-ops-9s?a=view"><tt>cb_ops</tt>(9S)</a> structure. In this example, no
leaf driver interfaces are exported, so the <tt>devo_cb_ops</tt> field is initialized to
<tt>NULL</tt>.</p>

<a name="scsihba-36"></a><h5><tt>_init()</tt> Entry Point (SCSI HBA Drivers)</h5>
<p>The <a href="http://docs.sun.com/doc/819-2255/u-init-9e?a=view"><tt>_init</tt>(9E)</a> function initializes a loadable module. <tt>_init()</tt> is called before any other routine
in the loadable module.</p><p>In a SCSI HBA, the <tt>_init()</tt> function must call  <a href="http://docs.sun.com/doc/819-2256/scsi-hba-init-9f?a=view"><tt>scsi_hba_init</tt>(9F)</a> to
inform the framework of the existence of the HBA driver before calling 
<a href="http://docs.sun.com/doc/819-2256/mod-install-9f?a=view"><tt>mod_install</tt>(9F)</a>. If <tt>scsi_hba__init()</tt> returns a nonzero value,<tt>_init()</tt> should return this value. Otherwise, <tt>_init()</tt>
must return the value returned by <a href="http://docs.sun.com/doc/819-2256/mod-install-9f?a=view"><tt>mod_install</tt>(9F)</a>.</p><p>The driver should initialize any required global state before calling  <a href="http://docs.sun.com/doc/819-2256/mod-install-9f?a=view"><tt>mod_install</tt>(9F)</a>.</p><p>If  <tt>mod_install()</tt> fails, the <tt>_init()</tt> function must free any global resources allocated.
<tt>_init()</tt> must call  <a href="http://docs.sun.com/doc/819-2256/scsi-hba-fini-9f?a=view"><tt>scsi_hba_fini</tt>(9F)</a> before returning.</p><p>The following example uses a global mutex to show how to allocate
data that is global to all instances of a driver. The code declares
global mutex and soft-state structure information. The global mutex and soft state are initialized
during <tt>_init()</tt>.</p>

<a name="scsihba-37"></a><h5><tt>_fini()</tt> Entry Point (SCSI HBA Drivers)</h5>
<p>The <a href="http://docs.sun.com/doc/819-2255/u-fini-9e?a=view"><tt>_fini</tt>(9E)</a> function is called when the system is about to try to
unload the SCSI HBA driver. The <tt>_fini()</tt> function must call  <a href="http://docs.sun.com/doc/819-2256/mod-remove-9f?a=view"><tt>mod_remove</tt>(9F)</a>
to determine whether the driver can be unloaded. If <tt>mod_remove()</tt> returns 0, the module
can be unloaded.  The HBA driver must deallocate any global resources allocated
in <a href="http://docs.sun.com/doc/819-2255/u-init-9e?a=view"><tt>_init</tt>(9E)</a>. The HBA driver must also call  <a href="http://docs.sun.com/doc/819-2256/scsi-hba-fini-9f?a=view"><tt>scsi_hba_fini</tt>(9F)</a>.</p><p><tt>_fini()</tt> must return the value returned by <tt>mod_remove()</tt>.</p>
<hr><p><b>Note - </b>The HBA driver must not free any resources or call  <a href="http://docs.sun.com/doc/819-2256/scsi-hba-fini-9f?a=view"><tt>scsi_hba_fini</tt>(9F)</a>
unless <a href="http://docs.sun.com/doc/819-2256/mod-remove-9f?a=view"><tt>mod_remove</tt>(9F)</a> returns 0.</p>
<hr>
<p><a href="#scsihba-ex-38">Example&nbsp;18-1</a> shows module initialization for SCSI HBA.</p><a name="scsihba-ex-38"></a><h6>Example&nbsp;18-1 Module Initialization for SCSI HBA</h6><pre>static struct dev_ops isp_dev_ops = {
    DEVO_REV,       /* devo_rev */
    0,              /* refcnt  */
    isp_getinfo,    /* getinfo */
    nulldev,        /* probe */
    isp_attach,     /* attach */
    isp_detach,     /* detach */
    nodev,          /* reset */
    NULL,           /* driver operations */
    NULL,           /* bus operations */
    isp_power,      /* power management */
};

/*
 * Local static data
 */
static kmutex_t      isp_global_mutex;
static void          *isp_state;

int
_init(void)
{
    int     err;
    
    if ((err = ddi_soft_state_init(&amp;isp_state,
        sizeof (struct isp), 0)) != 0) {
        return (err);
    }
    if ((err = scsi_hba_init(&amp;modlinkage)) == 0) {
        mutex_init(&amp;isp_global_mutex, "isp global mutex",
        MUTEX_DRIVER, NULL);
        if ((err = mod_install(&amp;modlinkage)) != 0) {
            mutex_destroy(&amp;isp_global_mutex);
            scsi_hba_fini(&amp;modlinkage);
            ddi_soft_state_fini(&amp;isp_state);    
        }
    }
    return (err);
}

int
_fini(void)
{
    int     err;
    
    if ((err = mod_remove(&amp;modlinkage)) == 0) {
        mutex_destroy(&amp;isp_global_mutex);
        scsi_hba_fini(&amp;modlinkage);
        ddi_soft_state_fini(&amp;isp_state);
    }
    return (err);
}</pre>

<a name="scsihba-39"></a><h4>Autoconfiguration Entry Points</h4>
<p><a name="indexterm-618"></a><a name="indexterm-619"></a>Associated with each device driver is a <a href="http://docs.sun.com/doc/819-2257/dev-ops-9s?a=view"><tt>dev_ops</tt>(9S)</a> structure, which enables the kernel to
locate the autoconfiguration entry points of the driver. A complete description of these
autoconfiguration routines is given in <a href="autoconf-17.html">Chapter&nbsp;6, Driver Autoconfiguration</a>. This section describes only those entry points associated
with operations performed by SCSI HBA drivers. These entry points include  <a href="http://docs.sun.com/doc/819-2255/attach-9e?a=view"><tt>attach</tt>(9E)</a>
and <a href="http://docs.sun.com/doc/819-2255/detach-9e?a=view"><tt>detach</tt>(9E)</a>.</p>

<a name="scsihba-40"></a><h5><tt>attach()</tt> Entry Point (SCSI HBA Drivers)</h5>
<p>The <a href="http://docs.sun.com/doc/819-2255/attach-9e?a=view"><tt>attach</tt>(9E)</a> entry point for a SCSI HBA driver performs several tasks when
configuring and attaching an instance of the driver for the device. For a
typical driver of real devices, the following operating system and hardware concerns must
be addressed:</p>
<ul><li><p>Soft-state structure</p></li>
<li><p>DMA</p></li>
<li><p>Transport structure</p></li>
<li><p>Attaching an HBA driver</p></li>
<li><p>Register mapping</p></li>
<li><p>Interrupt specification</p></li>
<li><p>Interrupt handling</p></li>
<li><p>Create power manageable components</p></li>
<li><p>Report attachment status</p></li></ul>


<a name="scsihba-41"></a><h5>Soft-State Structure</h5>
<p>When allocating the per-device-instance soft-state structure, a driver must clean up carefully if
an error occurs.</p>

<a name="scsihba-42"></a><h5>DMA</h5>
<p>The HBA driver must describe the attributes of its DMA engine by
properly initializing the <tt>ddi_dma_attr_t</tt> structure.</p><pre>static ddi_dma_attr_t isp_dma_attr = {
     DMA_ATTR_V0,        /* ddi_dma_attr version */
     0,                  /* low address */
     0xffffffff,         /* high address */
     0x00ffffff,         /* counter upper bound */
     1,                  /* alignment requirements */
     0x3f,               /* burst sizes */
     1,                  /* minimum DMA access */
     0xffffffff,         /* maximum DMA access */
     (1&lt;&lt;24)-1,          /* segment boundary restrictions */
     1,                  /* scatter-gather list length */
     512,                /* device granularity */
     0                   /* DMA flags */
};</pre><p>The driver, if providing DMA, should also check that its hardware is installed
in a DMA-capable slot:</p><pre>if (ddi_slaveonly(dip) == DDI_SUCCESS) {
    return (DDI_FAILURE);
}</pre>

<a name="scsihba-43"></a><h5>Transport Structure</h5>
<p><a name="indexterm-620"></a>The driver should further allocate and initialize a transport structure for this instance.
The <tt>tran_hba_private</tt> field is set to point to this instance's soft-state structure. The
<tt>tran_tgt_probe</tt> field can be set to <tt>NULL</tt> to achieve the default behavior, if
no special probe customization is needed.</p><pre>tran = scsi_hba_tran_alloc(dip, SCSI_HBA_CANSLEEP);

isp-&gt;isp_tran                   = tran;
isp-&gt;isp_dip                    = dip;

tran-&gt;tran_hba_private          = isp;
tran-&gt;tran_tgt_private          = NULL;
tran-&gt;tran_tgt_init             = isp_tran_tgt_init;
tran-&gt;tran_tgt_probe            = scsi_hba_probe;
tran-&gt;tran_tgt_free             = (void (*)())NULL;

tran-&gt;tran_start                = isp_scsi_start;
tran-&gt;tran_abort                = isp_scsi_abort;
tran-&gt;tran_reset                = isp_scsi_reset;
tran-&gt;tran_getcap               = isp_scsi_getcap;
tran-&gt;tran_setcap               = isp_scsi_setcap;
tran-&gt;tran_init_pkt             = isp_scsi_init_pkt;
tran-&gt;tran_destroy_pkt          = isp_scsi_destroy_pkt;
tran-&gt;tran_dmafree              = isp_scsi_dmafree;
tran-&gt;tran_sync_pkt             = isp_scsi_sync_pkt;
tran-&gt;tran_reset_notify         = isp_scsi_reset_notify;
tran-&gt;tran_bus_quiesce          = isp_tran_bus_quiesce
tran-&gt;tran_bus_unquiesce        = isp_tran_bus_unquiesce
tran-&gt;tran_bus_reset            = isp_tran_bus_reset
tran-&gt;tran_interconnect_type    = isp_tran_interconnect_type</pre>

<a name="scsihba-44"></a><h5>Attaching an HBA Driver</h5>
<p>The driver should attach this instance of the device, and perform error cleanup
if necessary.</p><pre>i = scsi_hba_attach_setup(dip, &amp;isp_dma_attr, tran, 0);
if (i != DDI_SUCCESS) {
    /* do error recovery */
    return (DDI_FAILURE);
}</pre>

<a name="scsihba-45"></a><h5>Register Mapping</h5>
<p>The driver should map in its device's registers. The driver need to specify
the following items:</p>
<ul><li><p>Register set index</p></li>
<li><p>Data access characteristics of the device</p></li>
<li><p>Size of the register to be mapped</p></li></ul>
<pre>ddi_device_acc_attr_t    dev_attributes;

     dev_attributes.devacc_attr_version = DDI_DEVICE_ATTR_V0;
     dev_attributes.devacc_attr_dataorder = DDI_STRICTORDER_ACC;
     dev_attributes.devacc_attr_endian_flags = DDI_STRUCTURE_LE_ACC;

     if (ddi_regs_map_setup(dip, 0, (caddr_t *)&amp;isp-&gt;isp_reg,
     0, sizeof (struct ispregs), &amp;dev_attributes,
     &amp;isp-&gt;isp_acc_handle) != DDI_SUCCESS) {
        /* do error recovery */
        return (DDI_FAILURE);
     }</pre>

<a name="scsihba-46"></a><h5>Adding an Interrupt Handler</h5>
<p>The driver must first obtain the <b>iblock cookie</b> to initialize any mutexes that are
used in the driver handler. Only after those mutexes have been initialized can
the interrupt handler be added.</p><pre>i = ddi_get_iblock_cookie(dip, 0, &amp;isp-&gt;iblock_cookie};
if (i != DDI_SUCCESS) {
    /* do error recovery */
    return (DDI_FAILURE);
}

mutex_init(&amp;isp-&gt;mutex, "isp_mutex", MUTEX_DRIVER,
(void *)isp-&gt;iblock_cookie);
i = ddi_add_intr(dip, 0, &amp;isp-&gt;iblock_cookie,
0, isp_intr, (caddr_t)isp);
if (i != DDI_SUCCESS) {
    /* do error recovery */
    return (DDI_FAILURE);
}</pre><p>If a high-level handler is required, the driver should be coded to
provide such a handler. Otherwise, the driver must be able to fail the
attach. See <a href="interrupt-18.html">Handling High-Level Interrupts</a> for a description of high-level interrupt handling.</p>

<a name="scsihba-104"></a><h5>Create Power Manageable Components</h5>
<p>With power management, if the host bus adapter only needs to power
down when all target adapters are at power level 0, the HBA driver
only needs to provide a <a href="http://docs.sun.com/doc/819-2255/power-9e?a=view"><tt>power</tt>(9E)</a> entry point. Refer to <a href="powermgt-37437.html">Chapter&nbsp;12, Power Management</a>. The HBA driver
also needs to create a <a href="http://docs.sun.com/doc/819-2257/pm-components-9p?a=view"><tt>pm-components</tt>(9P)</a> property that describes the components that the
device implements.</p><p>Nothing more is necessary, since the components will default to idle, and the
power management framework's default dependency processing will ensure that the host bus adapter
will be powered up whenever an target adapter is powered up. Provided that
automatic power management is enabled automatically, the processing will also power down the
host bus adapter when all target adapters are powered down ().</p>

<a name="scsihba-47"></a><h5>Report Attachment Status</h5>
<p>Finally, the driver should report that this instance of the device is attached
and return success.</p><pre>ddi_report_dev(dip);
    return (DDI_SUCCESS);</pre>

<a name="scsihba-48"></a><h5><tt>detach()</tt> Entry Point (SCSI HBA Drivers)</h5>
<p>The driver should perform standard detach operations, including   calling <a href="http://docs.sun.com/doc/819-2256/scsi-hba-detach-9f?a=view"><tt>scsi_hba_detach</tt>(9F)</a>.</p>
         </div>
      </td>
   </tr>

   <tr class="PageControls" valign="top">
      <td></td>
      <td>
         <table width="100%">
      	   <tr>
      	     <td>
                 <a href="scsihba-16.html">Previous</a>
             </td>
             <td align="right">
                 <a href="scsihba-50.html">Next</a>
             </td>
           </tr>
         </table>
      </td>
   </tr>
</tbody>
</table>


</body>
</html>

