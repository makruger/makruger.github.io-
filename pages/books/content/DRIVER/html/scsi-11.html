<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="en-US">
<head>
<meta http-equiv="Content-type" content="text/html; charset=iso-8859-1">
<title>Autoconfiguration for SCSI Target Drivers - Writing Device Drivers</title>
<meta name="robots" content="index,follow">
<meta name="robots" content="index,follow">
<meta name="date" content="2008-08-01">
<meta name="collection" content="reference">
<link rel="stylesheet" type="text/css" href="css/elements.css">
<link rel="stylesheet" type="text/css" href="css/indiana.css">
</head>

<body>


<div class="Masthead">
   <div class="MastheadLogo">
      <a href="http://www.opensolaris.org"><img border="0" src="graphics/header.png"></img></a>
   </div>
   <div class="Title">Writing Device Drivers</div>
</div>

<table class="Layout" border="0" cellspacing="0" width="100%">
<tbody>

   <tr valign="top" class="PageControls">
      <td></td>
      <td>
         <table width="100%">
      	   <tr>
      	     <td>
                 <a href="scsi-9.html">Previous</a>
             </td>
             <td align="right">
                 <a href="scsi-12.html">Next</a>
             </td>
           </tr>
         </table>
      </td>
   </tr>
   
   <tr valign="top">
      <td class="Navigation" width="200px"><p class="toc level1"><a href="docinfo.html">Document Information</a></p>
<p class="toc level1 tocsp"><a href="preface-1.html">Preface</a></p>
<p class="toc level1 tocsp"><a href="eqbvu.html">Part&nbsp;I&nbsp;Designing Device Drivers for the Solaris Platform</a></p>
<p class="toc level2"><a href="eqbqn.html">1.&nbsp;&nbsp;Overview of Solaris Device Drivers</a></p>
<p class="toc level2"><a href="kernelovr-77198.html">2.&nbsp;&nbsp;Solaris Kernel and Device Tree</a></p>
<p class="toc level2"><a href="mt-17026.html">3.&nbsp;&nbsp;Multithreading</a></p>
<p class="toc level2"><a href="properties-1.html">4.&nbsp;&nbsp;Properties</a></p>
<p class="toc level2"><a href="events-1.html">5.&nbsp;&nbsp;Managing Events and Queueing Tasks</a></p>
<p class="toc level2"><a href="autoconf-17.html">6.&nbsp;&nbsp;Driver Autoconfiguration</a></p>
<p class="toc level2"><a href="devaccess-3.html">7.&nbsp;&nbsp;Device Access: Programmed I/O</a></p>
<p class="toc level2"><a href="interrupt-15678.html">8.&nbsp;&nbsp;Interrupt Handlers</a></p>
<p class="toc level2"><a href="dma-29901.html">9.&nbsp;&nbsp;Direct Memory Access (DMA)</a></p>
<p class="toc level2"><a href="devmap-24338.html">10.&nbsp;&nbsp;Mapping Device and Kernel Memory</a></p>
<p class="toc level2"><a href="devcnmgt-19679.html">11.&nbsp;&nbsp;Device Context Management</a></p>
<p class="toc level2"><a href="powermgt-37437.html">12.&nbsp;&nbsp;Power Management</a></p>
<p class="toc level2"><a href="gevsi.html">13.&nbsp;&nbsp;Hardening Solaris Drivers</a></p>
<p class="toc level2"><a href="ldi-1.html">14.&nbsp;&nbsp;Layered Driver Interface (LDI)</a></p>
<p class="toc level1 tocsp"><a href="eqbvb.html">Part&nbsp;II&nbsp;Designing Specific Kinds of Device Drivers</a></p>
<p class="toc level2"><a href="character-21002.html">15.&nbsp;&nbsp;Drivers for Character Devices</a></p>
<p class="toc level2"><a href="block-34861.html">16.&nbsp;&nbsp;Drivers for Block Devices</a></p>
<p class="toc level2"><a href="scsi-36812.html">17.&nbsp;&nbsp;SCSI Target Drivers</a></p>
<p class="toc level3"><a href="scsi-6a.html">Introduction to Target Drivers</a></p>
<p class="toc level3"><a href="scsi-3.html">Sun Common SCSI Architecture Overview</a></p>
<p class="toc level3"><a href="scsi-37210.html">Hardware Configuration File</a></p>
<p class="toc level3"><a href="scsi-9.html">Declarations and Data Structures</a></p>
<div class="onpage">
<p class="toc level3"><a href="">Autoconfiguration for SCSI Target Drivers</a></p>
</div>
<p class="toc level3"><a href="scsi-12.html">Resource Allocation</a></p>
<p class="toc level3"><a href="scsi-15.html">Building and Transporting a Command</a></p>
<p class="toc level3"><a href="scsi-100.html">SCSI Options</a></p>
<p class="toc level2 tocsp"><a href="scsihba-32898.html">18.&nbsp;&nbsp;SCSI Host Bus Adapter Drivers</a></p>
<p class="toc level2"><a href="gld-1.html">19.&nbsp;&nbsp;Drivers for Network Devices</a></p>
<p class="toc level2"><a href="usb-1.html">20.&nbsp;&nbsp;USB Drivers</a></p>
<p class="toc level1 tocsp"><a href="eqbvo.html">Part&nbsp;III&nbsp;Building a Device Driver</a></p>
<p class="toc level2"><a href="loading-15035.html">21.&nbsp;&nbsp;Compiling, Loading, Packaging, and Testing Drivers</a></p>
<p class="toc level2"><a href="debug-60.html">22.&nbsp;&nbsp;Debugging, Testing, and Tuning Device Drivers</a></p>
<p class="toc level2"><a href="coding-practices.html">23.&nbsp;&nbsp;Recommended Coding Practices</a></p>
<p class="toc level1 tocsp"><a href="eqbva.html">Part&nbsp;IV&nbsp;Appendixes</a></p>
<p class="toc level2"><a href="hwovr-18191.html">A.&nbsp;&nbsp;Hardware Overview</a></p>
<p class="toc level2"><a href="ddidkisvc-29227.html">B.&nbsp;&nbsp;Summary of Solaris DDI/DKI Services</a></p>
<p class="toc level2"><a href="lp64-35004.html">C.&nbsp;&nbsp;Making a Device Driver 64-Bit Ready</a></p>
<p class="toc level2"><a href="euazz.html">D.&nbsp;&nbsp;Console Frame Buffer Drivers</a></p>
<p class="toc level1 tocsp"><a href="idx-1.html">Index</a></p>
</td>
      <td class="ContentPane" width="705px">

	 <div class="MainContent">      	 
             

<a name="scsi-11"></a><h3>Autoconfiguration for SCSI Target Drivers</h3>
<p><a name="scsi-ix485"></a><a name="scsi-ix486"></a>SCSI target drivers must implement the standard autoconfiguration routines <a href="http://docs.sun.com/doc/819-2255/u-init-9e?a=view"><tt>_init</tt>(9E)</a>, <a href="http://docs.sun.com/doc/819-2255/u-fini-9e?a=view"><tt>_fini</tt>(9E)</a>, and <a href="http://docs.sun.com/doc/819-2255/u-info-9e?a=view"><tt>_info</tt>(9E)</a>.
See <a href="autoconf-95548.html">Loadable Driver Interfaces</a> for more information.</p><p>The following routines are also required, but these routines must perform specific SCSI
and SCSA processing:</p>
<ul><li><p><a href="http://docs.sun.com/doc/819-2255/probe-9e?a=view"><tt>probe</tt>(9E)</a></p></li>
<li><p><a href="http://docs.sun.com/doc/819-2255/attach-9e?a=view"><tt>attach</tt>(9E)</a></p></li>
<li><p><a href="http://docs.sun.com/doc/819-2255/detach-9e?a=view"><tt>detach</tt>(9E)</a></p></li>
<li><p><a href="http://docs.sun.com/doc/819-2255/getinfo-9e?a=view"><tt>getinfo</tt>(9E)</a></p></li></ul>


<a name="scsi-65313"></a><h4><tt>probe()</tt> Entry Point (SCSI Target Drivers)</h4>
<p><a name="scsi-ix487"></a>SCSI target devices are not self-identifying, so target drivers must have a <a href="http://docs.sun.com/doc/819-2255/probe-9e?a=view"><tt>probe</tt>(9E)</a>
routine. This routine must determine whether the expected type of device is present
and responding.</p><p>The general structure and the return codes of the  <a href="http://docs.sun.com/doc/819-2255/probe-9e?a=view"><tt>probe</tt>(9E)</a> routine
are the same as the structure and return codes for other device drivers.
SCSI target drivers must use the  <a href="http://docs.sun.com/doc/819-2256/scsi-probe-9f?a=view"><tt>scsi_probe</tt>(9F)</a> routine in their  <a href="http://docs.sun.com/doc/819-2255/probe-9e?a=view"><tt>probe</tt>(9E)</a>
entry point.  <a href="http://docs.sun.com/doc/819-2256/scsi-probe-9f?a=view"><tt>scsi_probe</tt>(9F)</a> sends a SCSI inquiry command to the device and
returns a code that indicates the result. If the SCSI inquiry command is
successful,  <a href="http://docs.sun.com/doc/819-2256/scsi-probe-9f?a=view"><tt>scsi_probe</tt>(9F)</a> allocates a <a href="http://docs.sun.com/doc/819-2257/scsi-inquiry-9s?a=view"><tt>scsi_inquiry</tt>(9S)</a> structure and fills the structure in with
the device's inquiry data. Upon return from  <a href="http://docs.sun.com/doc/819-2256/scsi-probe-9f?a=view"><tt>scsi_probe</tt>(9F)</a>, the <tt>sd_inq</tt> field of
the <a href="http://docs.sun.com/doc/819-2257/scsi-device-9s?a=view"><tt>scsi_device</tt>(9S)</a> structure points to this <a href="http://docs.sun.com/doc/819-2257/scsi-inquiry-9s?a=view"><tt>scsi_inquiry</tt>(9S)</a> structure.</p><p>Because  <a href="http://docs.sun.com/doc/819-2255/probe-9e?a=view"><tt>probe</tt>(9E)</a> must be stateless, the target driver must call  <a href="http://docs.sun.com/doc/819-2256/scsi-unprobe-9f?a=view"><tt>scsi_unprobe</tt>(9F)</a>
before <a href="http://docs.sun.com/doc/819-2255/probe-9e?a=view"><tt>probe</tt>(9E)</a> returns, even if <a href="http://docs.sun.com/doc/819-2256/scsi-probe-9f?a=view"><tt>scsi_probe</tt>(9F)</a> fails.</p><p><a href="#scsi-14215">Example&nbsp;17-1</a> shows a typical <a href="http://docs.sun.com/doc/819-2255/probe-9e?a=view"><tt>probe</tt>(9E)</a> routine. The routine in the example retrieves the <a href="http://docs.sun.com/doc/819-2257/scsi-device-9s?a=view"><tt>scsi_device</tt>(9S)</a>
structure from the private field of its <tt>dev_info</tt> structure. The routine also retrieves the
device's SCSI target and logical unit numbers for printing in messages. The 
<a href="http://docs.sun.com/doc/819-2255/probe-9e?a=view"><tt>probe</tt>(9E)</a> routine then calls <a href="http://docs.sun.com/doc/819-2256/scsi-probe-9f?a=view"><tt>scsi_probe</tt>(9F)</a> to verify that the expected device, a printer
in this case, is present.</p><p>If  successful, <a href="http://docs.sun.com/doc/819-2256/scsi-probe-9f?a=view"><tt>scsi_probe</tt>(9F)</a> attaches the device's SCSI inquiry data in a
<a href="http://docs.sun.com/doc/819-2257/scsi-inquiry-9s?a=view"><tt>scsi_inquiry</tt>(9S)</a> structure to the <tt>sd_inq</tt> field of the <a href="http://docs.sun.com/doc/819-2257/scsi-device-9s?a=view"><tt>scsi_device</tt>(9S)</a> structure. The driver can then
determine whether the device type is a printer, which is reported in the
<tt>inq_dtype</tt> field. If the device is a printer, the type is reported with
<a href="http://docs.sun.com/doc/819-2256/scsi-log-9f?a=view"><tt>scsi_log</tt>(9F)</a>, using <a href="http://docs.sun.com/doc/819-2256/scsi-dname-9f?a=view"><tt>scsi_dname</tt>(9F)</a> to convert the device type into a string.</p><a name="scsi-14215"></a><h6>Example&nbsp;17-1 SCSI Target Driver <tt>probe</tt>(9E) Routine</h6><pre>static int
xxprobe(dev_info_t *dip)
{
    struct scsi_device *sdp;
    int rval, target, lun;
    /*
     * Get a pointer to the scsi_device(9S) structure
     */
    sdp = (struct scsi_device *)ddi_get_driver_private(dip);

    target = sdp-&gt;sd_address.a_target;
    lun = sdp-&gt;sd_address.a_lun;
    /*
     * Call scsi_probe(9F) to send the Inquiry command. It will
     * fill in the sd_inq field of the scsi_device structure.
     */
    switch (scsi_probe(sdp, NULL_FUNC)) {
    case SCSIPROBE_FAILURE:
    case SCSIPROBE_NORESP:
    case SCSIPROBE_NOMEM:
        /*
         * In these cases, device might be powered off,
         * in which case we might be able to successfully
         * probe it at some future time - referred to
         * as `deferred attach'.
         */
        rval = DDI_PROBE_PARTIAL;
        break;
    case SCSIPROBE_NONCCS:
    default:
        /*
         * Device isn't of the type we can deal with,
         * and/or it will never be usable.
         */
        rval = DDI_PROBE_FAILURE;
        break;
    case SCSIPROBE_EXISTS:
        /*
         * There is a device at the target/lun address. Check
         * inq_dtype to make sure that it is the right device
         * type. See scsi_inquiry(9S)for possible device types.
         */
        switch (sdp-&gt;sd_inq-&gt;inq_dtype) {
        case DTYPE_PRINTER:
        scsi_log(sdp, "xx", SCSI_DEBUG,
            "found %s device at target%d, lun%d\n",
            scsi_dname((int)sdp-&gt;sd_inq-&gt;inq_dtype),
            target, lun);
        rval = DDI_PROBE_SUCCESS;
        break;
        case DTYPE_NOTPRESENT:
        default:
        rval = DDI_PROBE_FAILURE;
        break;     
        }    
    }
    scsi_unprobe(sdp);
    return (rval);
}</pre><p>A more thorough  <a href="http://docs.sun.com/doc/819-2255/probe-9e?a=view"><tt>probe</tt>(9E)</a> routine could check <a href="http://docs.sun.com/doc/819-2257/scsi-inquiry-9s?a=view"><tt>scsi_inquiry</tt>(9S)</a>  to make sure
that the device is of the type expected by a particular driver.</p>

<a name="scsi-38411"></a><h4><tt>attach()</tt> Entry Point (SCSI Target Drivers)</h4>
<p>After the <a href="http://docs.sun.com/doc/819-2255/probe-9e?a=view"><tt>probe</tt>(9E)</a> routine has verified that the expected device is present, <a href="http://docs.sun.com/doc/819-2255/attach-9e?a=view"><tt>attach</tt>(9E)</a>
is called. <tt>attach()</tt> performs these tasks:</p>
<ul><li><p>Allocates and initializes any per-instance data.</p></li>
<li><p>Creates minor device node information.</p></li>
<li><p>Restores the hardware state of a device after a suspension of the device or the system. See <a href="autoconf-60641.html#autoconf-41111"><tt>attach()</tt> Entry Point</a> for details.</p></li></ul>
<p>A SCSI target driver needs to call <a href="http://docs.sun.com/doc/819-2256/scsi-probe-9f?a=view"><tt>scsi_probe</tt>(9F)</a> again to retrieve the
device's inquiry data. The driver must also create a SCSI request sense packet.
If the attach is successful, the <tt>attach()</tt> function should not call <a href="http://docs.sun.com/doc/819-2256/scsi-unprobe-9f?a=view"><tt>scsi_unprobe</tt>(9F)</a>.</p><p>Three routines are used to create the request sense packet: <a href="http://docs.sun.com/doc/819-2256/scsi-alloc-consistent-buf-9f?a=view"><tt>scsi_alloc_consistent_buf</tt>(9F)</a>, <a href="http://docs.sun.com/doc/819-2256/scsi-init-pkt-9f?a=view"><tt>scsi_init_pkt</tt>(9F)</a>,
and <a href="http://docs.sun.com/doc/819-2256/scsi-setup-cdb-9f?a=view"><tt>scsi_setup_cdb</tt>(9F)</a>. <a href="http://docs.sun.com/doc/819-2256/scsi-alloc-consistent-buf-9f?a=view"><tt>scsi_alloc_consistent_buf</tt>(9F)</a> allocates a buffer that is suitable for consistent DMA. <tt>scsi_alloc_consistent_buf()</tt>
then returns a pointer to a <a href="http://docs.sun.com/doc/819-2257/buf-9s?a=view"><tt>buf</tt>(9S)</a> structure. The advantage of a
consistent buffer is that no explicit synchronization of the data is required. In
other words, the target driver can access the data after the callback. The
<tt>sd_sense</tt> element of the device's <a href="http://docs.sun.com/doc/819-2257/scsi-device-9s?a=view"><tt>scsi_device</tt>(9S)</a> structure must be initialized with the address
of the sense buffer. <a href="http://docs.sun.com/doc/819-2256/scsi-init-pkt-9f?a=view"><tt>scsi_init_pkt</tt>(9F)</a> creates and partially initializes a <a href="http://docs.sun.com/doc/819-2257/scsi-pkt-9s?a=view"><tt>scsi_pkt</tt>(9S)</a> structure. <a href="http://docs.sun.com/doc/819-2256/scsi-setup-cdb-9f?a=view"><tt>scsi_setup_cdb</tt>(9F)</a>
creates a SCSI command descriptor block, in this case by creating a SCSI
request sense command.</p><p><a name="scsi-ix488"></a><a name="scsi-ix489"></a>Note that a SCSI device is not self-identifying and does not have a
<tt>reg</tt> property. As a result, the driver must set the <tt>pm-hardware-state</tt> property. Setting
<tt>pm-hardware-state</tt> informs the framework that this device needs to be suspended and then
resumed.</p><p>The following example shows the SCSI target driver's <tt>attach()</tt> routine.</p><a name="scsi-42148"></a><h6>Example&nbsp;17-2 SCSI Target Driver <tt>attach</tt>(9E) Routine</h6><pre>static int
xxattach(dev_info_t *dip, ddi_attach_cmd_t cmd)
{
    struct xxstate         *xsp;
    struct scsi_pkt        *rqpkt = NULL;
    struct scsi_device     *sdp;
    struct buf         *bp = NULL;
    int            instance;
    instance = ddi_get_instance(dip);
    switch (cmd) {
      case DDI_ATTACH:
          break;
      case DDI_RESUME:
          /* For information, see the "Directory Memory Access (DMA)" */
          /* chapter in this book. */
      default:
          return (DDI_FAILURE);
    }
    /*
     * Allocate a state structure and initialize it.
     */
    xsp = ddi_get_soft_state(statep, instance);
    sdp = (struct scsi_device *)ddi_get_driver_private(dip);
    /*
     * Cross-link the state and scsi_device(9S) structures.
     */
    sdp-&gt;sd_private = (caddr_t)xsp;
    xsp-&gt;sdp = sdp;
    /*
     * Call scsi_probe(9F) again to get and validate inquiry data.
     * Allocate a request sense buffer. The buf(9S) structure
     * is set to NULL to tell the routine to allocate a new one.
     * The callback function is set to NULL_FUNC to tell the
     * routine to return failure immediately if no
     * resources are available.
     */
    bp = scsi_alloc_consistent_buf(&amp;sdp-&gt;sd_address, NULL,
    SENSE_LENGTH, B_READ, NULL_FUNC, NULL);
    if (bp == NULL)
        goto failed;
    /*
     * Create a Request Sense scsi_pkt(9S) structure.
     */
    rqpkt = scsi_init_pkt(&amp;sdp-&gt;sd_address, NULL, bp,
    CDB_GROUP0, 1, 0, PKT_CONSISTENT, NULL_FUNC, NULL);
    if (rqpkt == NULL)
        goto failed;
    /*
     * scsi_alloc_consistent_buf(9F) returned a buf(9S) structure.
     * The actual buffer address is in b_un.b_addr.
     */
    sdp-&gt;sd_sense = (struct scsi_extended_sense *)bp-&gt;b_un.b_addr;
    /*
     * Create a Group0 CDB for the Request Sense command
     */
    if (scsi_setup_cdb((union scsi_cdb *)rqpkt-&gt;pkt_cdbp,
        SCMD_REQUEST_SENSE, 0, SENSE__LENGTH, 0) == 0)
        goto failed;;
    /*
     * Fill in the rest of the scsi_pkt structure.
     * xxcallback() is the private command completion routine.
     */
    rqpkt-&gt;pkt_comp = xxcallback;
    rqpkt-&gt;pkt_time = 30; /* 30 second command timeout */
    rqpkt-&gt;pkt_flags |= FLAG_SENSING;
    xsp-&gt;rqs = rqpkt;
    xsp-&gt;rqsbuf = bp;
    /*
     * Create minor nodes, report device, and do any other initialization. */
     * Since the device does not have the 'reg' property,
     * cpr will not call its DDI_SUSPEND/DDI_RESUME entries.
     * The following code is to tell cpr that this device
     * needs to be suspended and resumed.
     */
    (void) ddi_prop_update_string(device, dip,
        "pm-hardware-state", "needs-suspend-resume");
    xsp-&gt;open = 0;
    return (DDI_SUCCESS);
failed:
    if (bp)
        scsi_free_consistent_buf(bp);
    if (rqpkt)
        scsi_destroy_pkt(rqpkt);
    sdp-&gt;sd_private = (caddr_t)NULL;
    sdp-&gt;sd_sense = NULL;
    scsi_unprobe(sdp);
    /* Free any other resources, such as the state structure. */
    return (DDI_FAILURE);
}</pre>

<a name="scsi-41573"></a><h4><tt>detach()</tt> Entry Point (SCSI Target Drivers)</h4>
<p>The <a href="http://docs.sun.com/doc/819-2255/detach-9e?a=view"><tt>detach</tt>(9E)</a> entry point is the inverse of <a href="http://docs.sun.com/doc/819-2255/attach-9e?a=view"><tt>attach</tt>(9E)</a>. <tt>detach()</tt> must free all
resources that were allocated in <tt>attach()</tt>. If successful, the detach should call
 <a href="http://docs.sun.com/doc/819-2256/scsi-unprobe-9f?a=view"><tt>scsi_unprobe</tt>(9F)</a>. The following example shows a target driver <tt>detach()</tt> routine.</p><a name="scsi-42748"></a><h6>Example&nbsp;17-3 SCSI Target Driver <tt>detach</tt>(9E) Routine</h6><pre>static int
xxdetach(dev_info_t *dip, ddi_detach_cmd_t cmd)
{
    struct xxstate *xsp;
    switch (cmd) {
      case DDI_DETACH:
          /*
           * Normal detach(9E) operations, such as getting a
           * pointer to the state structure
           */
          scsi_free_consistent_buf(xsp-&gt;rqsbuf);
          scsi_destroy_pkt(xsp-&gt;rqs);
          xsp-&gt;sdp-&gt;sd_private = (caddr_t)NULL;
          xsp-&gt;sdp-&gt;sd_sense = NULL;
          scsi_unprobe(xsp-&gt;sdp);
          /*
           * Remove minor nodes.
           * Free resources, such as the state structure and properties.
           */
          return (DDI_SUCCESS);
      case DDI_SUSPEND:
          /* For information, see the "Directory Memory Access (DMA)" */
          /* chapter in this book. */
      default:
          return (DDI_FAILURE);
    }
}</pre>

<a name="scsi-31824"></a><h4><tt>getinfo()</tt> Entry Point (SCSI Target Drivers)</h4>
<p>The <a href="http://docs.sun.com/doc/819-2255/getinfo-9e?a=view"><tt>getinfo</tt>(9E)</a> routine for SCSI target drivers is much the same as for
other drivers (see <a href="autoconf-60641.html#autoconf-28012"><tt>getinfo()</tt> Entry Point</a> for more information on <tt>DDI_INFO_DEVT2INSTANCE</tt> case). However, in the
<tt>DDI_INFO_DEVT2DEVINFO</tt> case of the <tt>getinfo()</tt> routine, the target driver must return a pointer
to its <tt>dev_info</tt> node. This pointer can be saved in the driver state
structure or can be retrieved from the <tt>sd_dev</tt> field of the <a href="http://docs.sun.com/doc/819-2257/scsi-device-9s?a=view"><tt>scsi_device</tt>(9S)</a>
structure. The following example shows an alternative SCSI target driver <tt>getinfo()</tt> code fragment.</p><a name="scsi-17982"></a><h6>Example&nbsp;17-4 Alternative SCSI Target Driver <tt>getinfo()</tt> Code Fragment</h6><pre>case DDI_INFO_DEVT2DEVINFO:
    dev = (dev_t)arg;
    instance = getminor(dev);
    xsp = ddi_get_soft_state(statep, instance);
    if (xsp == NULL)
        return (DDI_FAILURE);
    *result = (void *)xsp-&gt;sdp-&gt;sd_dev;
    return (DDI_SUCCESS);</pre>
         </div>
      </td>
   </tr>

   <tr class="PageControls" valign="top">
      <td></td>
      <td>
         <table width="100%">
      	   <tr>
      	     <td>
                 <a href="scsi-9.html">Previous</a>
             </td>
             <td align="right">
                 <a href="scsi-12.html">Next</a>
             </td>
           </tr>
         </table>
      </td>
   </tr>
</tbody>
</table>


</body>
</html>

