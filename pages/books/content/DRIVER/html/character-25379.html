<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="en-US">
<head>
<meta http-equiv="Content-type" content="text/html; charset=iso-8859-1">
<title>I/O Request Handling - Writing Device Drivers</title>
<meta name="robots" content="index,follow">
<meta name="robots" content="index,follow">
<meta name="date" content="2008-08-01">
<meta name="collection" content="reference">
<link rel="stylesheet" type="text/css" href="css/elements.css">
<link rel="stylesheet" type="text/css" href="css/indiana.css">
</head>

<body>


<div class="Masthead">
   <div class="MastheadLogo">
      <a href="http://www.opensolaris.org"><img border="0" src="graphics/header.png"></img></a>
   </div>
   <div class="Title">Writing Device Drivers</div>
</div>

<table class="Layout" border="0" cellspacing="0" width="100%">
<tbody>

   <tr valign="top" class="PageControls">
      <td></td>
      <td>
         <table width="100%">
      	   <tr>
      	     <td>
                 <a href="character-6.html">Previous</a>
             </td>
             <td align="right">
                 <a href="character-16543.html">Next</a>
             </td>
           </tr>
         </table>
      </td>
   </tr>
   
   <tr valign="top">
      <td class="Navigation" width="200px"><p class="toc level1"><a href="docinfo.html">Document Information</a></p>
<p class="toc level1 tocsp"><a href="preface-1.html">Preface</a></p>
<p class="toc level1 tocsp"><a href="eqbvu.html">Part&nbsp;I&nbsp;Designing Device Drivers for the Solaris Platform</a></p>
<p class="toc level2"><a href="eqbqn.html">1.&nbsp;&nbsp;Overview of Solaris Device Drivers</a></p>
<p class="toc level2"><a href="kernelovr-77198.html">2.&nbsp;&nbsp;Solaris Kernel and Device Tree</a></p>
<p class="toc level2"><a href="mt-17026.html">3.&nbsp;&nbsp;Multithreading</a></p>
<p class="toc level2"><a href="properties-1.html">4.&nbsp;&nbsp;Properties</a></p>
<p class="toc level2"><a href="events-1.html">5.&nbsp;&nbsp;Managing Events and Queueing Tasks</a></p>
<p class="toc level2"><a href="autoconf-17.html">6.&nbsp;&nbsp;Driver Autoconfiguration</a></p>
<p class="toc level2"><a href="devaccess-3.html">7.&nbsp;&nbsp;Device Access: Programmed I/O</a></p>
<p class="toc level2"><a href="interrupt-15678.html">8.&nbsp;&nbsp;Interrupt Handlers</a></p>
<p class="toc level2"><a href="dma-29901.html">9.&nbsp;&nbsp;Direct Memory Access (DMA)</a></p>
<p class="toc level2"><a href="devmap-24338.html">10.&nbsp;&nbsp;Mapping Device and Kernel Memory</a></p>
<p class="toc level2"><a href="devcnmgt-19679.html">11.&nbsp;&nbsp;Device Context Management</a></p>
<p class="toc level2"><a href="powermgt-37437.html">12.&nbsp;&nbsp;Power Management</a></p>
<p class="toc level2"><a href="gevsi.html">13.&nbsp;&nbsp;Hardening Solaris Drivers</a></p>
<p class="toc level2"><a href="ldi-1.html">14.&nbsp;&nbsp;Layered Driver Interface (LDI)</a></p>
<p class="toc level1 tocsp"><a href="eqbvb.html">Part&nbsp;II&nbsp;Designing Specific Kinds of Device Drivers</a></p>
<p class="toc level2"><a href="character-21002.html">15.&nbsp;&nbsp;Drivers for Character Devices</a></p>
<p class="toc level3"><a href="character-1.html">Overview of the Character Driver Structure</a></p>
<p class="toc level3"><a href="character-51.html">Character Device Autoconfiguration</a></p>
<p class="toc level3"><a href="character-6.html">Device Access (Character Drivers)</a></p>
<div class="onpage">
<p class="toc level3"><a href="">I/O Request Handling</a></p>
</div>
<p class="toc level3"><a href="character-16543.html">Mapping Device Memory</a></p>
<p class="toc level3"><a href="character-11313.html">Multiplexing I/O on File Descriptors</a></p>
<p class="toc level3"><a href="character-23939.html">Miscellaneous I/O Control</a></p>
<p class="toc level3"><a href="character-17.html">32-bit and 64-bit Data Structure Macros</a></p>
<p class="toc level2 tocsp"><a href="block-34861.html">16.&nbsp;&nbsp;Drivers for Block Devices</a></p>
<p class="toc level2"><a href="scsi-36812.html">17.&nbsp;&nbsp;SCSI Target Drivers</a></p>
<p class="toc level2"><a href="scsihba-32898.html">18.&nbsp;&nbsp;SCSI Host Bus Adapter Drivers</a></p>
<p class="toc level2"><a href="gld-1.html">19.&nbsp;&nbsp;Drivers for Network Devices</a></p>
<p class="toc level2"><a href="usb-1.html">20.&nbsp;&nbsp;USB Drivers</a></p>
<p class="toc level1 tocsp"><a href="eqbvo.html">Part&nbsp;III&nbsp;Building a Device Driver</a></p>
<p class="toc level2"><a href="loading-15035.html">21.&nbsp;&nbsp;Compiling, Loading, Packaging, and Testing Drivers</a></p>
<p class="toc level2"><a href="debug-60.html">22.&nbsp;&nbsp;Debugging, Testing, and Tuning Device Drivers</a></p>
<p class="toc level2"><a href="coding-practices.html">23.&nbsp;&nbsp;Recommended Coding Practices</a></p>
<p class="toc level1 tocsp"><a href="eqbva.html">Part&nbsp;IV&nbsp;Appendixes</a></p>
<p class="toc level2"><a href="hwovr-18191.html">A.&nbsp;&nbsp;Hardware Overview</a></p>
<p class="toc level2"><a href="ddidkisvc-29227.html">B.&nbsp;&nbsp;Summary of Solaris DDI/DKI Services</a></p>
<p class="toc level2"><a href="lp64-35004.html">C.&nbsp;&nbsp;Making a Device Driver 64-Bit Ready</a></p>
<p class="toc level2"><a href="euazz.html">D.&nbsp;&nbsp;Console Frame Buffer Drivers</a></p>
<p class="toc level1 tocsp"><a href="idx-1.html">Index</a></p>
</td>
      <td class="ContentPane" width="705px">

	 <div class="MainContent">      	 
             

<a name="character-25379"></a><h3>I/O Request Handling</h3>
<p><a name="character-ix375"></a><a name="character-ix376"></a>This section discusses I/O request processing in detail. </p>

<a name="character-9"></a><h4>User Addresses</h4>
<p><a name="character-ix377"></a>When a user thread issues a <a href="http://docs.sun.com/doc/819-2241/write-2?a=view"><tt>write</tt>(2)</a> system call, the thread passes the address
of a buffer in user space:</p><pre>char buffer[] = "python";
count = write(fd, buffer, strlen(buffer) + 1);</pre><p>The system builds a <a href="http://docs.sun.com/doc/819-2257/uio-9s?a=view"><tt>uio</tt>(9S)</a> structure to describe this transfer by allocating an
<a href="http://docs.sun.com/doc/819-2257/iovec-9s?a=view"><tt>iovec</tt>(9S)</a> structure and setting the <tt>iov_base</tt> field to the address passed to
<a href="http://docs.sun.com/doc/819-2241/write-2?a=view"><tt>write</tt>(2)</a>, in this case, <tt>buffer</tt>. The <a href="http://docs.sun.com/doc/819-2257/uio-9s?a=view"><tt>uio</tt>(9S)</a> structure is passed to the driver 
<a href="http://docs.sun.com/doc/819-2255/write-9e?a=view"><tt>write</tt>(9E)</a> routine. See <a href="#character-15613">Vectored I/O</a> for more information about the <a href="http://docs.sun.com/doc/819-2257/uio-9s?a=view"><tt>uio</tt>(9S)</a> structure.</p><p>The address in the <a href="http://docs.sun.com/doc/819-2257/iovec-9s?a=view"><tt>iovec</tt>(9S)</a> is in user space, not kernel space. Thus,
the address is neither guaranteed to be currently in memory nor  to
be a valid address. In either case, accessing a user address directly from
the device driver or from the kernel could crash the system. Thus, device
drivers should never access user addresses directly. Instead, a data transfer routine in
the Solaris DDI/DKI should be used to transfer data into or out of
the kernel. These routines can handle page faults. The DDI/DKI routines can bring
in the proper user page to continue the copy transparently. Alternatively, the routines
can return an error on an invalid access.</p><p><a name="character-ix378"></a><a name="character-ix379"></a><a href="http://docs.sun.com/doc/819-2256/copyout-9f?a=view"><tt>copyout</tt>(9F)</a> can be used to copy data from kernel space to user space.
<a href="http://docs.sun.com/doc/819-2256/copyin-9f?a=view"><tt>copyin</tt>(9F)</a> can copy data from user space to kernel space. <a href="http://docs.sun.com/doc/819-2256/ddi-copyout-9f?a=view"><tt>ddi_copyout</tt>(9F)</a> and <a href="http://docs.sun.com/doc/819-2256/ddi-copyin-9f?a=view"><tt>ddi_copyin</tt>(9F)</a>
operate similarly but are to be used in the <a href="http://docs.sun.com/doc/819-2255/ioctl-9e?a=view"><tt>ioctl</tt>(9E)</a> routine. <a href="http://docs.sun.com/doc/819-2256/copyin-9f?a=view"><tt>copyin</tt>(9F)</a> and
<a href="http://docs.sun.com/doc/819-2256/copyout-9f?a=view"><tt>copyout</tt>(9F)</a> can be used on the buffer described by each <a href="http://docs.sun.com/doc/819-2257/iovec-9s?a=view"><tt>iovec</tt>(9S)</a> structure, or
<a href="http://docs.sun.com/doc/819-2256/uiomove-9f?a=view"><tt>uiomove</tt>(9F)</a> can perform the entire transfer to or from a contiguous area of
driver or device memory.</p>

<a name="character-15613"></a><h4>Vectored I/O</h4>
<p>In character drivers, transfers are described by a <a href="http://docs.sun.com/doc/819-2257/uio-9s?a=view"><tt>uio</tt>(9S)</a> structure. The <a href="http://docs.sun.com/doc/819-2257/uio-9s?a=view"><tt>uio</tt>(9S)</a>
structure contains information about the direction and size of the transfer, plus an
array of buffers for one end of the transfer. The other end is
the device.</p><p>The <a href="http://docs.sun.com/doc/819-2257/uio-9s?a=view"><tt>uio</tt>(9S)</a> structure contains the following members:</p><pre>iovec_t       *uio_iov;       /* base address of the iovec */
                              /* buffer description array */
int           uio_iovcnt;     /* the number of iovec structures */
off_t         uio_offset;     /* 32-bit offset into file where */
                              /* data is transferred from or to */
offset_t      uio_loffset;    /* 64-bit offset into file where */
                              /* data is transferred from or to */
uio_seg_t     uio_segflg;     /* identifies the type of I/O transfer */
                              /* UIO_SYSSPACE:  kernel &lt;-&gt; kernel */
                              /* UIO_USERSPACE: kernel &lt;-&gt; user */
short         uio_fmode;      /* file mode flags (not driver setTable) */
daddr_t       uio_limit;      /* 32-bit ulimit for file (maximum */
                              /* block offset). not driver settable. */
diskaddr_t    uio_llimit;     /* 64-bit ulimit for file (maximum block */
                              /* block offset). not driver settable. */
int           uio_resid;      /* amount (in bytes) not */
                              /* transferred on completion */</pre><p><a name="character-ix382"></a><a name="character-ix383"></a>A <a href="http://docs.sun.com/doc/819-2257/uio-9s?a=view"><tt>uio</tt>(9S)</a> structure is passed to the driver <a href="http://docs.sun.com/doc/819-2255/read-9e?a=view"><tt>read</tt>(9E)</a> and <a href="http://docs.sun.com/doc/819-2255/write-9e?a=view"><tt>write</tt>(9E)</a> entry points.
This structure is generalized to support what is called <b>gather-write</b> and <b>scatter-read</b>. When
writing to a device, the data buffers to be written do not have
to be contiguous in application memory. Similarly, data that is transferred from a
device into memory comes off in a contiguous stream but can go into
noncontiguous areas of application memory. See the <a href="http://docs.sun.com/doc/819-2241/readv-2?a=view"><tt>readv</tt>(2)</a>, <a href="http://docs.sun.com/doc/819-2241/writev-2?a=view"><tt>writev</tt>(2)</a>, <a href="http://docs.sun.com/doc/819-2241/pread-2?a=view"><tt>pread</tt>(2)</a>, and <a href="http://docs.sun.com/doc/819-2241/pwrite-2?a=view"><tt>pwrite</tt>(2)</a>
man pages for more information on scatter-gather I/O.</p><p><a name="character-ix384"></a>Each buffer is described by an <a href="http://docs.sun.com/doc/819-2257/iovec-9s?a=view"><tt>iovec</tt>(9S)</a> structure. This structure contains a pointer
to the data area and the number of bytes to be transferred.</p><pre>caddr_t    iov_base;    /* address of buffer */
int        iov_len;     /* amount to transfer */</pre><p>The <tt>uio</tt> structure contains a pointer to an array of <a href="http://docs.sun.com/doc/819-2257/iovec-9s?a=view"><tt>iovec</tt>(9S)</a> structures. The base
address of this array is held in <tt>uio_iov</tt>, and the number of elements
is stored in <tt>uio_iovcnt</tt>.</p><p>The <tt>uio_offset</tt> field contains the 32-bit offset into the device at which the
application needs to begin the transfer. <tt>uio_loffset</tt> is used for 64-bit file
offsets. If the device does not support the notion of an offset, these
fields can be safely ignored. The driver should interpret either <tt>uio_offset</tt> or <tt>uio_loffset</tt>,
but not both. If the driver has set the <tt>D_64BIT</tt> flag in
the <a href="http://docs.sun.com/doc/819-2257/cb-ops-9s?a=view"><tt>cb_ops</tt>(9S)</a> structure, that driver should use <tt>uio_loffset</tt>.</p><p>The <tt>uio_resid</tt> field starts out as the number of bytes to be transferred,
that is, the sum of all the <tt>iov_len</tt> fields in <tt>uio_iov</tt>. This field
<b>must</b> be set by the driver to the number of bytes that were
<b>not</b> transferred before returning. The <a href="http://docs.sun.com/doc/819-2241/read-2?a=view"><tt>read</tt>(2)</a> and <a href="http://docs.sun.com/doc/819-2241/write-2?a=view"><tt>write</tt>(2)</a> system calls use the return value
from the <a href="http://docs.sun.com/doc/819-2255/read-9e?a=view"><tt>read</tt>(9E)</a> and <a href="http://docs.sun.com/doc/819-2255/write-9e?a=view"><tt>write</tt>(9E)</a> entry points to determine failed transfers. If a
failure occurs, these routines return -1. If the return value indicates success, the
system calls return the number of bytes requested minus <tt>uio_resid</tt>. If <tt>uio_resid</tt> is not
changed by the driver, the <a href="http://docs.sun.com/doc/819-2241/read-2?a=view"><tt>read</tt>(2)</a> and <a href="http://docs.sun.com/doc/819-2241/write-2?a=view"><tt>write</tt>(2)</a> calls return 0. A
return value of 0 indicates end-of-file, even though all the data has been
transferred.</p><p>The support routines <a href="http://docs.sun.com/doc/819-2256/uiomove-9f?a=view"><tt>uiomove</tt>(9F)</a>, <a href="http://docs.sun.com/doc/819-2256/physio-9f?a=view"><tt>physio</tt>(9F)</a>, and  <a href="http://docs.sun.com/doc/819-2256/aphysio-9f?a=view"><tt>aphysio</tt>(9F)</a> update the <a href="http://docs.sun.com/doc/819-2257/uio-9s?a=view"><tt>uio</tt>(9S)</a> structure
directly. These support routines update the device offset to account for the data
transfer. Neither the <tt>uio_offset</tt> or <tt>uio_loffset</tt> fields need to be adjusted when the driver
is used with a seekable device that uses the concept of position. I/O
performed to a device in this manner is constrained by the maximum possible
value of <tt>uio_offset</tt> or <tt>uio_loffset</tt>. An example of such a usage is
raw I/O on a disk.</p><p>If the device has no concept of position, the driver can take
the following steps:</p>
<ol><li><p>Save <tt>uio_offset</tt> or <tt>uio_loffset</tt>.</p></li>
<li><p>Perform the I/O operation.</p></li>
<li><p>Restore <tt>uio_offset</tt> or <tt>uio_loffset</tt> to the field's initial value.</p></li></ol>
<p>I/O that is performed to a device in this manner is not
constrained by the maximum possible value of <tt>uio_offset</tt> or <tt>uio_loffset</tt>. An example of
this type of usage is I/O on a serial line.</p><p>The following example shows one way to preserve <tt>uio_loffset</tt> in the  <a href="http://docs.sun.com/doc/819-2255/read-9e?a=view"><tt>read</tt>(9E)</a>
function.</p><pre>static int
xxread(dev_t dev, struct uio *uio_p, cred_t *cred_p)
{
    offset_t off;
    /* ... */
    off = uio_p-&gt;uio_loffset;  /* save the offset */
    /* do the transfer */
    uio_p-&gt;uio_loffset = off;  /* restore it */
}</pre>

<a name="character-11"></a><h4>Differences Between Synchronous and Asynchronous I/O</h4>
<p><a name="indexterm-568"></a><a name="indexterm-569"></a>Data transfers can be <b>synchronous</b> or <b>asynchronous</b>. The determining factor is whether the
entry point that schedules the transfer returns immediately or waits until the I/O
has been completed.</p><p><a name="character-ix385a"></a><a name="character-ix385b"></a><a name="character-ix387"></a>The <a href="http://docs.sun.com/doc/819-2255/read-9e?a=view"><tt>read</tt>(9E)</a> and  <a href="http://docs.sun.com/doc/819-2255/write-9e?a=view"><tt>write</tt>(9E)</a> entry points are synchronous entry points. The transfer must
not return until the I/O is complete. Upon return from the routines, the
process knows whether the transfer has succeeded.</p><p><a name="character-ix385c"></a><a name="character-ix385"></a>The  <a href="http://docs.sun.com/doc/819-2255/aread-9e?a=view"><tt>aread</tt>(9E)</a> and <a href="http://docs.sun.com/doc/819-2255/awrite-9e?a=view"><tt>awrite</tt>(9E)</a> entry points are asynchronous entry points. Asynchronous entry
points schedule the I/O and return immediately. Upon return, the process that issues
the request knows that the I/O is scheduled and that the status of
the I/O must be determined later. In the meantime, the process can perform
other operations. </p><p><a name="character-ix390"></a>With an asynchronous I/O request to the kernel, the process is not required
to wait while the I/O is in process. A process can perform multiple
I/O requests and allow the kernel to handle the data transfer details. Asynchronous
I/O requests enable applications such as transaction processing to use concurrent programming methods
to increase performance or response time. Any performance boost for applications that use asynchronous
I/O, however, comes at the expense of greater programming complexity.</p>

<a name="character-22917"></a><h4>Data Transfer Methods</h4>
<p>Data can be transferred using either programmed I/O or DMA. These data transfer
methods can be used either by synchronous or by asynchronous entry points, depending
on the capabilities of the device.</p>

<a name="character-12"></a><h5>Programmed I/O Transfers</h5>
<p><a name="character-ix391"></a><a name="character-ix392"></a>Programmed I/O devices rely on the CPU to perform the data transfer. Programmed
I/O data transfers are identical to other read and write operations for device
registers. Various data access routines are used to read or store values to
device memory.</p><p><a name="character-ix393"></a><a name="indexterm-570"></a><a href="http://docs.sun.com/doc/819-2256/uiomove-9f?a=view"><tt>uiomove</tt>(9F)</a> can be used to transfer data to some programmed I/O devices. 
<a href="http://docs.sun.com/doc/819-2256/uiomove-9f?a=view"><tt>uiomove</tt>(9F)</a> transfers data between the user space, as defined by the <tt>uio(9S)</tt> structure,
and the kernel.  <tt>uiomove()</tt>  can handle page faults, so the memory to
which data is transferred need not be locked down. <tt>uiomove()</tt> also updates the
<tt>uio_resid</tt> field in the <a href="http://docs.sun.com/doc/819-2257/uio-9s?a=view"><tt>uio</tt>(9S)</a> structure. The following example shows one way to
write a ramdisk <a href="http://docs.sun.com/doc/819-2255/read-9e?a=view"><tt>read</tt>(9E)</a> routine. It uses synchronous I/O and relies on the
presence of the following fields in the ramdisk state structure:</p><pre>caddr_t    ram;        /* base address of ramdisk */
int        ramsize;    /* size of the ramdisk */</pre><a name="character-31915"></a><h6>Example&nbsp;15-3 Ramdisk <tt>read</tt>(9E) Routine Using <tt>uiomove</tt>(9F)</h6><pre>static int
rd_read(dev_t dev, struct uio *uiop, cred_t *credp)
{
     rd_devstate_t     *rsp;

     rsp = ddi_get_soft_state(rd_statep, getminor(dev));
     if (rsp == NULL)
       return (ENXIO);
     if (uiop-&gt;uio_offset &gt;= rsp-&gt;ramsize)
       return (EINVAL);
     /*
      * uiomove takes the offset into the kernel buffer,
      * the data transfer count (minimum of the requested and
      * the remaining data), the UIO_READ flag, and a pointer
      * to the uio structure.
      */
     return (uiomove(rsp-&gt;ram + uiop-&gt;uio_offset,
         min(uiop-&gt;uio_resid, rsp-&gt;ramsize - uiop-&gt;uio_offset),
         UIO_READ, uiop));
}</pre><p>Another example of programmed I/O would be a driver that writes data one
byte at a time directly to the device's memory. Each byte is
retrieved from the <a href="http://docs.sun.com/doc/819-2257/uio-9s?a=view"><tt>uio</tt>(9S)</a> structure by using <a href="http://docs.sun.com/doc/819-2256/uwritec-9f?a=view"><tt>uwritec</tt>(9F)</a>. The byte is then sent to the
device. <a href="http://docs.sun.com/doc/819-2255/read-9e?a=view"><tt>read</tt>(9E)</a> can use <a href="http://docs.sun.com/doc/819-2256/ureadc-9f?a=view"><tt>ureadc</tt>(9F)</a> to transfer a byte from the device to
the area described by the <a href="http://docs.sun.com/doc/819-2257/uio-9s?a=view"><tt>uio</tt>(9S)</a> structure.</p><a name="character-ex-15"></a><h6>Example&nbsp;15-4 Programmed I/O <tt>write</tt>(9E) Routine Using <tt>uwritec</tt>(9F)</h6><pre>static int
xxwrite(dev_t dev, struct uio *uiop, cred_t *credp)
{
    int    value;
    struct xxstate     *xsp;

    xsp = ddi_get_soft_state(statep, getminor(dev));
    if (xsp == NULL)
        return (ENXIO);
    /* if the device implements a power manageable component, do this: */
    pm_busy_component(xsp-&gt;dip, 0);
    if (xsp-&gt;pm_suspended)
        pm_raise_power(xsp-&gt;dip, normal power);

    while (uiop-&gt;uio_resid &gt; 0) {
        /*
         * do the programmed I/O access
         */
        value = uwritec(uiop);
        if (value == -1)
               return (EFAULT);
        ddi_put8(xsp-&gt;data_access_handle, &amp;xsp-&gt;regp-&gt;data,
            (uint8_t)value);
        ddi_put8(xsp-&gt;data_access_handle, &amp;xsp-&gt;regp-&gt;csr,
            START_TRANSFER);
        /*
         * this device requires a ten microsecond delay
         * between writes
         */
        drv_usecwait(10);
    }
    pm_idle_component(xsp-&gt;dip, 0);
    return (0);
}</pre>

<a name="character-35745"></a><h5>DMA Transfers (Synchronous)</h5>
<a name="character-ix394"></a><p><a name="character-ix395a"></a><a name="character-ix396"></a><a name="character-ix397a"></a>Character drivers generally use  <a href="http://docs.sun.com/doc/819-2256/physio-9f?a=view"><tt>physio</tt>(9F)</a> to do the setup work for DMA transfers
in  <a href="http://docs.sun.com/doc/819-2255/read-9e?a=view"><tt>read</tt>(9E)</a> and <a href="http://docs.sun.com/doc/819-2255/write-9e?a=view"><tt>write</tt>(9E)</a>, as is shown in <a href="#character-36010">Example&nbsp;15-5</a>.</p><pre>int physio(int (*<i>strat</i>)(struct <i>buf</i> *), struct buf *<i>bp</i>,
     dev_t <i>dev</i>, int <i>rw</i>, void (*<i>mincnt</i>)(struct <i>buf</i> *),
     struct uio *<i>uio</i>);</pre><p><a href="http://docs.sun.com/doc/819-2256/physio-9f?a=view"><tt>physio</tt>(9F)</a> requires the driver to provide the address of a <a href="http://docs.sun.com/doc/819-2255/strategy-9e?a=view"><tt>strategy</tt>(9E)</a> routine. 
<a href="http://docs.sun.com/doc/819-2256/physio-9f?a=view"><tt>physio</tt>(9F)</a> ensures that memory space is locked down, that is, memory cannot be
paged out, for the duration of the data transfer. This lock-down is necessary
for DMA transfers because DMA transfers cannot handle page faults.  <a href="http://docs.sun.com/doc/819-2256/physio-9f?a=view"><tt>physio</tt>(9F)</a> also
provides an automated way of breaking a larger transfer into a series of
smaller, more manageable ones. See <a href="#character-42867"><tt>minphys()</tt> Entry Point</a> for more information.</p><a name="character-36010"></a><h6>Example&nbsp;15-5 <tt>read</tt>(9E) and <tt>write</tt>(9E) Routines Using <tt>physio</tt>(9F)</h6><pre>static int
xxread(dev_t dev, struct uio *uiop, cred_t *credp)
{
     struct xxstate *xsp;
     int ret;

     xsp = ddi_get_soft_state(statep, getminor(dev));
     if (xsp == NULL)
        return (ENXIO);
     ret = physio(xxstrategy, NULL, dev, B_READ, xxminphys, uiop);
     return (ret);
}    

static int
xxwrite(dev_t dev, struct uio *uiop, cred_t *credp)
{     
     struct xxstate *xsp;
     int ret;

     xsp = ddi_get_soft_state(statep, getminor(dev));
     if (xsp == NULL)
        return (ENXIO);
     ret = physio(xxstrategy, NULL, dev, B_WRITE, xxminphys, uiop);
     return (ret);
}</pre><p>In the call to <a href="http://docs.sun.com/doc/819-2256/physio-9f?a=view"><tt>physio</tt>(9F)</a>, <tt>xxstrategy</tt> is a pointer to the driver
<tt>strategy()</tt> routine. Passing <tt>NULL</tt> as the <a href="http://docs.sun.com/doc/819-2257/buf-9s?a=view"><tt>buf</tt>(9S)</a> structure pointer tells <a href="http://docs.sun.com/doc/819-2256/physio-9f?a=view"><tt>physio</tt>(9F)</a> to allocate
a <a href="http://docs.sun.com/doc/819-2257/buf-9s?a=view"><tt>buf</tt>(9S)</a> structure. If the driver must provide <a href="http://docs.sun.com/doc/819-2256/physio-9f?a=view"><tt>physio</tt>(9F)</a> with a <a href="http://docs.sun.com/doc/819-2257/buf-9s?a=view"><tt>buf</tt>(9S)</a> structure, <a href="http://docs.sun.com/doc/819-2256/getrbuf-9f?a=view"><tt>getrbuf</tt>(9F)</a>
should be used to allocate the structure. <a href="http://docs.sun.com/doc/819-2256/physio-9f?a=view"><tt>physio</tt>(9F)</a> returns zero if the transfer completes
successfully, or an error number on failure. After calling <a href="http://docs.sun.com/doc/819-2255/strategy-9e?a=view"><tt>strategy</tt>(9E)</a>, <a href="http://docs.sun.com/doc/819-2256/physio-9f?a=view"><tt>physio</tt>(9F)</a> calls
 <a href="http://docs.sun.com/doc/819-2256/biowait-9f?a=view"><tt>biowait</tt>(9F)</a> to block until the transfer either completes or fails. The return
value of <a href="http://docs.sun.com/doc/819-2256/physio-9f?a=view"><tt>physio</tt>(9F)</a> is determined by the error field in the <a href="http://docs.sun.com/doc/819-2257/buf-9s?a=view"><tt>buf</tt>(9S)</a> structure set
by  <a href="http://docs.sun.com/doc/819-2256/bioerror-9f?a=view"><tt>bioerror</tt>(9F)</a>.</p>

<a name="character-16"></a><h5>DMA Transfers (Asynchronous)</h5>
<p><a name="character-ix395"></a><a name="character-ix397b"></a>Character drivers that support  <a href="http://docs.sun.com/doc/819-2255/aread-9e?a=view"><tt>aread</tt>(9E)</a> and <a href="http://docs.sun.com/doc/819-2255/awrite-9e?a=view"><tt>awrite</tt>(9E)</a> use <a href="http://docs.sun.com/doc/819-2256/aphysio-9f?a=view"><tt>aphysio</tt>(9F)</a> instead of
<a href="http://docs.sun.com/doc/819-2256/physio-9f?a=view"><tt>physio</tt>(9F)</a>.</p><pre>int aphysio(int (*<i>strat</i>)(struct <i>buf</i> *), int (*<i>cancel</i>)(struct <i>buf</i> *),
     dev_t <i>dev</i>, int <i>rw</i>, void (*<i>mincnt</i>)(struct <i>buf</i> *),
     struct aio_req *<i>aio_reqp</i>);</pre>
<hr><p><b>Note - </b>The address of  <a href="http://docs.sun.com/doc/819-2256/anocancel-9f?a=view"><tt>anocancel</tt>(9F)</a> is the only value that can currently be
passed as the second argument to  <a href="http://docs.sun.com/doc/819-2256/aphysio-9f?a=view"><tt>aphysio</tt>(9F)</a>.</p>
<hr>
<p><a href="http://docs.sun.com/doc/819-2256/aphysio-9f?a=view"><tt>aphysio</tt>(9F)</a> requires the driver to pass the address of a <a href="http://docs.sun.com/doc/819-2255/strategy-9e?a=view"><tt>strategy</tt>(9E)</a> routine. 
<a href="http://docs.sun.com/doc/819-2256/aphysio-9f?a=view"><tt>aphysio</tt>(9F)</a> ensures that memory space is locked down, that is, cannot be paged
out, for the duration of the data transfer. This lock-down is necessary for
DMA transfers because DMA transfers cannot handle page faults.  <a href="http://docs.sun.com/doc/819-2256/aphysio-9f?a=view"><tt>aphysio</tt>(9F)</a> also provides
an automated way of breaking a larger transfer into a series of smaller,
more manageable ones. See <a href="#character-42867"><tt>minphys()</tt> Entry Point</a> for more information.</p><p><a href="#character-36010">Example&nbsp;15-5</a> and <a href="#character-29697">Example&nbsp;15-6</a> demonstrate that the  <a href="http://docs.sun.com/doc/819-2255/aread-9e?a=view"><tt>aread</tt>(9E)</a> and <a href="http://docs.sun.com/doc/819-2255/awrite-9e?a=view"><tt>awrite</tt>(9E)</a> entry points differ only
slightly from the  <a href="http://docs.sun.com/doc/819-2255/read-9e?a=view"><tt>read</tt>(9E)</a> and <a href="http://docs.sun.com/doc/819-2255/write-9e?a=view"><tt>write</tt>(9E)</a> entry points. The difference is primarily
in their use of <a href="http://docs.sun.com/doc/819-2256/aphysio-9f?a=view"><tt>aphysio</tt>(9F)</a> instead of <a href="http://docs.sun.com/doc/819-2256/physio-9f?a=view"><tt>physio</tt>(9F)</a>.</p><a name="character-29697"></a><h6>Example&nbsp;15-6 <tt>aread</tt>(9E) and <tt>awrite</tt>(9E) Routines Using <tt>aphysio</tt>(9F)</h6><pre>static int
xxaread(dev_t dev, struct aio_req *aiop, cred_t *cred_p)
{
     struct xxstate *xsp;

     xsp = ddi_get_soft_state(statep, getminor(dev));
     if (xsp == NULL)
         return (ENXIO);
     return (aphysio(xxstrategy, anocancel, dev, B_READ,
     xxminphys, aiop));
}

static int
xxawrite(dev_t dev, struct aio_req *aiop, cred_t *cred_p)
{
     struct xxstate *xsp;

     xsp = ddi_get_soft_state(statep, getminor(dev));
     if (xsp == NULL)
        return (ENXIO);
     return (aphysio(xxstrategy, anocancel, dev, B_WRITE,
     xxminphys,aiop));  
}</pre><p>In the call to  <a href="http://docs.sun.com/doc/819-2256/aphysio-9f?a=view"><tt>aphysio</tt>(9F)</a>, <tt>xxstrategy()</tt> is a pointer to the
driver strategy routine. <i>aiop</i> is a pointer to the <a href="http://docs.sun.com/doc/819-2257/aio-req-9s?a=view"><tt>aio_req</tt>(9S)</a> structure. <i>aiop</i>
is passed to  <a href="http://docs.sun.com/doc/819-2255/aread-9e?a=view"><tt>aread</tt>(9E)</a> and <a href="http://docs.sun.com/doc/819-2255/awrite-9e?a=view"><tt>awrite</tt>(9E)</a>.   <a href="http://docs.sun.com/doc/819-2257/aio-req-9s?a=view"><tt>aio_req</tt>(9S)</a> describes where the data
is to be stored in user space.  <a href="http://docs.sun.com/doc/819-2256/aphysio-9f?a=view"><tt>aphysio</tt>(9F)</a> returns zero if
the I/O request is scheduled successfully or an error number on failure. After
calling <a href="http://docs.sun.com/doc/819-2255/strategy-9e?a=view"><tt>strategy</tt>(9E)</a>,  <a href="http://docs.sun.com/doc/819-2256/aphysio-9f?a=view"><tt>aphysio</tt>(9F)</a> returns without waiting for the I/O to complete or
fail.</p>

<a name="character-42867"></a><h5><tt>minphys()</tt> Entry Point</h5>
<p><a name="character-ix395e"></a><a name="character-ix397c"></a>The <tt>minphys()</tt> entry point is a pointer to a function to be called
by  <a href="http://docs.sun.com/doc/819-2256/physio-9f?a=view"><tt>physio</tt>(9F)</a> or <a href="http://docs.sun.com/doc/819-2256/aphysio-9f?a=view"><tt>aphysio</tt>(9F)</a>. The purpose of <i>xxminphys</i> is to ensure that
the size of the requested transfer does not exceed a driver-imposed limit. If
the user requests a larger transfer,  <a href="http://docs.sun.com/doc/819-2255/strategy-9e?a=view"><tt>strategy</tt>(9E)</a> is called repeatedly, requesting no more
than the imposed limit at a time. This approach is important because DMA
resources are limited. Drivers for slow devices, such as printers, should be careful
not to tie up resources for a long time.</p><p>Usually, a driver passes the address of the kernel function  <a href="http://docs.sun.com/doc/819-2256/minphys-9f?a=view"><tt>minphys</tt>(9F)</a>,
but the driver can define its own <tt>xxminphys()</tt> routine instead. The job of <tt>xxminphys()</tt>
is to keep the <tt>b_bcount</tt> field of the <a href="http://docs.sun.com/doc/819-2257/buf-9s?a=view"><tt>buf</tt>(9S)</a> structure under a driver's limit.
The driver should adhere to other system limits as well. For example, the
driver's <tt>xxminphys()</tt> routine should call the system <a href="http://docs.sun.com/doc/819-2256/minphys-9f?a=view"><tt>minphys</tt>(9F)</a> routine after setting the <tt>b_bcount</tt> field
and before returning.</p><a name="character-ex-17"></a><h6>Example&nbsp;15-7 <tt>minphys</tt>(9F) Routine</h6><pre>#define XXMINVAL (512 &lt;&lt; 10)    /* 512 KB */
static void
xxminphys(struct buf *bp)
{
    if (bp-&gt;b_bcount &gt; XXMINVAL)
        bp-&gt;b_bcount = XXMINVAL
    minphys(bp);
}</pre>

<a name="character-64481"></a><h5><tt>strategy()</tt> Entry Point</h5>
<p><a name="character-ix395f"></a><a name="character-ix397d"></a>The  <a href="http://docs.sun.com/doc/819-2255/strategy-9e?a=view"><tt>strategy</tt>(9E)</a> routine originated in block drivers. The strategy function got its
name from implementing a strategy for efficient queuing of I/O requests to a
block device. A driver for a character-oriented device can also use a <tt>strategy(9E)</tt>
routine. In the character I/O model presented here,  <a href="http://docs.sun.com/doc/819-2255/strategy-9e?a=view"><tt>strategy</tt>(9E)</a> does not maintain
a queue of requests, but rather services one request at a time.</p><p>In the following example, the <a href="http://docs.sun.com/doc/819-2255/strategy-9e?a=view"><tt>strategy</tt>(9E)</a> routine for a character-oriented DMA device allocates
DMA resources for synchronous data transfer. <tt>strategy()</tt> starts the command by programming
the device register. See <a href="dma-29901.html">Chapter&nbsp;9, Direct Memory Access (DMA)</a> for a detailed description.</p>
<hr><p><b>Note - </b><a href="http://docs.sun.com/doc/819-2255/strategy-9e?a=view"><tt>strategy</tt>(9E)</a> does not receive a device number (<tt>dev_t</tt>) as a parameter. Instead, the device
number is retrieved from the <tt>b_edev</tt> field of the <a href="http://docs.sun.com/doc/819-2257/buf-9s?a=view"><tt>buf</tt>(9S)</a> structure passed to <a href="http://docs.sun.com/doc/819-2255/strategy-9e?a=view"><tt>strategy</tt>(9E)</a>.</p>
<hr>
<a name="character-35679"></a><h6>Example&nbsp;15-8 <tt>strategy</tt>(9E) Routine</h6><pre>static int
xxstrategy(struct buf *bp)
{
     minor_t            instance;
     struct xxstate     *xsp;
     ddi_dma_cookie_t   cookie;

     instance = getminor(bp-&gt;b_edev);
     xsp = ddi_get_soft_state(statep, instance);
     /* ... */
      * If the device has power manageable components,
      * mark the device busy with pm_busy_components(9F),
      * and then ensure that the device is
      * powered up by calling pm_raise_power(9F).
      */
     /* Set up DMA resources with ddi_dma_alloc_handle(9F) and
      * ddi_dma_buf_bind_handle(9F).
      */
     xsp-&gt;bp = bp; /* remember bp */
     /* Program DMA engine and start command */
     return (0);
}</pre>
<hr><p><b>Note - </b>Although <tt>strategy()</tt> is declared to return an <tt>int</tt>, <tt>strategy()</tt> must always return
zero.</p>
<hr>
<p>On completion of the DMA transfer, the device generates an interrupt, causing the
interrupt routine to be called. In the following example, <tt>xxintr()</tt> receives a
pointer to the state structure for the device that might have generated the
interrupt.</p><a name="character-28538"></a><h6>Example&nbsp;15-9 Interrupt Routine</h6><pre>static u_int
xxintr(caddr_t arg)
{
     struct xxstate *xsp = (struct xxstate *)arg;
     if ( /* device did not interrupt */ ) {
        return (DDI_INTR_UNCLAIMED);
     }
     if ( /* error */ ) {
        /* error handling */
     }
     /* Release any resources used in the transfer, such as DMA resources.
      * ddi_dma_unbind_handle(9F) and ddi_dma_free_handle(9F)
      * Notify threads that the transfer is complete.
      */
     biodone(xsp-&gt;bp);
     return (DDI_INTR_CLAIMED);
}</pre><p>The driver indicates an error by calling <a href="http://docs.sun.com/doc/819-2256/bioerror-9f?a=view"><tt>bioerror</tt>(9F)</a>. The driver must call
 <a href="http://docs.sun.com/doc/819-2256/biodone-9f?a=view"><tt>biodone</tt>(9F)</a> when the transfer is complete or after indicating an error with
 <a href="http://docs.sun.com/doc/819-2256/bioerror-9f?a=view"><tt>bioerror</tt>(9F)</a>.</p>
         </div>
      </td>
   </tr>

   <tr class="PageControls" valign="top">
      <td></td>
      <td>
         <table width="100%">
      	   <tr>
      	     <td>
                 <a href="character-6.html">Previous</a>
             </td>
             <td align="right">
                 <a href="character-16543.html">Next</a>
             </td>
           </tr>
         </table>
      </td>
   </tr>
</tbody>
</table>


</body>
</html>

