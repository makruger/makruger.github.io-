<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="en-US">
<head>
<meta http-equiv="Content-type" content="text/html; charset=iso-8859-1">
<title>DMA Operations - Writing Device Drivers</title>
<meta name="robots" content="index,follow">
<meta name="robots" content="index,follow">
<meta name="date" content="2008-08-01">
<meta name="collection" content="reference">
<link rel="stylesheet" type="text/css" href="css/elements.css">
<link rel="stylesheet" type="text/css" href="css/indiana.css">
</head>

<body>


<div class="Masthead">
   <div class="MastheadLogo">
      <a href="http://www.opensolaris.org"><img border="0" src="graphics/header.png"></img></a>
   </div>
   <div class="Title">Writing Device Drivers</div>
</div>

<table class="Layout" border="0" cellspacing="0" width="100%">
<tbody>

   <tr valign="top" class="PageControls">
      <td></td>
      <td>
         <table width="100%">
      	   <tr>
      	     <td>
                 <a href="dma-7.html">Previous</a>
             </td>
             <td align="right">
                 <a href="dma-6.html">Next</a>
             </td>
           </tr>
         </table>
      </td>
   </tr>
   
   <tr valign="top">
      <td class="Navigation" width="200px"><p class="toc level1"><a href="docinfo.html">Document Information</a></p>
<p class="toc level1 tocsp"><a href="preface-1.html">Preface</a></p>
<p class="toc level1 tocsp"><a href="eqbvu.html">Part&nbsp;I&nbsp;Designing Device Drivers for the Solaris Platform</a></p>
<p class="toc level2"><a href="eqbqn.html">1.&nbsp;&nbsp;Overview of Solaris Device Drivers</a></p>
<p class="toc level2"><a href="kernelovr-77198.html">2.&nbsp;&nbsp;Solaris Kernel and Device Tree</a></p>
<p class="toc level2"><a href="mt-17026.html">3.&nbsp;&nbsp;Multithreading</a></p>
<p class="toc level2"><a href="properties-1.html">4.&nbsp;&nbsp;Properties</a></p>
<p class="toc level2"><a href="events-1.html">5.&nbsp;&nbsp;Managing Events and Queueing Tasks</a></p>
<p class="toc level2"><a href="autoconf-17.html">6.&nbsp;&nbsp;Driver Autoconfiguration</a></p>
<p class="toc level2"><a href="devaccess-3.html">7.&nbsp;&nbsp;Device Access: Programmed I/O</a></p>
<p class="toc level2"><a href="interrupt-15678.html">8.&nbsp;&nbsp;Interrupt Handlers</a></p>
<p class="toc level2"><a href="dma-29901.html">9.&nbsp;&nbsp;Direct Memory Access (DMA)</a></p>
<p class="toc level3"><a href="dma-1.html">DMA Model</a></p>
<p class="toc level3"><a href="dma-2.html">Types of Device DMA</a></p>
<p class="toc level3"><a href="dma-6a.html">Types of Host Platform DMA</a></p>
<p class="toc level3"><a href="dma-7.html">DMA Software Components:  Handles, Windows, and Cookies</a></p>
<div class="onpage">
<p class="toc level3"><a href="">DMA Operations</a></p>
</div>
<p class="toc level3"><a href="dma-6.html">Managing DMA Resources</a></p>
<p class="toc level3"><a href="dma-35348.html">DMA Windows</a></p>
<p class="toc level2 tocsp"><a href="devmap-24338.html">10.&nbsp;&nbsp;Mapping Device and Kernel Memory</a></p>
<p class="toc level2"><a href="devcnmgt-19679.html">11.&nbsp;&nbsp;Device Context Management</a></p>
<p class="toc level2"><a href="powermgt-37437.html">12.&nbsp;&nbsp;Power Management</a></p>
<p class="toc level2"><a href="gevsi.html">13.&nbsp;&nbsp;Hardening Solaris Drivers</a></p>
<p class="toc level2"><a href="ldi-1.html">14.&nbsp;&nbsp;Layered Driver Interface (LDI)</a></p>
<p class="toc level1 tocsp"><a href="eqbvb.html">Part&nbsp;II&nbsp;Designing Specific Kinds of Device Drivers</a></p>
<p class="toc level2"><a href="character-21002.html">15.&nbsp;&nbsp;Drivers for Character Devices</a></p>
<p class="toc level2"><a href="block-34861.html">16.&nbsp;&nbsp;Drivers for Block Devices</a></p>
<p class="toc level2"><a href="scsi-36812.html">17.&nbsp;&nbsp;SCSI Target Drivers</a></p>
<p class="toc level2"><a href="scsihba-32898.html">18.&nbsp;&nbsp;SCSI Host Bus Adapter Drivers</a></p>
<p class="toc level2"><a href="gld-1.html">19.&nbsp;&nbsp;Drivers for Network Devices</a></p>
<p class="toc level2"><a href="usb-1.html">20.&nbsp;&nbsp;USB Drivers</a></p>
<p class="toc level1 tocsp"><a href="eqbvo.html">Part&nbsp;III&nbsp;Building a Device Driver</a></p>
<p class="toc level2"><a href="loading-15035.html">21.&nbsp;&nbsp;Compiling, Loading, Packaging, and Testing Drivers</a></p>
<p class="toc level2"><a href="debug-60.html">22.&nbsp;&nbsp;Debugging, Testing, and Tuning Device Drivers</a></p>
<p class="toc level2"><a href="coding-practices.html">23.&nbsp;&nbsp;Recommended Coding Practices</a></p>
<p class="toc level1 tocsp"><a href="eqbva.html">Part&nbsp;IV&nbsp;Appendixes</a></p>
<p class="toc level2"><a href="hwovr-18191.html">A.&nbsp;&nbsp;Hardware Overview</a></p>
<p class="toc level2"><a href="ddidkisvc-29227.html">B.&nbsp;&nbsp;Summary of Solaris DDI/DKI Services</a></p>
<p class="toc level2"><a href="lp64-35004.html">C.&nbsp;&nbsp;Making a Device Driver 64-Bit Ready</a></p>
<p class="toc level2"><a href="euazz.html">D.&nbsp;&nbsp;Console Frame Buffer Drivers</a></p>
<p class="toc level1 tocsp"><a href="idx-1.html">Index</a></p>
</td>
      <td class="ContentPane" width="705px">

	 <div class="MainContent">      	 
             

<a name="dma-36180"></a><h3>DMA Operations</h3>
<a name="dma-ix310"></a><p><a name="dma-ix311"></a>The steps in a DMA transfer are similar among the types of
DMA. The following sections present methods for performing DMA transfers.</p>
<hr><p><b>Note - </b>You do not need to ensure that the DMA object is locked
in memory in block drivers for buffers that come from the file system.
The file system has already locked the data in memory.</p>
<hr>


<a name="dma-9"></a><h4>Performing Bus-Master DMA Transfers</h4>
<p><a name="dma-ix312"></a>The driver should perform the following steps for bus-master DMA.</p>
<ol><li><p>Describe the DMA attributes. This step enables the routines to ensure that the device is able to access the buffer.</p></li>
<li><p>Allocate a DMA handle.</p></li>
<li><p>Ensure that the DMA object is locked in memory. See the <a href="http://docs.sun.com/doc/819-2256/physio-9f?a=view"><tt>physio</tt>(9F)</a> or <a href="http://docs.sun.com/doc/819-2256/ddi-umem-lock-9f?a=view"><tt>ddi_umem_lock</tt>(9F)</a> man page.</p></li>
<li><p>Allocate DMA resources for the object.</p></li>
<li><p>Program the DMA engine on the device.</p></li>
<li><p>Start the engine.</p></li>
<li><p>When the transfer is complete, continue the bus master operation.</p></li>
<li><p>Perform any required object synchronizations.</p></li>
<li><p>Release the DMA resources.</p></li>
<li><p>Free the DMA handle.</p></li></ol>


<a name="dma-10"></a><h4>Performing First-Party DMA Transfers</h4>
<p><a name="dma-ix313"></a>The driver should perform the following steps for first-party DMA.</p>
<ol><li><p>Allocate a DMA channel.</p></li>
<li><p>Use <a href="http://docs.sun.com/doc/819-2256/ddi-dmae-1stparty-9f?a=view"><tt>ddi_dmae_1stparty</tt>(9F)</a> to configure the channel.</p></li>
<li><p>Ensure that the DMA object is locked in memory. See the <a href="http://docs.sun.com/doc/819-2256/physio-9f?a=view"><tt>physio</tt>(9F)</a> or <a href="http://docs.sun.com/doc/819-2256/ddi-umem-lock-9f?a=view"><tt>ddi_umem_lock</tt>(9F)</a> man page.</p></li>
<li><p>Allocate DMA resources for the object.</p></li>
<li><p>Program the DMA engine on the device.</p></li>
<li><p>Start the engine.</p></li>
<li><p>When the transfer is complete, continue the bus-master operation.</p></li>
<li><p>Perform any required object synchronizations.</p></li>
<li><p>Release the DMA resources.</p></li>
<li><p>Deallocate the DMA channel.</p></li></ol>


<a name="dma-11"></a><h4>Performing Third-Party DMA Transfers</h4>
<p><a name="dma-ix314"></a>The driver should perform these steps for third-party DMA.</p>
<ol><li><p>Allocate a DMA channel.</p></li>
<li><p>Retrieve the system's DMA engine attributes with <a href="http://docs.sun.com/doc/819-2256/ddi-dmae-getattr-9f?a=view"><tt>ddi_dmae_getattr</tt>(9F)</a>.</p></li>
<li><p>Lock the DMA object in memory. See the <a href="http://docs.sun.com/doc/819-2256/physio-9f?a=view"><tt>physio</tt>(9F)</a> or <a href="http://docs.sun.com/doc/819-2256/ddi-umem-lock-9f?a=view"><tt>ddi_umem_lock</tt>(9F)</a> man page.</p></li>
<li><p>Allocate DMA resources for the object.</p></li>
<li><p>Use <a href="http://docs.sun.com/doc/819-2256/ddi-dmae-prog-9f?a=view"><tt>ddi_dmae_prog</tt>(9F)</a> to program the system DMA engine to perform the transfer.</p></li>
<li><p>Perform any required object synchronizations.</p></li>
<li><p>Use <a href="http://docs.sun.com/doc/819-2256/ddi-dmae-stop-9f?a=view"><tt>ddi_dmae_stop</tt>(9F)</a> to stop the DMA engine.</p></li>
<li><p>Release the DMA resources.</p></li>
<li><p>Deallocate the DMA channel.</p></li></ol>
<p>Certain hardware platforms restrict DMA capabilities in a bus-specific way. Drivers should use
 <a href="http://docs.sun.com/doc/819-2256/ddi-slaveonly-9f?a=view"><tt>ddi_slaveonly</tt>(9F)</a> to determine whether the device is in a slot in
which DMA is possible.</p>

<a name="dma-39813"></a><h4>DMA Attributes</h4>
<p><a name="dma-ix315"></a>DMA attributes describe the attributes and limits of a DMA engine, which include:</p>
<ul><li><p>Limits on addresses that the device can access</p></li>
<li><p>Maximum transfer count</p></li>
<li><p>Address alignment restrictions</p></li></ul>
<p>A device driver must inform the system about any DMA engine limitations through
the <a href="http://docs.sun.com/doc/819-2257/ddi-dma-attr-9s?a=view"><tt>ddi_dma_attr</tt>(9S)</a> structure. This action ensures that DMA resources that are allocated by
the system can be accessed by the device's DMA engine.  The system
can impose additional restrictions on the device attributes, but the system never removes
any of the driver-supplied restrictions.</p>

<a name="dma-12"></a><h5><tt>ddi_dma_attr</tt> Structure</h5>
<p><a name="indexterm-194"></a>The DMA attribute structure has the following members:</p><pre>typedef struct ddi_dma_attr {
    uint_t      dma_attr_version;       /* version number */
    uint64_t    dma_attr_addr_lo;       /* low DMA address range */
    uint64_t    dma_attr_addr_hi;       /* high DMA address range */
    uint64_t    dma_attr_count_max;     /* DMA counter register */
    uint64_t    dma_attr_align;         /* DMA address alignment */
    uint_t      dma_attr_burstsizes;    /* DMA burstsizes */
    uint32_t    dma_attr_minxfer;       /* min effective DMA size */
    uint64_t    dma_attr_maxxfer;       /* max DMA xfer size */
    uint64_t    dma_attr_seg;           /* segment boundary */
    int         dma_attr_sgllen;        /* s/g length */
    uint32_t    dma_attr_granular;      /* granularity of device */
    uint_t      dma_attr_flags;         /* Bus specific DMA flags */
} ddi_dma_attr_t;</pre><p>where:</p><dl><dt><tt>dma_attr_version</tt></dt>
<dd><p>Version number of the attribute structure. <tt>dma_attr_version</tt> should be set to DMA_ATTR_V0.</p></dd>
<dt><tt>dma_attr_addr_lo</tt></dt>
<dd><p>Lowest bus address that the DMA engine can access.</p></dd>
<dt><tt>dma_attr_addr_hi</tt></dt>
<dd><p>Highest bus address that the DMA engine can access.</p></dd>
<dt><tt>dma_attr_count_max</tt></dt>
<dd><p>Specifies the maximum transfer count that the DMA engine can handle in one cookie. The limit is expressed as the maximum count minus one. This count is used as a bit mask, so the count must also be one less than a power of two.</p></dd>
<dt><tt>dma_attr_align</tt></dt>
<dd><p>Specifies alignment requirements when allocating memory from <a href="http://docs.sun.com/doc/819-2256/ddi-dma-mem-alloc-9f?a=view"><tt>ddi_dma_mem_alloc</tt>(9F)</a>. An example of an alignment requirement is alignment on a page boundary. The <tt>dma_attr_align</tt> field is used only when allocating memory. This field is ignored during bind operations. For bind operations, the driver must ensure that the buffer is aligned appropriately.</p></dd>
<dt><tt>dma_attr_burstsizes</tt></dt>
<dd><p>Specifies the <b>burst sizes</b> that the device supports. A burst size is the amount of data the device can transfer before relinquishing the bus. This member is a binary encoding of burst sizes, which are assumed to be powers of two. For example, if the device is capable of doing 1-byte, 2-byte, 4-byte, and 16-byte bursts, this field should be set to 0x17. The system also uses this field to determine alignment restrictions.</p></dd>
<dt><tt>dma_attr_minxfer</tt></dt>
<dd><p>Minimum effective transfer size that the device can perform. This size also influences restrictions on alignment and on padding.</p></dd>
<dt><tt>dma_attr_maxxfer</tt></dt>
<dd><p>Describes the maximum number of bytes that the DMA engine can accommodate in one I/O command. This limitation is only significant if <tt>dma_attr_maxxfer</tt> is less than <tt>(dma_attr_count_max + 1) * dma_attr_sgllen</tt>.</p></dd>
<dt><tt>dma_attr_seg</tt></dt>
<dd><p>Upper bound of the DMA engine's address register. <tt>dma_attr_seg</tt> is often used where the upper 8 bits of an address register are a latch that contains a segment number. The lower 24 bits are used to address a segment. In this case, <tt>dma_attr_seg</tt> would be set to 0xFFFFFF, which prevents the system from crossing a 24-bit segment boundary when allocating resources for the object.</p></dd>
<dt><tt>dma_attr_sgllen</tt></dt>
<dd><p>Specifies the maximum number of entries in the scatter-gather list. <tt>dma_attr_sgllen</tt> is the number of cookies that the DMA engine can consume in one I/O request to the device. If the DMA engine has no scatter-gather list, this field should be set to 1.</p></dd>
<dt><tt>dma_attr_granular</tt></dt>
<dd><p>This field gives the granularity in bytes of the DMA transfer ability of the device. An example of how this value is used is to specify the sector size of a mass storage device. When a bind operation requires a partial mapping, this field is used to ensure that the sum of the sizes of the cookies in a DMA window is a whole multiple of granularity. However, if the device does not have a scatter-gather capability, it is impossible for the DDI to ensure the granularity. For this case, the value of the <tt>dma_attr_granular</tt> field should be 1.</p></dd>
<dt><tt>dma_attr_flags</tt></dt>
<dd><p>This field can be set to <tt>DDI_DMA_FORCE_PHYSICAL</tt>, which indicates that the system should return physical rather than virtual I/O addresses if the system supports both. If the system does not support physical DMA, the return value from <tt>ddi_dma_alloc_handle(9F)</tt> is <tt>DDI_DMA_BADATTR</tt>. In this case, the driver has to clear <tt>DDI_DMA_FORCE_PHYSICAL</tt> and retry the operation.</p></dd>
</dl>


<a name="dma-13"></a><h5>SBus Example</h5>
<p>A DMA engine on an SBus in a SPARC machine has the
following attributes:</p>
<ul><li><p>Access to addresses ranging from 0xFF000000 to 0xFFFFFFFF only </p></li>
<li><p>32-bit DMA counter register</p></li>
<li><p>Ability to handle byte-aligned transfers</p></li>
<li><p>Support for 1-byte, 2-byte, and 4-byte burst sizes</p></li>
<li><p>Minimum effective transfer size of 1 byte</p></li>
<li><p>32-bit address register</p></li>
<li><p>No scatter-gather list</p></li>
<li><p>Operation on sectors only, for example, a disk</p></li></ul>
<p>A DMA engine on an SBus in a SPARC machine has the
following attribute structure:</p><pre>static ddi_dma_attr_t attributes = {
    DMA_ATTR_V0,   /* Version number */
    0xFF000000,    /* low address */
    0xFFFFFFFF,    /* high address */
    0xFFFFFFFF,    /* counter register max */
    1,             /* byte alignment */
    0x7,           /* burst sizes: 0x1 | 0x2 | 0x4 */
    0x1,           /* minimum transfer size */
    0xFFFFFFFF,    /* max transfer size */
    0xFFFFFFFF,    /* address register max */
    1,             /* no scatter-gather */
    512,           /* device operates on sectors */
    0,             /* attr flag: set to 0 */
};</pre>

<a name="dma-15"></a><h5>ISA Bus Example</h5>
<p>A DMA engine on an ISA bus in an x86 machine has
the following attributes:</p>
<ul><li><p>Access to the first 16 megabytes of memory only</p></li>
<li><p>Inability to cross a 1-megabyte boundary in a single DMA transfer</p></li>
<li><p>16-bit counter register</p></li>
<li><p>Ability to handle byte-aligned transfers</p></li>
<li><p>Support for 1-byte, 2-byte, and 4-byte burst sizes</p></li>
<li><p>Minimum effective transfer size of 1 byte</p></li>
<li><p>Ability to hold up to 17 scatter-gather transfers</p></li>
<li><p>Operation on sectors only, for example, a disk</p></li></ul>
<p>A DMA engine on an ISA bus in an x86 machine has
the following attribute structure:</p><pre>static ddi_dma_attr_t attributes = {
    DMA_ATTR_V0,   /* Version number */
    0x00000000,    /* low address */
    0x00FFFFFF,    /* high address */
    0xFFFF,        /* counter register max */
    1,             /* byte alignment */
    0x7,           /* burst sizes */
    0x1,           /* minimum transfer size */
    0xFFFFFFFF,    /* max transfer size */
    0x000FFFFF,    /* address register max */
    17,            /* scatter-gather */
    512,           /* device operates on sectors */
    0,             /* attr flag: set to 0 */
};</pre>
         </div>
      </td>
   </tr>

   <tr class="PageControls" valign="top">
      <td></td>
      <td>
         <table width="100%">
      	   <tr>
      	     <td>
                 <a href="dma-7.html">Previous</a>
             </td>
             <td align="right">
                 <a href="dma-6.html">Next</a>
             </td>
           </tr>
         </table>
      </td>
   </tr>
</tbody>
</table>


</body>
</html>

