<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="en-US">
<head>
<meta http-equiv="Content-type" content="text/html; charset=iso-8859-1">
<title>Asynchronous Data Transfers (Block Drivers) - Writing Device Drivers</title>
<meta name="robots" content="index,follow">
<meta name="robots" content="index,follow">
<meta name="date" content="2008-08-01">
<meta name="collection" content="reference">
<link rel="stylesheet" type="text/css" href="css/elements.css">
<link rel="stylesheet" type="text/css" href="css/indiana.css">
</head>

<body>


<div class="Masthead">
   <div class="MastheadLogo">
      <a href="http://www.opensolaris.org"><img border="0" src="graphics/header.png"></img></a>
   </div>
   <div class="Title">Writing Device Drivers</div>
</div>

<table class="Layout" border="0" cellspacing="0" width="100%">
<tbody>

   <tr valign="top" class="PageControls">
      <td></td>
      <td>
         <table width="100%">
      	   <tr>
      	     <td>
                 <a href="block-78892.html">Previous</a>
             </td>
             <td align="right">
                 <a href="block-25.html">Next</a>
             </td>
           </tr>
         </table>
      </td>
   </tr>
   
   <tr valign="top">
      <td class="Navigation" width="200px"><p class="toc level1"><a href="docinfo.html">Document Information</a></p>
<p class="toc level1 tocsp"><a href="preface-1.html">Preface</a></p>
<p class="toc level1 tocsp"><a href="eqbvu.html">Part&nbsp;I&nbsp;Designing Device Drivers for the Solaris Platform</a></p>
<p class="toc level2"><a href="eqbqn.html">1.&nbsp;&nbsp;Overview of Solaris Device Drivers</a></p>
<p class="toc level2"><a href="kernelovr-77198.html">2.&nbsp;&nbsp;Solaris Kernel and Device Tree</a></p>
<p class="toc level2"><a href="mt-17026.html">3.&nbsp;&nbsp;Multithreading</a></p>
<p class="toc level2"><a href="properties-1.html">4.&nbsp;&nbsp;Properties</a></p>
<p class="toc level2"><a href="events-1.html">5.&nbsp;&nbsp;Managing Events and Queueing Tasks</a></p>
<p class="toc level2"><a href="autoconf-17.html">6.&nbsp;&nbsp;Driver Autoconfiguration</a></p>
<p class="toc level2"><a href="devaccess-3.html">7.&nbsp;&nbsp;Device Access: Programmed I/O</a></p>
<p class="toc level2"><a href="interrupt-15678.html">8.&nbsp;&nbsp;Interrupt Handlers</a></p>
<p class="toc level2"><a href="dma-29901.html">9.&nbsp;&nbsp;Direct Memory Access (DMA)</a></p>
<p class="toc level2"><a href="devmap-24338.html">10.&nbsp;&nbsp;Mapping Device and Kernel Memory</a></p>
<p class="toc level2"><a href="devcnmgt-19679.html">11.&nbsp;&nbsp;Device Context Management</a></p>
<p class="toc level2"><a href="powermgt-37437.html">12.&nbsp;&nbsp;Power Management</a></p>
<p class="toc level2"><a href="gevsi.html">13.&nbsp;&nbsp;Hardening Solaris Drivers</a></p>
<p class="toc level2"><a href="ldi-1.html">14.&nbsp;&nbsp;Layered Driver Interface (LDI)</a></p>
<p class="toc level1 tocsp"><a href="eqbvb.html">Part&nbsp;II&nbsp;Designing Specific Kinds of Device Drivers</a></p>
<p class="toc level2"><a href="character-21002.html">15.&nbsp;&nbsp;Drivers for Character Devices</a></p>
<p class="toc level2"><a href="block-34861.html">16.&nbsp;&nbsp;Drivers for Block Devices</a></p>
<p class="toc level3"><a href="block-1.html">Block Driver Structure Overview</a></p>
<p class="toc level3"><a href="block-82249.html">File I/O</a></p>
<p class="toc level3"><a href="block-5.html">Block Device Autoconfiguration</a></p>
<p class="toc level3"><a href="block-6.html">Controlling Device Access</a></p>
<p class="toc level3"><a href="block-78892.html">Synchronous Data Transfers (Block Drivers)</a></p>
<div class="onpage">
<p class="toc level3"><a href="">Asynchronous Data Transfers (Block Drivers)</a></p>
</div>
<p class="toc level3"><a href="block-25.html"><tt>dump()</tt> and <tt>print()</tt> Entry Points</a></p>
<p class="toc level3"><a href="advanced-7.html">Disk Device Drivers</a></p>
<p class="toc level2 tocsp"><a href="scsi-36812.html">17.&nbsp;&nbsp;SCSI Target Drivers</a></p>
<p class="toc level2"><a href="scsihba-32898.html">18.&nbsp;&nbsp;SCSI Host Bus Adapter Drivers</a></p>
<p class="toc level2"><a href="gld-1.html">19.&nbsp;&nbsp;Drivers for Network Devices</a></p>
<p class="toc level2"><a href="usb-1.html">20.&nbsp;&nbsp;USB Drivers</a></p>
<p class="toc level1 tocsp"><a href="eqbvo.html">Part&nbsp;III&nbsp;Building a Device Driver</a></p>
<p class="toc level2"><a href="loading-15035.html">21.&nbsp;&nbsp;Compiling, Loading, Packaging, and Testing Drivers</a></p>
<p class="toc level2"><a href="debug-60.html">22.&nbsp;&nbsp;Debugging, Testing, and Tuning Device Drivers</a></p>
<p class="toc level2"><a href="coding-practices.html">23.&nbsp;&nbsp;Recommended Coding Practices</a></p>
<p class="toc level1 tocsp"><a href="eqbva.html">Part&nbsp;IV&nbsp;Appendixes</a></p>
<p class="toc level2"><a href="hwovr-18191.html">A.&nbsp;&nbsp;Hardware Overview</a></p>
<p class="toc level2"><a href="ddidkisvc-29227.html">B.&nbsp;&nbsp;Summary of Solaris DDI/DKI Services</a></p>
<p class="toc level2"><a href="lp64-35004.html">C.&nbsp;&nbsp;Making a Device Driver 64-Bit Ready</a></p>
<p class="toc level2"><a href="euazz.html">D.&nbsp;&nbsp;Console Frame Buffer Drivers</a></p>
<p class="toc level1 tocsp"><a href="idx-1.html">Index</a></p>
</td>
      <td class="ContentPane" width="705px">

	 <div class="MainContent">      	 
             

<a name="block-54698"></a><h3>Asynchronous Data Transfers (Block Drivers)</h3>
<p><a name="block-ix439"></a><a name="indexterm-588"></a>This section presents a method for performing asynchronous I/O transfers. The driver queues the
I/O requests and then returns control to the caller. Again, the assumption is
that the hardware is a simple disk device that allows one transfer
at a time. The device interrupts when a data transfer has completed. An
interrupt also takes place if an error occurs. The basic steps for performing
asynchronous data transfers are:</p>
<ol><li><p>Check for invalid <a href="http://docs.sun.com/doc/819-2257/buf-9s?a=view"><tt>buf</tt>(9S)</a> requests.</p></li>
<li><p>Enqueue the request.</p></li>
<li><p>Start the first transfer.</p></li>
<li><p>Handle the interrupting device.</p></li></ol>


<a name="fblew"></a><h4>Checking for Invalid <tt>buf</tt> Requests</h4>
<p>As in the synchronous case, the device driver should check the <a href="http://docs.sun.com/doc/819-2257/buf-9s?a=view"><tt>buf</tt>(9S)</a>
structure passed to  <a href="http://docs.sun.com/doc/819-2255/strategy-9e?a=view"><tt>strategy</tt>(9E)</a> for validity. See <a href="block-78892.html">Synchronous Data Transfers (Block Drivers)</a> for more details.</p>

<a name="fbleu"></a><h4>Enqueuing the Request</h4>
<p>Unlike synchronous data transfers, a driver does not wait for an asynchronous request
to complete. Instead, the driver adds the request to a queue. The head
of the queue can be the current transfer. The head of the
queue can also be a separate field in the state structure for holding
the active request, as in <a href="#fblfb">Example&nbsp;16-5</a>.</p><p>If the queue is initially empty, then the hardware is not busy
and <a href="http://docs.sun.com/doc/819-2255/strategy-9e?a=view"><tt>strategy</tt>(9E)</a> starts the transfer before returning. Otherwise, if a transfer completes with
a non-empty queue, the interrupt routine begins a new transfer.  <a href="#fblfb">Example&nbsp;16-5</a> places
the decision of whether to start a new transfer into a separate routine
for convenience.</p><p>The driver can use the <tt>av_forw</tt> and the <tt>av_back</tt> members of the
<a href="http://docs.sun.com/doc/819-2257/buf-9s?a=view"><tt>buf</tt>(9S)</a> structure to manage a list of transfer requests. A single pointer can
be used to manage a singly linked list, or both pointers can be
used together to build a doubly linked list. The device hardware specification specifies
which type of list management, such as insertion policies, is used to optimize
the performance of the device. The transfer list is a per-device list, so
the head and tail of the list are stored in the state
structure.</p><p>The following example provides multiple threads with access to the driver shared data,
such as the transfer list. You must identify the shared data and must
protect the data with a mutex. See <a href="mt-17026.html">Chapter&nbsp;3, Multithreading</a> for more details about
mutex locks.</p><a name="fblfb"></a><h6>Example&nbsp;16-5 Enqueuing Data Transfer Requests for Block Drivers</h6><pre>static int
xxstrategy(struct buf *bp)
{
    struct xxstate *xsp;
    minor_t instance;
    instance = getminor(bp-&gt;b_edev);
    xsp = ddi_get_soft_state(statep, instance);
    /* ... */
    /* validate transfer request */
    /* ... */
    /*
     * Add the request to the end of the queue. Depending on the device, a sorting
     * algorithm, such as disksort(9F) can be used if it improves the
     * performance of the device.
     */
    mutex_enter(&amp;xsp-&gt;mu);
    bp-&gt;av_forw = NULL;
    if (xsp-&gt;list_head) {
        /* Non-empty transfer list */
        xsp-&gt;list_tail-&gt;av_forw = bp;
        xsp-&gt;list_tail = bp;
    } else {
        /* Empty Transfer list */
        xsp-&gt;list_head = bp;
        xsp-&gt;list_tail = bp;
    }
    mutex_exit(&amp;xsp-&gt;mu);
    /* Start the transfer if possible */
    (void) xxstart((caddr_t)xsp);
    return (0);
}</pre>

<a name="fblev"></a><h4>Starting the First Transfer</h4>
<p>Device drivers that implement queuing usually have a <tt>start()</tt> routine. <tt>start()</tt> dequeues
the next request and starts the data transfer to or from the device.
In this example, <tt>start()</tt> processes all requests regardless of the state of the
device, whether busy or free.</p>
<hr><p><b>Note - </b><tt>start()</tt> must be written to be called from any context. <tt>start()</tt> can be
called by both the strategy routine in kernel context and the interrupt routine
in interrupt context.</p>
<hr>
<p><tt>start()</tt> is called by <a href="http://docs.sun.com/doc/819-2255/strategy-9e?a=view"><tt>strategy</tt>(9E)</a> every time <tt>strategy()</tt> queues a request so that
an idle device can be started. If the device is busy, <tt>start()</tt>
returns immediately.</p><p><tt>start()</tt> is also called by the interrupt handler before the handler returns from
a claimed interrupt so that a nonempty queue can be serviced. If the
queue is empty, <tt>start()</tt> returns immediately.</p><p>Because <tt>start()</tt> is a private driver routine, <tt>start()</tt> can take any arguments
and can return any type. The following code sample is written to be
used as a DMA callback, although that portion is not shown. Accordingly, the
example must take a <tt>caddr_t</tt> as an argument and return an <tt>int</tt>. See
<a href="dma-6.html#dma-200">Handling Resource Allocation Failures</a> for more information about DMA callback routines.</p><a name="fblfa"></a><h6>Example&nbsp;16-6 Starting the First Data Request for a Block Driver</h6><pre>static int
xxstart(caddr_t arg)
{
    struct xxstate *xsp = (struct xxstate *)arg;
    struct buf *bp;

    mutex_enter(&amp;xsp-&gt;mu);
    /*
     * If there is nothing more to do, or the device is
     * busy, return.
     */
    if (xsp-&gt;list_head == NULL || xsp-&gt;busy) {
       mutex_exit(&amp;xsp-&gt;mu);
       return (0);
    }
    xsp-&gt;busy = 1;
    /* Get the first buffer off the transfer list */
    bp = xsp-&gt;list_head;
    /* Update the head and tail pointer */
    xsp-&gt;list_head = xsp-&gt;list_head-&gt;av_forw;
    if (xsp-&gt;list_head == NULL)
       xsp-&gt;list_tail = NULL;
    bp-&gt;av_forw = NULL;
    mutex_exit(&amp;xsp-&gt;mu);
    /* 
     * If the device has power manageable components, 
     * mark the device busy with pm_busy_components(9F),
     * and then ensure that the device 
     * is powered up by calling pm_raise_power(9F).
     *
     * Set up DMA resources with ddi_dma_alloc_handle(9F) and
     * ddi_dma_buf_bind_handle(9F).
     */
    xsp-&gt;bp = bp;
    ddi_put32(xsp-&gt;data_access_handle, &amp;xsp-&gt;regp-&gt;dma_addr,
        cookie.dmac_address);
    ddi_put32(xsp-&gt;data_access_handle, &amp;xsp-&gt;regp-&gt;dma_size,
        (uint32_t)cookie.dmac_size);
    ddi_put8(xsp-&gt;data_access_handle, &amp;xsp-&gt;regp-&gt;csr,
        ENABLE_INTERRUPTS | START_TRANSFER);
    return (0);
}</pre>

<a name="fbles"></a><h4>Handling the Interrupting Device</h4>
<p>The interrupt routine is similar to the asynchronous version, with the addition of
the call to <tt>start()</tt> and the removal of the call to <a href="http://docs.sun.com/doc/819-2256/cv-signal-9f?a=view"><tt>cv_signal</tt>(9F)</a>.</p><a name="block-33565"></a><h6>Example&nbsp;16-7 Block Driver Routine for Asynchronous Interrupts</h6><pre>static u_int
xxintr(caddr_t arg)
{
    struct xxstate *xsp = (struct xxstate *)arg;
    struct buf *bp;
    uint8_t status;
    mutex_enter(&amp;xsp-&gt;mu);
    status = ddi_get8(xsp-&gt;data_access_handle, &amp;xsp-&gt;regp-&gt;csr);
    if (!(status &amp; INTERRUPTING)) {
        mutex_exit(&amp;xsp-&gt;mu);
        return (DDI_INTR_UNCLAIMED);
    }
    /* Get the buf responsible for this interrupt */
    bp = xsp-&gt;bp;
    xsp-&gt;bp = NULL;
    /*
     * This example is for a simple device which either
     * succeeds or fails the data transfer, indicated in the
     * command/status register.
     */
    if (status &amp; DEVICE_ERROR) {
        /* failure */
        bp-&gt;b_resid = bp-&gt;b_bcount;
        bioerror(bp, EIO);
    } else {
        /* success */
        bp-&gt;b_resid = 0;
    }
    ddi_put8(xsp-&gt;data_access_handle, &amp;xsp-&gt;regp-&gt;csr,
        CLEAR_INTERRUPT);
    /* The transfer has finished, successfully or not */
    biodone(bp);
    /*
     * If the device has power manageable components that were
     * marked busy in strategy(9F), mark them idle now with
     * pm_idle_component(9F)
     * Release any resources used in the transfer, such as DMA
     * resources (ddi_dma_unbind_handle(9F) and
     * ddi_dma_free_handle(9F)).
     *
     * Let the next I/O thread have access to the device.
     */
    xsp-&gt;busy = 0;
    mutex_exit(&amp;xsp-&gt;mu);
    (void) xxstart((caddr_t)xsp);
    return (DDI_INTR_CLAIMED);
}</pre>
         </div>
      </td>
   </tr>

   <tr class="PageControls" valign="top">
      <td></td>
      <td>
         <table width="100%">
      	   <tr>
      	     <td>
                 <a href="block-78892.html">Previous</a>
             </td>
             <td align="right">
                 <a href="block-25.html">Next</a>
             </td>
           </tr>
         </table>
      </td>
   </tr>
</tbody>
</table>


</body>
</html>

