<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="en-US">
<head>
<meta http-equiv="Content-type" content="text/html; charset=iso-8859-1">
<title>32-bit and 64-bit Data Structure Macros - Writing Device Drivers</title>
<meta name="robots" content="index,follow">
<meta name="robots" content="index,follow">
<meta name="date" content="2008-08-01">
<meta name="collection" content="reference">
<link rel="stylesheet" type="text/css" href="css/elements.css">
<link rel="stylesheet" type="text/css" href="css/indiana.css">
</head>

<body>


<div class="Masthead">
   <div class="MastheadLogo">
      <a href="http://www.opensolaris.org"><img border="0" src="graphics/header.png"></img></a>
   </div>
   <div class="Title">Writing Device Drivers</div>
</div>

<table class="Layout" border="0" cellspacing="0" width="100%">
<tbody>

   <tr valign="top" class="PageControls">
      <td></td>
      <td>
         <table width="100%">
      	   <tr>
      	     <td>
                 <a href="character-23939.html">Previous</a>
             </td>
             <td align="right">
                 <a href="block-34861.html">Next</a>
             </td>
           </tr>
         </table>
      </td>
   </tr>
   
   <tr valign="top">
      <td class="Navigation" width="200px"><p class="toc level1"><a href="docinfo.html">Document Information</a></p>
<p class="toc level1 tocsp"><a href="preface-1.html">Preface</a></p>
<p class="toc level1 tocsp"><a href="eqbvu.html">Part&nbsp;I&nbsp;Designing Device Drivers for the Solaris Platform</a></p>
<p class="toc level2"><a href="eqbqn.html">1.&nbsp;&nbsp;Overview of Solaris Device Drivers</a></p>
<p class="toc level2"><a href="kernelovr-77198.html">2.&nbsp;&nbsp;Solaris Kernel and Device Tree</a></p>
<p class="toc level2"><a href="mt-17026.html">3.&nbsp;&nbsp;Multithreading</a></p>
<p class="toc level2"><a href="properties-1.html">4.&nbsp;&nbsp;Properties</a></p>
<p class="toc level2"><a href="events-1.html">5.&nbsp;&nbsp;Managing Events and Queueing Tasks</a></p>
<p class="toc level2"><a href="autoconf-17.html">6.&nbsp;&nbsp;Driver Autoconfiguration</a></p>
<p class="toc level2"><a href="devaccess-3.html">7.&nbsp;&nbsp;Device Access: Programmed I/O</a></p>
<p class="toc level2"><a href="interrupt-15678.html">8.&nbsp;&nbsp;Interrupt Handlers</a></p>
<p class="toc level2"><a href="dma-29901.html">9.&nbsp;&nbsp;Direct Memory Access (DMA)</a></p>
<p class="toc level2"><a href="devmap-24338.html">10.&nbsp;&nbsp;Mapping Device and Kernel Memory</a></p>
<p class="toc level2"><a href="devcnmgt-19679.html">11.&nbsp;&nbsp;Device Context Management</a></p>
<p class="toc level2"><a href="powermgt-37437.html">12.&nbsp;&nbsp;Power Management</a></p>
<p class="toc level2"><a href="gevsi.html">13.&nbsp;&nbsp;Hardening Solaris Drivers</a></p>
<p class="toc level2"><a href="ldi-1.html">14.&nbsp;&nbsp;Layered Driver Interface (LDI)</a></p>
<p class="toc level1 tocsp"><a href="eqbvb.html">Part&nbsp;II&nbsp;Designing Specific Kinds of Device Drivers</a></p>
<p class="toc level2"><a href="character-21002.html">15.&nbsp;&nbsp;Drivers for Character Devices</a></p>
<p class="toc level3"><a href="character-1.html">Overview of the Character Driver Structure</a></p>
<p class="toc level3"><a href="character-51.html">Character Device Autoconfiguration</a></p>
<p class="toc level3"><a href="character-6.html">Device Access (Character Drivers)</a></p>
<p class="toc level3"><a href="character-25379.html">I/O Request Handling</a></p>
<p class="toc level3"><a href="character-16543.html">Mapping Device Memory</a></p>
<p class="toc level3"><a href="character-11313.html">Multiplexing I/O on File Descriptors</a></p>
<p class="toc level3"><a href="character-23939.html">Miscellaneous I/O Control</a></p>
<div class="onpage">
<p class="toc level3"><a href="">32-bit and 64-bit Data Structure Macros</a></p>
</div>
<p class="toc level2 tocsp"><a href="block-34861.html">16.&nbsp;&nbsp;Drivers for Block Devices</a></p>
<p class="toc level2"><a href="scsi-36812.html">17.&nbsp;&nbsp;SCSI Target Drivers</a></p>
<p class="toc level2"><a href="scsihba-32898.html">18.&nbsp;&nbsp;SCSI Host Bus Adapter Drivers</a></p>
<p class="toc level2"><a href="gld-1.html">19.&nbsp;&nbsp;Drivers for Network Devices</a></p>
<p class="toc level2"><a href="usb-1.html">20.&nbsp;&nbsp;USB Drivers</a></p>
<p class="toc level1 tocsp"><a href="eqbvo.html">Part&nbsp;III&nbsp;Building a Device Driver</a></p>
<p class="toc level2"><a href="loading-15035.html">21.&nbsp;&nbsp;Compiling, Loading, Packaging, and Testing Drivers</a></p>
<p class="toc level2"><a href="debug-60.html">22.&nbsp;&nbsp;Debugging, Testing, and Tuning Device Drivers</a></p>
<p class="toc level2"><a href="coding-practices.html">23.&nbsp;&nbsp;Recommended Coding Practices</a></p>
<p class="toc level1 tocsp"><a href="eqbva.html">Part&nbsp;IV&nbsp;Appendixes</a></p>
<p class="toc level2"><a href="hwovr-18191.html">A.&nbsp;&nbsp;Hardware Overview</a></p>
<p class="toc level2"><a href="ddidkisvc-29227.html">B.&nbsp;&nbsp;Summary of Solaris DDI/DKI Services</a></p>
<p class="toc level2"><a href="lp64-35004.html">C.&nbsp;&nbsp;Making a Device Driver 64-Bit Ready</a></p>
<p class="toc level2"><a href="euazz.html">D.&nbsp;&nbsp;Console Frame Buffer Drivers</a></p>
<p class="toc level1 tocsp"><a href="idx-1.html">Index</a></p>
</td>
      <td class="ContentPane" width="705px">

	 <div class="MainContent">      	 
             

<a name="character-17"></a><h3>32-bit and 64-bit Data Structure Macros</h3>
<p>The method in <a href="character-23939.html#character-ex-6">Example&nbsp;15-15</a> works well for many drivers. An alternate scheme is
to use the data structure macros that are provided in <tt>&lt;sys/model.h&gt;</tt>to move data
between the application and the kernel. These macros make the code less cluttered and
behave identically, from a functional perspective.</p><a name="character-ex-8"></a><h6>Example&nbsp;15-16 Using Data Structure Macros to Move Data</h6><pre>int
    xxioctl(dev_t dev, int cmd, intptr_t arg, int mode,
        cred_t *cr, int *rval_p)
    {    
        STRUCT_DECL(opdata, op);

        if (cmd != OPONE)
            return (ENOTTY);

        STRUCT_INIT(op, mode);

        if (copyin((void *)arg,
            STRUCT_BUF(op), STRUCT_SIZE(op)))
                return (EFAULT);

        if (STRUCT_FGET(op, flag) != XXACTIVE ||     
            STRUCT_FGET(op, size) &gt; XXSIZE)
                return (EINVAL);
        xxdowork(device_state, STRUCT_FGET(op, size));
        return (0);
}</pre>

<a name="character-29"></a><h4>How Do the Structure Macros Work?</h4>
<p>In a 64-bit device driver, structure macros enable the use of the
same piece of kernel memory by data structures of both sizes. The memory
buffer holds the contents of the native form of the data structure, that
is, the LP64 form, and the ILP32 form. Each structure access is implemented
by a conditional expression. When compiled as a 32-bit driver, only one data
model, the native form, is supported. No conditional expression is used.</p><p>The 64-bit versions of the macros depend on the definition of a
shadow version of the data structure. The shadow version describes the 32-bit interface with
fixed-width types. The name of the shadow data structure is formed by appending
&ldquo;32&rdquo; to the name of the native data structure. For convenience, place the
definition of the shadow structure in the same file as the native structure
to ease future maintenance costs.</p><p>The macros can take the following arguments:</p><dl><dt><i>structname</i></dt>
<dd><p>The structure name of the native form of the data structure as entered after the <tt>struct</tt> keyword.</p></dd>
<dt><i>umodel</i></dt>
<dd><p>A flag word that contains the user data model, such as <tt>FILP32</tt> or <tt>FLP64</tt>, extracted from the mode parameter of <a href="http://docs.sun.com/doc/819-2255/ioctl-9e?a=view"><tt>ioctl</tt>(9E)</a>.</p></dd>
<dt><i>handle</i></dt>
<dd><p>The name used to refer to a particular instance of a structure that is manipulated by these macros.</p></dd>
<dt><i>fieldname</i></dt>
<dd><p>The name of the field within the structure.</p></dd>
</dl>


<a name="character-30"></a><h4>When to Use Structure Macros</h4>
<p>Macros enable you to make in-place references only to the fields of a
data item. Macros do not provide a way to take separate code
paths that are based on the data model. Macros should be avoided if
the number of fields in the data structure is large. Macros should also
be avoided if the frequency of references to these fields is high.</p><p>Macros hide many of the differences between data models in the implementation of
the macros. As a result, code written with this interface is generally easier
to read. When compiled as a 32-bit driver, the resulting code is
compact without needing clumsy <tt>#ifdefs</tt>, but still preserves type checking.</p>

<a name="character-41"></a><h4>Declaring and Initializing Structure Handles</h4>
<p><a href="http://docs.sun.com/doc/819-2256/struct-decl-9f?a=view"><tt>STRUCT_DECL</tt>(9F)</a> and <a href="http://docs.sun.com/doc/819-2256/struct-init-9f?a=view"><tt>STRUCT_INIT</tt>(9F)</a> can be used to declare and initialize a handle and
space for decoding an <tt>ioctl</tt> on the stack. <a href="http://docs.sun.com/doc/819-2256/struct-handle-9f?a=view"><tt>STRUCT_HANDLE</tt>(9F)</a> and <a href="http://docs.sun.com/doc/819-2256/struct-set-handle-9f?a=view"><tt>STRUCT_SET_HANDLE</tt>(9F)</a> declare and
initialize a handle without allocating space on the stack. The latter macros can
be useful if the structure is very large, or is contained in some
other data structure.</p>
<hr><p><b>Note - </b>Because the <a href="http://docs.sun.com/doc/819-2256/struct-decl-9f?a=view"><tt>STRUCT_DECL</tt>(9F)</a> and <a href="http://docs.sun.com/doc/819-2256/struct-handle-9f?a=view"><tt>STRUCT_HANDLE</tt>(9F)</a> macros expand to data structure declarations, these macros
should be grouped with such declarations in C code.</p>
<hr>
<p>The macros for declaring and initializing structures are as follows:</p><dl><dt><tt>STRUCT_DECL(</tt><i>structname</i><tt>,</tt> <i>handle</i><tt>)</tt></dt>
<dd><p>Declares a <b>structure handle</b>that is called <tt>handle</tt> for a <i>structname</i> data structure. <tt>STRUCT_DECL</tt> allocates space for its native form on the stack. The native form is assumed to be larger than or equal to the ILP32 form of the structure.</p></dd>
<dt><tt>STRUCT_INIT(</tt><i>handle</i><tt>,</tt> <i>umodel</i><tt>)</tt></dt>
<dd><p>Initializes the data model for <i>handle</i> to <tt>umodel</tt>. This macro must be invoked before any access is made to a structure handle declared with <a href="http://docs.sun.com/doc/819-2256/struct-decl-9f?a=view"><tt>STRUCT_DECL</tt>(9F)</a>.</p></dd>
<dt><tt>STRUCT_HANDLE(</tt><i>structname</i><tt>,</tt> <i>handle</i><tt>)</tt></dt>
<dd><p>Declares a <b>structure handle</b> that is called <tt>handle</tt>. Contrast with <a href="http://docs.sun.com/doc/819-2256/struct-decl-9f?a=view"><tt>STRUCT_DECL</tt>(9F)</a>.</p></dd>
<dt><tt>STRUCT_SET_HANDLE(</tt><i>handle</i><tt>,</tt> <i>umodel</i><tt>,</tt> <i>addr</i><tt>)</tt></dt>
<dd><p>Initializes the data model for <i>handle</i> to <i>umodel</i>, and sets <i>addr</i> as the buffer used for subsequent manipulation. Invoke this macro before accessing a structure handle declared with <a href="http://docs.sun.com/doc/819-2256/struct-decl-9f?a=view"><tt>STRUCT_DECL</tt>(9F)</a>.</p></dd>
</dl>


<a name="character-42"></a><h4>Operations on Structure Handles</h4>
<p>The macros for performing operations on structures are as follows:</p><dl><dt><tt>size_t STRUCT_SIZE(</tt><i>handle</i><tt>)</tt></dt>
<dd><p>Returns the size of the structure referred to by <i>handle</i>, according to its embedded data model.</p></dd>
<dt><tt>typeof</tt> <i>fieldname</i> <tt>STRUCT_FGET(</tt><i>handle</i><tt>,</tt> <i>fieldname</i><tt>)</tt></dt>
<dd><p>Returns the indicated field in the data structure referred to by <i>handle</i>. This field is a non-pointer type.</p></dd>
<dt><tt>typeof</tt> <i>fieldname</i> <tt>STRUCT_FGETP(</tt><i>handle</i><tt>,</tt> <i>fieldname</i><tt>)</tt></dt>
<dd><p>Returns the indicated field in the data structure referred to by <i>handle</i>. This field is a pointer type.</p></dd>
<dt><tt>STRUCT_FSET(</tt><i>handle</i><tt>,</tt> <i>fieldname</i><tt>,</tt> <i>val</i><tt>)</tt></dt>
<dd><p>Sets the indicated field in the data structure referred to by <i>handle</i> to value <i>val</i>. The type of <i>val</i> should match the type of <i>fieldname</i>. The field is a non-pointer type.</p></dd>
<dt><tt>STRUCT_FSETP(</tt><i>handle</i><tt>,</tt> <i>fieldname</i><tt>,</tt> <i>val</i><tt>)</tt></dt>
<dd><p>Sets the indicated field in the data structure referred to by <i>handle</i> to value <i>val</i>. The field is a pointer type.</p></dd>
<dt><tt>typeof</tt> <i>fieldname</i> <tt>*STRUCT_FADDR(</tt><i>handle</i><tt>,</tt> <i>fieldname</i><tt>)</tt></dt>
<dd><p>Returns the address of the indicated field in the data structure referred to by <i>handle</i>.</p></dd>
<dt><tt>struct structname *STRUCT_BUF(</tt><i>handle</i><tt>)</tt></dt>
<dd><p>Returns a pointer to the native structure described by <i>handle</i>.</p></dd>
</dl>


<a name="character-43"></a><h4>Other Operations</h4>
<p>Some miscellaneous structure macros follow:</p><dl><dt><tt>size_t SIZEOF_STRUCT(</tt><i>struct_name</i><tt>,</tt> <i>datamodel</i><tt>)</tt></dt>
<dd><p>Returns the size of <i>struct_name</i>, which is based on the given data model.</p></dd>
<dt><tt>size_t SIZEOF_PTR(</tt><i>datamodel</i><tt>)</tt></dt>
<dd><p>Returns the size of a pointer based on the given data model.</p></dd>
</dl>

         </div>
      </td>
   </tr>

   <tr class="PageControls" valign="top">
      <td></td>
      <td>
         <table width="100%">
      	   <tr>
      	     <td>
                 <a href="character-23939.html">Previous</a>
             </td>
             <td align="right">
                 <a href="block-34861.html">Next</a>
             </td>
           </tr>
         </table>
      </td>
   </tr>
</tbody>
</table>


</body>
</html>

