<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="en-US">
<head>
<meta http-equiv="Content-type" content="text/html; charset=iso-8859-1">
<title>DMA Windows - Writing Device Drivers</title>
<meta name="robots" content="index,follow">
<meta name="robots" content="index,follow">
<meta name="date" content="2008-08-01">
<meta name="collection" content="reference">
<link rel="stylesheet" type="text/css" href="css/elements.css">
<link rel="stylesheet" type="text/css" href="css/indiana.css">
</head>

<body>


<div class="Masthead">
   <div class="MastheadLogo">
      <a href="http://www.opensolaris.org"><img border="0" src="graphics/header.png"></img></a>
   </div>
   <div class="Title">Writing Device Drivers</div>
</div>

<table class="Layout" border="0" cellspacing="0" width="100%">
<tbody>

   <tr valign="top" class="PageControls">
      <td></td>
      <td>
         <table width="100%">
      	   <tr>
      	     <td>
                 <a href="dma-6.html">Previous</a>
             </td>
             <td align="right">
                 <a href="devmap-24338.html">Next</a>
             </td>
           </tr>
         </table>
      </td>
   </tr>
   
   <tr valign="top">
      <td class="Navigation" width="200px"><p class="toc level1"><a href="docinfo.html">Document Information</a></p>
<p class="toc level1 tocsp"><a href="preface-1.html">Preface</a></p>
<p class="toc level1 tocsp"><a href="eqbvu.html">Part&nbsp;I&nbsp;Designing Device Drivers for the Solaris Platform</a></p>
<p class="toc level2"><a href="eqbqn.html">1.&nbsp;&nbsp;Overview of Solaris Device Drivers</a></p>
<p class="toc level2"><a href="kernelovr-77198.html">2.&nbsp;&nbsp;Solaris Kernel and Device Tree</a></p>
<p class="toc level2"><a href="mt-17026.html">3.&nbsp;&nbsp;Multithreading</a></p>
<p class="toc level2"><a href="properties-1.html">4.&nbsp;&nbsp;Properties</a></p>
<p class="toc level2"><a href="events-1.html">5.&nbsp;&nbsp;Managing Events and Queueing Tasks</a></p>
<p class="toc level2"><a href="autoconf-17.html">6.&nbsp;&nbsp;Driver Autoconfiguration</a></p>
<p class="toc level2"><a href="devaccess-3.html">7.&nbsp;&nbsp;Device Access: Programmed I/O</a></p>
<p class="toc level2"><a href="interrupt-15678.html">8.&nbsp;&nbsp;Interrupt Handlers</a></p>
<p class="toc level2"><a href="dma-29901.html">9.&nbsp;&nbsp;Direct Memory Access (DMA)</a></p>
<p class="toc level3"><a href="dma-1.html">DMA Model</a></p>
<p class="toc level3"><a href="dma-2.html">Types of Device DMA</a></p>
<p class="toc level3"><a href="dma-6a.html">Types of Host Platform DMA</a></p>
<p class="toc level3"><a href="dma-7.html">DMA Software Components:  Handles, Windows, and Cookies</a></p>
<p class="toc level3"><a href="dma-36180.html">DMA Operations</a></p>
<p class="toc level3"><a href="dma-6.html">Managing DMA Resources</a></p>
<div class="onpage">
<p class="toc level3"><a href="">DMA Windows</a></p>
</div>
<p class="toc level2 tocsp"><a href="devmap-24338.html">10.&nbsp;&nbsp;Mapping Device and Kernel Memory</a></p>
<p class="toc level2"><a href="devcnmgt-19679.html">11.&nbsp;&nbsp;Device Context Management</a></p>
<p class="toc level2"><a href="powermgt-37437.html">12.&nbsp;&nbsp;Power Management</a></p>
<p class="toc level2"><a href="gevsi.html">13.&nbsp;&nbsp;Hardening Solaris Drivers</a></p>
<p class="toc level2"><a href="ldi-1.html">14.&nbsp;&nbsp;Layered Driver Interface (LDI)</a></p>
<p class="toc level1 tocsp"><a href="eqbvb.html">Part&nbsp;II&nbsp;Designing Specific Kinds of Device Drivers</a></p>
<p class="toc level2"><a href="character-21002.html">15.&nbsp;&nbsp;Drivers for Character Devices</a></p>
<p class="toc level2"><a href="block-34861.html">16.&nbsp;&nbsp;Drivers for Block Devices</a></p>
<p class="toc level2"><a href="scsi-36812.html">17.&nbsp;&nbsp;SCSI Target Drivers</a></p>
<p class="toc level2"><a href="scsihba-32898.html">18.&nbsp;&nbsp;SCSI Host Bus Adapter Drivers</a></p>
<p class="toc level2"><a href="gld-1.html">19.&nbsp;&nbsp;Drivers for Network Devices</a></p>
<p class="toc level2"><a href="usb-1.html">20.&nbsp;&nbsp;USB Drivers</a></p>
<p class="toc level1 tocsp"><a href="eqbvo.html">Part&nbsp;III&nbsp;Building a Device Driver</a></p>
<p class="toc level2"><a href="loading-15035.html">21.&nbsp;&nbsp;Compiling, Loading, Packaging, and Testing Drivers</a></p>
<p class="toc level2"><a href="debug-60.html">22.&nbsp;&nbsp;Debugging, Testing, and Tuning Device Drivers</a></p>
<p class="toc level2"><a href="coding-practices.html">23.&nbsp;&nbsp;Recommended Coding Practices</a></p>
<p class="toc level1 tocsp"><a href="eqbva.html">Part&nbsp;IV&nbsp;Appendixes</a></p>
<p class="toc level2"><a href="hwovr-18191.html">A.&nbsp;&nbsp;Hardware Overview</a></p>
<p class="toc level2"><a href="ddidkisvc-29227.html">B.&nbsp;&nbsp;Summary of Solaris DDI/DKI Services</a></p>
<p class="toc level2"><a href="lp64-35004.html">C.&nbsp;&nbsp;Making a Device Driver 64-Bit Ready</a></p>
<p class="toc level2"><a href="euazz.html">D.&nbsp;&nbsp;Console Frame Buffer Drivers</a></p>
<p class="toc level1 tocsp"><a href="idx-1.html">Index</a></p>
</td>
      <td class="ContentPane" width="705px">

	 <div class="MainContent">      	 
             

<a name="dma-35348"></a><h3>DMA Windows</h3>
<p><a name="gbgtz"></a><a name="indexterm-204"></a>If an object does not fit within the limitations of the DMA engine,
the transfer must be broken into a series of smaller transfers. The driver
can break up the transfer itself. Alternatively, the driver can allow the system
to allocate resources for only part of the object, thereby creating a series
of DMA <b>windows</b>. Allowing the system to allocate resources is the preferred solution,
because the system can manage the resources more effectively than the driver can
manage the resources.</p><p>A DMA window has two attributes. The <i>offset</i> attribute is measured from the
beginning of the object. The  <i>length</i> attribute is the number of bytes
of memory to be allocated. After a partial allocation, only a range of
<i>length</i> bytes that starts at <i>offset</i> has allocated resources.</p><p>A DMA window is requested by specifying the <tt>DDI_DMA_PARTIAL</tt> flag as a parameter
to <a href="http://docs.sun.com/doc/819-2256/ddi-dma-buf-bind-handle-9f?a=view"><tt>ddi_dma_buf_bind_handle</tt>(9F)</a> or <a href="http://docs.sun.com/doc/819-2256/ddi-dma-addr-bind-handle-9f?a=view"><tt>ddi_dma_addr_bind_handle</tt>(9F)</a>. Both functions return <tt>DDI_DMA_PARTIAL_MAP</tt> if a window can be
established. However, the system might allocate resources for the entire object, in which
case <tt>DDI_DMA_MAPPED</tt> is returned. The driver should check the return value to determine
whether DMA windows are in use. See the following example.</p><a name="dma-23815"></a><h6>Example&nbsp;9-7 Setting Up DMA Windows</h6><pre>static int
xxstart (caddr_t arg)
{
    struct xxstate *xsp = (struct xxstate *)arg;
    struct device_reg *regp = xsp-&gt;reg;
    ddi_dma_cookie_t cookie;
    int status;
    mutex_enter(&amp;xsp-&gt;mu);
    if (xsp-&gt;busy) {
        /* transfer in progress */
        mutex_exit(&amp;xsp-&gt;mu);
        return (DDI_DMA_CALLBACK_RUNOUT);
    }
    xsp-&gt;busy = 1;
    mutex_exit(&amp;xsp-&gt;mu);
    if ( /* transfer is a read */) {
        flags = DDI_DMA_READ;
    } else {
        flags = DDI_DMA_WRITE;
    }
    flags |= DDI_DMA_PARTIAL;
    status = ddi_dma_buf_bind_handle(xsp-&gt;handle, xsp-&gt;bp,
        flags, xxstart, (caddr_t)xsp, &amp;cookie, &amp;ccount);
    if (status != DDI_DMA_MAPPED &amp;&amp;
        status != DDI_DMA_PARTIAL_MAP)
        return (DDI_DMA_CALLBACK_RUNOUT);
    if (status == DDI_DMA_PARTIAL_MAP) {
        ddi_dma_numwin(xsp-&gt;handle, &amp;xsp-&gt;nwin);
        xsp-&gt;partial = 1;
        xsp-&gt;windex = 0;
    } else {
        xsp-&gt;partial = 0;
    }
    /* Program the DMA engine. */
    return (DDI_DMA_CALLBACK_DONE);
}</pre><p>Two functions operate with DMA windows. The first, <a href="http://docs.sun.com/doc/819-2256/ddi-dma-numwin-9f?a=view"><tt>ddi_dma_numwin</tt>(9F)</a>, returns the number of
DMA windows for a particular DMA object. The other function, <a href="http://docs.sun.com/doc/819-2256/ddi-dma-getwin-9f?a=view"><tt>ddi_dma_getwin</tt>(9F)</a>, allows
repositioning within the object, that is, reallocation of system resources. The <tt>ddi_dma_getwin()</tt> function
shifts the current window to a new window within the object. Because <tt>ddi_dma_getwin()</tt>
reallocates system resources to the new window, the previous window becomes invalid.</p>
<hr><p><b>Caution - </b>Do not move the DMA windows with a call to <tt>ddi_dma_getwin()</tt> before
transfers into the current window are complete. Wait until the transfer to the
current window is complete, which is when the interrupt arrives. Then call <tt>ddi_dma_getwin()</tt>
to avoid data corruption.</p>
<hr>
<p>The <tt>ddi_dma_getwin()</tt> function is normally called from an interrupt routine, as shown in
<a href="#dma-41452">Example&nbsp;9-8</a>. The first DMA transfer is initiated as a result of a
call to the driver. Subsequent transfers are started from the interrupt routine.</p><p>The interrupt routine examines the status of the device to determine whether the
device completes the transfer successfully. If not, normal error recovery occurs. If the
transfer is successful, the routine must determine whether the logical transfer is complete.
A complete transfer includes the entire object as specified by the <a href="http://docs.sun.com/doc/819-2257/buf-9s?a=view"><tt>buf</tt>(9S)</a> structure. 
In a partial transfer, only one DMA window is moved. In a
partial transfer, the interrupt routine moves the window with <a href="http://docs.sun.com/doc/819-2256/ddi-dma-getwin-9f?a=view"><tt>ddi_dma_getwin</tt>(9F)</a>, retrieves a new
cookie, and starts another DMA transfer.</p><p>If the logical request has been completed, the interrupt routine checks for pending
requests. If necessary, the interrupt routine starts a transfer. Otherwise, the routine returns
without invoking another DMA transfer. The following example illustrates the usual flow control.</p><a name="dma-41452"></a><h6>Example&nbsp;9-8 Interrupt Handler Using DMA Windows</h6><pre>static uint_t
xxintr(caddr_t arg)
{
    struct xxstate *xsp = (struct xxstate *)arg;
    uint8_t    status;
    volatile   uint8_t   temp;
    mutex_enter(&amp;xsp-&gt;mu);
    /* read status */
    status = ddi_get8(xsp-&gt;access_hdl, &amp;xsp-&gt;regp-&gt;csr);
    if (!(status &amp; INTERRUPTING)) {
        mutex_exit(&amp;xsp-&gt;mu);
        return (DDI_INTR_UNCLAIMED);
    }
    ddi_put8(xsp-&gt;access_hdl,&amp;xsp-&gt;regp-&gt;csr, CLEAR_INTERRUPT);
    /* for store buffers */
    temp = ddi_get8(xsp-&gt;access_hdl, &amp;xsp-&gt;regp-&gt;csr);
    if ( /* an error occurred during transfer */ ) {
        bioerror(xsp-&gt;bp, EIO);
        xsp-&gt;partial = 0;
    } else {
        xsp-&gt;bp-&gt;b_resid -= /* amount transferred */ ;
    }

    if (xsp-&gt;partial &amp;&amp; (++xsp-&gt;windex &lt; xsp-&gt;nwin)) {
        /* device still marked busy to protect state */
        mutex_exit(&amp;xsp-&gt;mu);
        (void) ddi_dma_getwin(xsp-&gt;handle, xsp-&gt;windex,
            &amp;offset, &amp;len, &amp;cookie, &amp;ccount);
        /* Program the DMA engine with the new cookie(s). */
        return (DDI_INTR_CLAIMED);
    }
    ddi_dma_unbind_handle(xsp-&gt;handle);
    biodone(xsp-&gt;bp);
    xsp-&gt;busy = 0;
    xsp-&gt;partial = 0;
    mutex_exit(&amp;xsp-&gt;mu);
    if ( /* pending transfers */ ) {
        (void) xxstart((caddr_t)xsp);
    }
    return (DDI_INTR_CLAIMED);
}</pre>
         </div>
      </td>
   </tr>

   <tr class="PageControls" valign="top">
      <td></td>
      <td>
         <table width="100%">
      	   <tr>
      	     <td>
                 <a href="dma-6.html">Previous</a>
             </td>
             <td align="right">
                 <a href="devmap-24338.html">Next</a>
             </td>
           </tr>
         </table>
      </td>
   </tr>
</tbody>
</table>


</body>
</html>

