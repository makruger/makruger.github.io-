<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="en-US">
<head>
<meta http-equiv="Content-type" content="text/html; charset=iso-8859-1">
<title>Kernel Interfaces - Writing Device Drivers</title>
<meta name="robots" content="index,follow">
<meta name="robots" content="index,follow">
<meta name="date" content="2008-08-01">
<meta name="collection" content="reference">
<link rel="stylesheet" type="text/css" href="css/elements.css">
<link rel="stylesheet" type="text/css" href="css/indiana.css">
</head>

<body>


<div class="Masthead">
   <div class="MastheadLogo">
      <a href="http://www.opensolaris.org"><img border="0" src="graphics/header.png"></img></a>
   </div>
   <div class="Title">Writing Device Drivers</div>
</div>

<table class="Layout" border="0" cellspacing="0" width="100%">
<tbody>

   <tr valign="top" class="PageControls">
      <td></td>
      <td>
         <table width="100%">
      	   <tr>
      	     <td>
                 <a href="ewpre.html">Previous</a>
             </td>
             <td align="right">
                 <a href="ldi-5.html">Next</a>
             </td>
           </tr>
         </table>
      </td>
   </tr>
   
   <tr valign="top">
      <td class="Navigation" width="200px"><p class="toc level1"><a href="docinfo.html">Document Information</a></p>
<p class="toc level1 tocsp"><a href="preface-1.html">Preface</a></p>
<p class="toc level1 tocsp"><a href="eqbvu.html">Part&nbsp;I&nbsp;Designing Device Drivers for the Solaris Platform</a></p>
<p class="toc level2"><a href="eqbqn.html">1.&nbsp;&nbsp;Overview of Solaris Device Drivers</a></p>
<p class="toc level2"><a href="kernelovr-77198.html">2.&nbsp;&nbsp;Solaris Kernel and Device Tree</a></p>
<p class="toc level2"><a href="mt-17026.html">3.&nbsp;&nbsp;Multithreading</a></p>
<p class="toc level2"><a href="properties-1.html">4.&nbsp;&nbsp;Properties</a></p>
<p class="toc level2"><a href="events-1.html">5.&nbsp;&nbsp;Managing Events and Queueing Tasks</a></p>
<p class="toc level2"><a href="autoconf-17.html">6.&nbsp;&nbsp;Driver Autoconfiguration</a></p>
<p class="toc level2"><a href="devaccess-3.html">7.&nbsp;&nbsp;Device Access: Programmed I/O</a></p>
<p class="toc level2"><a href="interrupt-15678.html">8.&nbsp;&nbsp;Interrupt Handlers</a></p>
<p class="toc level2"><a href="dma-29901.html">9.&nbsp;&nbsp;Direct Memory Access (DMA)</a></p>
<p class="toc level2"><a href="devmap-24338.html">10.&nbsp;&nbsp;Mapping Device and Kernel Memory</a></p>
<p class="toc level2"><a href="devcnmgt-19679.html">11.&nbsp;&nbsp;Device Context Management</a></p>
<p class="toc level2"><a href="powermgt-37437.html">12.&nbsp;&nbsp;Power Management</a></p>
<p class="toc level2"><a href="gevsi.html">13.&nbsp;&nbsp;Hardening Solaris Drivers</a></p>
<p class="toc level2"><a href="ldi-1.html">14.&nbsp;&nbsp;Layered Driver Interface (LDI)</a></p>
<p class="toc level3"><a href="ewpre.html">LDI Overview</a></p>
<div class="onpage">
<p class="toc level3"><a href="">Kernel Interfaces</a></p>
</div>
<p class="toc level3"><a href="ldi-5.html">User Interfaces</a></p>
<p class="toc level1 tocsp"><a href="eqbvb.html">Part&nbsp;II&nbsp;Designing Specific Kinds of Device Drivers</a></p>
<p class="toc level2"><a href="character-21002.html">15.&nbsp;&nbsp;Drivers for Character Devices</a></p>
<p class="toc level2"><a href="block-34861.html">16.&nbsp;&nbsp;Drivers for Block Devices</a></p>
<p class="toc level2"><a href="scsi-36812.html">17.&nbsp;&nbsp;SCSI Target Drivers</a></p>
<p class="toc level2"><a href="scsihba-32898.html">18.&nbsp;&nbsp;SCSI Host Bus Adapter Drivers</a></p>
<p class="toc level2"><a href="gld-1.html">19.&nbsp;&nbsp;Drivers for Network Devices</a></p>
<p class="toc level2"><a href="usb-1.html">20.&nbsp;&nbsp;USB Drivers</a></p>
<p class="toc level1 tocsp"><a href="eqbvo.html">Part&nbsp;III&nbsp;Building a Device Driver</a></p>
<p class="toc level2"><a href="loading-15035.html">21.&nbsp;&nbsp;Compiling, Loading, Packaging, and Testing Drivers</a></p>
<p class="toc level2"><a href="debug-60.html">22.&nbsp;&nbsp;Debugging, Testing, and Tuning Device Drivers</a></p>
<p class="toc level2"><a href="coding-practices.html">23.&nbsp;&nbsp;Recommended Coding Practices</a></p>
<p class="toc level1 tocsp"><a href="eqbva.html">Part&nbsp;IV&nbsp;Appendixes</a></p>
<p class="toc level2"><a href="hwovr-18191.html">A.&nbsp;&nbsp;Hardware Overview</a></p>
<p class="toc level2"><a href="ddidkisvc-29227.html">B.&nbsp;&nbsp;Summary of Solaris DDI/DKI Services</a></p>
<p class="toc level2"><a href="lp64-35004.html">C.&nbsp;&nbsp;Making a Device Driver 64-Bit Ready</a></p>
<p class="toc level2"><a href="euazz.html">D.&nbsp;&nbsp;Console Frame Buffer Drivers</a></p>
<p class="toc level1 tocsp"><a href="idx-1.html">Index</a></p>
</td>
      <td class="ContentPane" width="705px">

	 <div class="MainContent">      	 
             

<a name="ldi-2"></a><h3>Kernel Interfaces</h3>
<p><a name="indexterm-464"></a><a name="indexterm-465"></a>Some LDI kernel interfaces enable the LDI to track and report kernel device
usage information. See <a href="#ldi-6">Layered Identifiers - Kernel Device Consumers</a>.</p><p><a name="indexterm-466"></a><a name="indexterm-467"></a>Other LDI kernel interfaces enable kernel modules to perform access operations such as
<tt>open</tt>, <tt>read</tt>, and <tt>write</tt> a target device. These LDI kernel interfaces also
enable a kernel device consumer to query property and event information about target devices.
See <a href="#ldi-3">Layered Driver Handles - Target Devices</a>.</p><p><a href="#euayr">LDI Kernel Interfaces Example</a> shows an example driver that uses many of these LDI interfaces.</p>

<a name="ldi-6"></a><h4>Layered Identifiers &ndash; Kernel Device Consumers</h4>
<a name="indexterm-468"></a><a name="indexterm-469"></a><a name="indexterm-470"></a><a name="indexterm-471"></a><a name="indexterm-472"></a><a name="indexterm-473"></a><a name="indexterm-474"></a><p>Layered identifiers enable the LDI to track and report kernel device usage information.
A layered identifier (<tt>ldi_ident_t</tt>) identifies a kernel device consumer. Kernel device consumers must
obtain a layered identifier prior to opening a target device using the LDI.</p><p>Layered drivers are the only supported types of kernel device consumers. Therefore, a
layered driver must obtain a layered identifier that is associated with the device
number, the device information node, or the stream of the layered driver. The
layered identifier is associated with the layered driver. The layered identifier is not
associated with the target device.</p><p>You can retrieve the kernel device usage information that is collected by the
LDI by using the <tt>libdevinfo</tt>(3LIB) interfaces, the <tt>fuser</tt>(1M) command, or the <tt>prtconf</tt>(1M) command.
For example, the <tt>prtconf</tt>(1M) command can show which target devices a layered driver
is accessing or which layered drivers are accessing a particular target device. See
<a href="ldi-5.html">User Interfaces</a> to learn more about how to retrieve device usage information.</p><p>The following describes the LDI layered identifier interfaces:</p><dl><dt><tt>ldi_ident_t</tt></dt>
<dd><p>Layered identifier. An opaque type.</p></dd>
<dt><a href="http://docs.sun.com/doc/819-2256/ldi-ident-from-dev-9f?a=view"><tt>ldi_ident_from_dev</tt>(9F)</a></dt>
<dd><p>Allocate and retrieve a layered identifier that is associated with a <tt>dev_t</tt> device number.</p></dd>
<dt><a href="http://docs.sun.com/doc/819-2256/ldi-ident-from-dip-9f?a=view"><tt>ldi_ident_from_dip</tt>(9F)</a></dt>
<dd><p>Allocate and retrieve a layered identifier that is associated with a <tt>dev_info_t</tt> device information node.</p></dd>
<dt><a href="http://docs.sun.com/doc/819-2256/ldi-ident-from-stream-9f?a=view"><tt>ldi_ident_from_stream</tt>(9F)</a></dt>
<dd><p>Allocate and retrieve a layered identifier that is associated with a stream.</p></dd>
<dt><a href="http://docs.sun.com/doc/819-2256/ldi-ident-release-9f?a=view"><tt>ldi_ident_release</tt>(9F)</a></dt>
<dd><p>Release a layered identifier that was allocated with <tt>ldi_ident_from_dev</tt>(9F), <tt>ldi_ident_from_dip</tt>(9F), or <tt>ldi_ident_from_stream</tt>(9F).</p></dd>
</dl>


<a name="ldi-3"></a><h4>Layered Driver Handles &ndash; Target Devices</h4>
<a name="indexterm-475"></a><a name="indexterm-476"></a><a name="indexterm-477"></a><a name="indexterm-478"></a><p>Kernel device consumers must use a layered driver handle (<tt>ldi_handle_t</tt>) to access
a target device through LDI interfaces. The <tt>ldi_handle_t</tt> type is valid only
with LDI interfaces. The LDI allocates and returns this handle when the LDI
successfully opens a device. A kernel device consumer can then use this handle
to access the target device through the LDI interfaces. The LDI deallocates the
handle when the LDI closes the device. See <a href="#euayr">LDI Kernel Interfaces Example</a> for an example.</p><p>This section discusses how kernel device consumers can access target devices and retrieve
different types of information. See <a href="#eupzu">Opening and Closing Target Devices</a> to learn how kernel device consumers can
open and close target devices. See <a href="#ldi-24">Accessing Target Devices</a> to learn how kernel device
consumers can perform operations such as <tt>read</tt>, <tt>write</tt>, <tt>strategy</tt>, and <tt>ioctl</tt> on target devices.
<a href="#ldi-23">Retrieving Target Device Information</a> describes interfaces that retrieve target device information such as device open type
and device minor name. <a href="#ldi-22">Retrieving Target Device Property Values</a> describes interfaces that retrieve values and address of
target device properties. See <a href="#ldi-21">Receiving Asynchronous Device Event Notification</a> to learn how kernel device consumers can receive
event notification from target devices.</p>

<a name="eupzu"></a><h5>Opening and Closing Target Devices</h5>
<a name="indexterm-479"></a><a name="indexterm-480"></a><a name="indexterm-481"></a><a name="indexterm-482"></a><a name="indexterm-483"></a><p>This section describes the LDI kernel interfaces for opening and closing target devices.
The open interfaces take a pointer to a layered driver handle. The open
interfaces attempt to open the target device specified by the device number, device
ID, or path name. If the open operation is successful, the open interfaces
allocate and return a layered driver handle that can be used to access
the target device. The close interface closes the target device associated with the
specified layered driver handle and then frees the layered driver handle.</p><dl><dt><tt>ldi_handle_t</tt></dt>
<dd><p>Layered driver handle for target device access. An opaque data structure that is returned when a device is successfully opened.</p></dd>
<dt><a href="http://docs.sun.com/doc/819-2256/ldi-open-by-dev-9f?a=view"><tt>ldi_open_by_dev</tt>(9F)</a></dt>
<dd><p>Open the device specified by the <tt>dev_t</tt> device number parameter.</p></dd>
<dt><a href="http://docs.sun.com/doc/819-2256/ldi-open-by-devid-9f?a=view"><tt>ldi_open_by_devid</tt>(9F)</a></dt>
<dd><p>Open the device specified by the <tt>ddi_devid_t</tt> device ID parameter. You also must specify the minor node name to open.</p></dd>
<dt><a href="http://docs.sun.com/doc/819-2256/ldi-open-by-name-9f?a=view"><tt>ldi_open_by_name</tt>(9F)</a></dt>
<dd><p>Open a device by path name. The path name is a null-terminated string in the kernel address space. The path name must be an absolute path, beginning with a forward slash character (<tt>/</tt>).</p></dd>
<dt><a href="http://docs.sun.com/doc/819-2256/ldi-close-9f?a=view"><tt>ldi_close</tt>(9F)</a></dt>
<dd><p>Close a device that was opened with <tt>ldi_open_by_dev</tt>(9F), <tt>ldi_open_by_devid</tt>(9F), or <tt>ldi_open_by_name</tt>(9F). After <tt>ldi_close</tt>(9F) returns, the layered driver handle of the device that was closed is no longer valid.</p></dd>
</dl>


<a name="ldi-24"></a><h5>Accessing Target Devices</h5>
<a name="indexterm-484"></a><a name="indexterm-485"></a><a name="indexterm-486"></a><a name="indexterm-487"></a><a name="indexterm-488"></a><a name="indexterm-489"></a><a name="indexterm-490"></a><a name="indexterm-491"></a><a name="indexterm-492"></a><a name="indexterm-493"></a><a name="indexterm-494"></a><p>This section describes the LDI kernel interfaces for accessing target devices. These interfaces
enable a kernel device consumer to perform operations on the target device specified
by the layered driver handle. Kernel device consumers can perform operations such as
<tt>read</tt>, <tt>write</tt>, <tt>strategy</tt>, and <tt>ioctl</tt> on the target device.</p><dl><dt><tt>ldi_handle_t</tt></dt>
<dd><p>Layered driver handle for target device access. An opaque data structure.</p></dd>
<dt><a href="http://docs.sun.com/doc/819-2256/ldi-read-9f?a=view"><tt>ldi_read</tt>(9F)</a></dt>
<dd><p>Pass a read request to the device entry point for the target device. This operation is supported for block, character, and STREAMS devices.</p></dd>
<dt><a href="http://docs.sun.com/doc/819-2256/ldi-aread-9f?a=view"><tt>ldi_aread</tt>(9F)</a></dt>
<dd><p>Pass an asynchronous read request to the device entry point for the target device. This operation is supported for block and character devices.</p></dd>
<dt><a href="http://docs.sun.com/doc/819-2256/ldi-write-9f?a=view"><tt>ldi_write</tt>(9F)</a></dt>
<dd><p>Pass a write request to the device entry point for the target device. This operation is supported for block, character, and STREAMS devices.</p></dd>
<dt><a href="http://docs.sun.com/doc/819-2256/ldi-awrite-9f?a=view"><tt>ldi_awrite</tt>(9F)</a></dt>
<dd><p>Pass an asynchronous write request to the device entry point for the target device. This operation is supported for block and character devices.</p></dd>
<dt><a href="http://docs.sun.com/doc/819-2256/ldi-strategy-9f?a=view"><tt>ldi_strategy</tt>(9F)</a></dt>
<dd><p>Pass a strategy request to the device entry point for the target device. This operation is supported for block and character devices.</p></dd>
<dt><a href="http://docs.sun.com/doc/819-2256/ldi-dump-9f?a=view"><tt>ldi_dump</tt>(9F)</a></dt>
<dd><p>Pass a dump request to the device entry point for the target device. This operation is supported for block and character devices.</p></dd>
<dt><a href="http://docs.sun.com/doc/819-2256/ldi-poll-9f?a=view"><tt>ldi_poll</tt>(9F)</a></dt>
<dd><p>Pass a poll request to the device entry point for the target device. This operation is supported for block, character, and STREAMS devices.</p></dd>
<dt><a href="http://docs.sun.com/doc/819-2256/ldi-ioctl-9f?a=view"><tt>ldi_ioctl</tt>(9F)</a></dt>
<dd><p>Pass an <tt>ioctl</tt> request to the device entry point for the target device. This operation is supported for block, character, and STREAMS devices. The LDI supports STREAMS linking and STREAMS <tt>ioctl</tt> commands. See the &ldquo;STREAM IOCTLS&rdquo; section of the <tt>ldi_ioctl</tt>(9F) man page. See also the <tt>ioctl</tt> commands in the <a href="http://docs.sun.com/doc/819-2254/streamio-7i?a=view"><tt>streamio</tt>(7I)</a> man page.</p></dd>
<dt><a href="http://docs.sun.com/doc/819-2256/ldi-devmap-9f?a=view"><tt>ldi_devmap</tt>(9F)</a></dt>
<dd><p>Pass a <tt>devmap</tt> request to the device entry point for the target device. This operation is supported for block and character devices.</p></dd>
<dt><a href="http://docs.sun.com/doc/819-2256/ldi-getmsg-9f?a=view"><tt>ldi_getmsg</tt>(9F)</a></dt>
<dd><p>Get a message block from a stream.</p></dd>
<dt><a href="http://docs.sun.com/doc/819-2256/ldi-putmsg-9f?a=view"><tt>ldi_putmsg</tt>(9F)</a></dt>
<dd><p>Put a message block on a stream.</p></dd>
</dl>


<a name="ldi-23"></a><h5>Retrieving Target Device Information</h5>
<a name="indexterm-495"></a><a name="indexterm-496"></a><a name="indexterm-497"></a><a name="indexterm-498"></a><a name="indexterm-499"></a><a name="indexterm-500"></a><a name="indexterm-501"></a><a name="indexterm-502"></a><p>This section describes LDI interfaces that kernel device consumers can use to retrieve
device information about a specified target device. A target device is specified by
a layered driver handle. A kernel device consumer can receive information such as
device number, device open type, device ID, device minor name, and device size.</p><dl><dt><a href="http://docs.sun.com/doc/819-2256/ldi-get-dev-9f?a=view"><tt>ldi_get_dev</tt>(9F)</a></dt>
<dd><p>Get the <tt>dev_t</tt> device number for the target device specified by the layered driver handle.</p></dd>
<dt><a href="http://docs.sun.com/doc/819-2256/ldi-get-otyp-9f?a=view"><tt>ldi_get_otyp</tt>(9F)</a></dt>
<dd><p>Get the open flag that was used to open the target device specified by the layered driver handle. This flag tells you whether the target device is a character device or a block device.</p></dd>
<dt><a href="http://docs.sun.com/doc/819-2256/ldi-get-devid-9f?a=view"><tt>ldi_get_devid</tt>(9F)</a></dt>
<dd><p>Get the <tt>ddi_devid_t</tt> device ID for the target device specified by the layered driver handle. Use <a href="http://docs.sun.com/doc/819-2256/ddi-devid-free-9f?a=view"><tt>ddi_devid_free</tt>(9F)</a> to free the <tt>ddi_devid_t</tt> when you are finished using the device ID.</p></dd>
<dt><a href="http://docs.sun.com/doc/819-2256/ldi-get-minor-name-9f?a=view"><tt>ldi_get_minor_name</tt>(9F)</a></dt>
<dd><p>Retrieve a buffer that contains the name of the minor node that was opened for the target device. Use <a href="http://docs.sun.com/doc/819-2256/kmem-free-9f?a=view"><tt>kmem_free</tt>(9F)</a> to release the buffer when you are finished using the minor node name.</p></dd>
<dt><a href="http://docs.sun.com/doc/819-2256/ldi-get-size-9f?a=view"><tt>ldi_get_size</tt>(9F)</a></dt>
<dd><p>Retrieve the partition size of the target device specified by the layered driver handle.</p></dd>
</dl>


<a name="ldi-22"></a><h5>Retrieving Target Device Property Values</h5>
<a name="indexterm-503"></a><a name="indexterm-504"></a><a name="indexterm-505"></a><a name="indexterm-506"></a><a name="indexterm-507"></a><a name="indexterm-508"></a><a name="indexterm-509"></a><a name="indexterm-510"></a><a name="indexterm-511"></a><a name="indexterm-512"></a><p>This section describes LDI interfaces that kernel device consumers can use to retrieve
property information about a specified target device. A target device is specified by
a layered driver handle. A kernel device consumer can receive values and addresses
of properties and determine whether a property exists.</p><dl><dt><a href="http://docs.sun.com/doc/819-2256/ldi-prop-exists-9f?a=view"><tt>ldi_prop_exists</tt>(9F)</a></dt>
<dd><p>Return <tt>1</tt> if the property exists for the target device specified by the layered driver handle. Return <tt>0</tt> if the property does not exist for the specified target device.</p></dd>
<dt><a href="http://docs.sun.com/doc/819-2256/ldi-prop-get-int-9f?a=view"><tt>ldi_prop_get_int</tt>(9F)</a></dt>
<dd><p>Search for an <tt>int</tt> integer property that is associated with the target device specified by the layered driver handle. If the integer property is found, return the property value.</p></dd>
<dt><a href="http://docs.sun.com/doc/819-2256/ldi-prop-get-int64-9f?a=view"><tt>ldi_prop_get_int64</tt>(9F)</a></dt>
<dd><p>Search for an <tt>int64_t</tt> integer property that is associated with the target device specified by the layered driver handle. If the integer property is found, return the property value.</p></dd>
<dt><a href="http://docs.sun.com/doc/819-2256/ldi-prop-lookup-int-array-9f?a=view"><tt>ldi_prop_lookup_int_array</tt>(9F)</a></dt>
<dd><p>Retrieve the address of an <tt>int</tt> integer array property value for the target device specified by the layered driver handle.</p></dd>
<dt><a href="http://docs.sun.com/doc/819-2256/ldi-prop-lookup-int64-array-9f?a=view"><tt>ldi_prop_lookup_int64_array</tt>(9F)</a></dt>
<dd><p>Retrieve the address of an <tt>int64_t</tt> integer array property value for the target device specified by the layered driver handle.</p></dd>
<dt><a href="http://docs.sun.com/doc/819-2256/ldi-prop-lookup-string-9f?a=view"><tt>ldi_prop_lookup_string</tt>(9F)</a></dt>
<dd><p>Retrieve the address of a null-terminated string property value for the target device specified by the layered driver handle.</p></dd>
<dt><a href="http://docs.sun.com/doc/819-2256/ldi-prop-lookup-string-array-9f?a=view"><tt>ldi_prop_lookup_string_array</tt>(9F)</a></dt>
<dd><p>Retrieve the address of an array of strings. The string array is an array of pointers to null-terminated strings of property values for the target device specified by the layered driver handle.</p></dd>
<dt><a href="http://docs.sun.com/doc/819-2256/ldi-prop-lookup-byte-array-9f?a=view"><tt>ldi_prop_lookup_byte_array</tt>(9F)</a></dt>
<dd><p>Retrieve the address of an array of bytes. The byte array is a property value of the target device specified by the layered driver handle.</p></dd>
</dl>


<a name="ldi-21"></a><h5>Receiving Asynchronous Device Event Notification</h5>
<a name="indexterm-513"></a><a name="indexterm-514"></a><a name="indexterm-515"></a><a name="indexterm-516"></a><a name="indexterm-517"></a><a name="indexterm-518"></a><a name="indexterm-519"></a><p>The LDI enables kernel device consumers to register for event notification and to
receive event notification from target devices. A kernel device consumer can register an
event handler that will be called when the event occurs. The kernel device
consumer must open a device and receive a layered driver handle before the
kernel device consumer can register for event notification with the LDI event notification
interfaces.</p><p>The LDI event notification interfaces enable a kernel device consumer to specify an
event name and to retrieve an associated kernel event cookie. The kernel device
consumer can then pass the layered driver handle (<tt>ldi_handle_t</tt>), the cookie (<tt>ddi_eventcookie_t</tt>),
and the event handler to <a href="http://docs.sun.com/doc/819-2256/ldi-add-event-handler-9f?a=view"><tt>ldi_add_event_handler</tt>(9F)</a> to register for event notification. When registration completes
successfully, the kernel device consumer receives a unique LDI event handler identifier (<tt>ldi_callback_id_t</tt>).
The LDI event handler identifier is an opaque type that can be used
only with the LDI event notification interfaces.</p><p>The LDI provides a framework to register for events generated by other devices.
The LDI itself does not define any event types or provide interfaces for
generating events.</p><p>The following describes the LDI asynchronous event notification interfaces:</p><dl><dt><tt>ldi_callback_id_t</tt></dt>
<dd><p>Event handler identifier. An opaque type.</p></dd>
<dt><a href="http://docs.sun.com/doc/819-2256/ldi-get-eventcookie-9f?a=view"><tt>ldi_get_eventcookie</tt>(9F)</a></dt>
<dd><p>Retrieve an event service cookie for the target device specified by the layered driver handle.</p></dd>
<dt><a href="http://docs.sun.com/doc/819-2256/ldi-add-event-handler-9f?a=view"><tt>ldi_add_event_handler</tt>(9F)</a></dt>
<dd><p>Add the callback handler specified by the <tt>ldi_callback_id_t</tt> registration identifier. The callback handler is invoked when the event specified by the <tt>ddi_eventcookie_t</tt> cookie occurs.</p></dd>
<dt><a href="http://docs.sun.com/doc/819-2256/ldi-remove-event-handler-9f?a=view"><tt>ldi_remove_event_handler</tt>(9F)</a></dt>
<dd><p>Remove the callback handler specified by the <tt>ldi_callback_id_t</tt> registration identifier.</p></dd>
</dl>


<a name="euayr"></a><h4>LDI Kernel Interfaces Example</h4>
<p>This section shows an example kernel device consumer that uses some of the
LDI calls discussed in the preceding sections in this chapter. This section discusses
the following aspects of this example module:</p>
<ul><li><p><a href="#eubbk">Device Configuration File</a></p></li>
<li><p><a href="#eubbe">Driver Source File</a></p></li>
<li><p><a href="#euihe">Test the Layered Driver</a></p></li></ul>
<p>This example kernel device consumer is named <tt>lyr</tt>. The <tt>lyr</tt> module is a
layered driver that uses LDI calls to send data to a target device.
In its <a href="http://docs.sun.com/doc/819-2255/open-9e?a=view"><tt>open</tt>(9E)</a> entry point, the <tt>lyr</tt> driver opens the device that is
specified by the <tt>lyr_targ</tt> property in the <tt>lyr.conf</tt> configuration file. In its <a href="http://docs.sun.com/doc/819-2255/write-9e?a=view"><tt>write</tt>(9E)</a>
entry point, the <tt>lyr</tt> driver writes all of its incoming data to the
device specified by the <tt>lyr_targ</tt> property.</p>

<a name="eubbk"></a><h5>Device Configuration File</h5>
<p>In the configuration file shown below, the target device that the <tt>lyr</tt>
driver is writing to is the console.</p><a name="euayx"></a><h6>Example&nbsp;14-1 Configuration File</h6><pre>#
# Copyright 2004 Sun Microsystems, Inc.  All rights reserved.
# Use is subject to license terms.
#
#pragma ident    "%Z%%M%    %I%    %E% SMI"

name="lyr" parent="pseudo" instance=1;
lyr_targ="/dev/console";</pre>

<a name="eubbe"></a><h5>Driver Source File</h5>
<a name="indexterm-520"></a><a name="indexterm-521"></a><a name="indexterm-522"></a><a name="indexterm-523"></a><p>In the driver source file shown below, the <tt>lyr_state_t</tt> structure holds the soft
state for the <tt>lyr</tt> driver. The soft state includes the layered driver handle
(<tt>lh</tt>) for the <tt>lyr_targ</tt> device and the layered identifier (<tt>li</tt>) for the
<tt>lyr</tt> device. For more information on soft state, see <a href="euxdb.html#fappe">Retrieving Driver Soft State Information</a>.</p><p><a name="indexterm-524"></a><a name="indexterm-525"></a><a name="indexterm-526"></a>In the <tt>lyr_open()</tt> entry point, <a href="http://docs.sun.com/doc/819-2256/ddi-prop-lookup-string-9f?a=view"><tt>ddi_prop_lookup_string</tt>(9F)</a> retrieves from the <tt>lyr_targ</tt> property the name
of the target device for the <tt>lyr</tt> device to open. The <a href="http://docs.sun.com/doc/819-2256/ldi-ident-from-dev-9f?a=view"><tt>ldi_ident_from_dev</tt>(9F)</a> function
gets an LDI layered identifier for the <tt>lyr</tt> device. The <a href="http://docs.sun.com/doc/819-2256/ldi-open-by-name-9f?a=view"><tt>ldi_open_by_name</tt>(9F)</a> function
opens the <tt>lyr_targ</tt> device and gets a layered driver handle for the
<tt>lyr_targ</tt> device.</p><p><a name="indexterm-527"></a><a name="indexterm-528"></a><a name="indexterm-529"></a>Note that if any failure occurs in <tt>lyr_open()</tt>, the <a href="http://docs.sun.com/doc/819-2256/ldi-close-9f?a=view"><tt>ldi_close</tt>(9F)</a>, <a href="http://docs.sun.com/doc/819-2256/ldi-ident-release-9f?a=view"><tt>ldi_ident_release</tt>(9F)</a>, and <a href="http://docs.sun.com/doc/819-2256/ddi-prop-free-9f?a=view"><tt>ddi_prop_free</tt>(9F)</a>
calls undo everything that was done. The <tt>ldi_close</tt>(9F) function closes the <tt>lyr_targ</tt> device. The
<tt>ldi_ident_release</tt>(9F) function releases the <tt>lyr</tt> layered identifier. The <tt>ddi_prop_free</tt>(9F) function frees resources allocated
when the <tt>lyr_targ</tt> device name was retrieved. If no failure occurs, the <tt>ldi_close</tt>(9F)
and <tt>ldi_ident_release</tt>(9F) functions are called in the <tt>lyr_close()</tt> entry point.</p><p><a name="indexterm-530"></a>In the last line of the driver module, the <a href="http://docs.sun.com/doc/819-2256/ldi-write-9f?a=view"><tt>ldi_write</tt>(9F)</a> function is called.
The <tt>ldi_write</tt>(9F) function takes the data written to the <tt>lyr</tt> device in the
<tt>lyr_write()</tt> entry point and writes that data to the <tt>lyr_targ</tt> device. The <tt>ldi_write</tt>(9F)
function uses the layered driver handle for the <tt>lyr_targ</tt> device to write the data
to the <tt>lyr_targ</tt> device.</p><a name="euayy"></a><h6>Example&nbsp;14-2 Driver Source File</h6><pre>#include &lt;sys/types.h&gt;
#include &lt;sys/file.h&gt;
#include &lt;sys/errno.h&gt;
#include &lt;sys/open.h&gt;
#include &lt;sys/cred.h&gt;
#include &lt;sys/cmn_err.h&gt;
#include &lt;sys/modctl.h&gt;
#include &lt;sys/conf.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;sys/ddi.h&gt;
#include &lt;sys/sunddi.h&gt;
#include &lt;sys/sunldi.h&gt;

typedef struct lyr_state {
    ldi_handle_t    lh;
    ldi_ident_t     li;
    dev_info_t      *dip;
    minor_t     minor;
    int         flags;
    kmutex_t    lock;
} lyr_state_t;

#define LYR_OPENED      0x1     /* lh is valid */
#define LYR_IDENTED     0x2     /* li is valid */

static int lyr_info(dev_info_t *, ddi_info_cmd_t, void *, void **);
static int lyr_attach(dev_info_t *, ddi_attach_cmd_t);
static int lyr_detach(dev_info_t *, ddi_detach_cmd_t);
static int lyr_open(dev_t *, int, int, cred_t *);
static int lyr_close(dev_t, int, int, cred_t *);
static int lyr_write(dev_t, struct uio *, cred_t *);

static void *lyr_statep;

static struct cb_ops lyr_cb_ops = {
    lyr_open,       /* open */
    lyr_close,      /* close */
    nodev,      /* strategy */
    nodev,      /* print */
    nodev,      /* dump */
    nodev,      /* read */
    lyr_write,      /* write */
    nodev,      /* ioctl */
    nodev,      /* devmap */
    nodev,      /* mmap */
    nodev,      /* segmap */
    nochpoll,       /* poll */
    ddi_prop_op,    /* prop_op */
    NULL,       /* streamtab  */
    D_NEW | D_MP,   /* cb_flag */
    CB_REV,     /* cb_rev */
    nodev,      /* aread */
    nodev       /* awrite */
};

static struct dev_ops lyr_dev_ops = {
    DEVO_REV,       /* devo_rev, */
    0,          /* refcnt  */
    lyr_info,       /* getinfo */
    nulldev,    /* identify */
    nulldev,    /* probe */
    lyr_attach,     /* attach */
    lyr_detach,     /* detach */
    nodev,      /* reset */
    &amp;lyr_cb_ops,    /* cb_ops */
    NULL,       /* bus_ops */
    NULL        /* power */
};

static struct modldrv modldrv = {
    &amp;mod_driverops,
    "LDI example driver",
    &amp;lyr_dev_ops
};

static struct modlinkage modlinkage = {
    MODREV_1,
    &amp;modldrv,
    NULL
};

int
_init(void)
{
    int rv;

    if ((rv = ddi_soft_state_init(&amp;lyr_statep, sizeof (lyr_state_t),
        0)) != 0) {
        cmn_err(CE_WARN, "lyr _init: soft state init failed\n");
        return (rv);
    }
    if ((rv = mod_install(&amp;modlinkage)) != 0) {
        cmn_err(CE_WARN, "lyr _init: mod_install failed\n");
        goto FAIL;
    }
    return (rv);
    /*NOTEREACHED*/
FAIL:
    ddi_soft_state_fini(&amp;lyr_statep);
    return (rv);
}

int
_info(struct modinfo *modinfop)
{
    return (mod_info(&amp;modlinkage, modinfop));
}

int
_fini(void)
{
    int rv;

    if ((rv = mod_remove(&amp;modlinkage)) != 0) {
        return(rv);
    }
    ddi_soft_state_fini(&amp;lyr_statep);
    return (rv);
}
/*
 * 1:1 mapping between minor number and instance
 */
static int
lyr_info(dev_info_t *dip, ddi_info_cmd_t infocmd, void *arg, void **result)
{
    int inst;
    minor_t minor;
    lyr_state_t *statep;
    char *myname = "lyr_info";

    minor = getminor((dev_t)arg);
    inst = minor;
    switch (infocmd) {
    case DDI_INFO_DEVT2DEVINFO:
        statep = ddi_get_soft_state(lyr_statep, inst);
        if (statep == NULL) {
            cmn_err(CE_WARN, "%s: get soft state "
                "failed on inst %d\n", myname, inst);
            return (DDI_FAILURE);
        }
        *result = (void *)statep-&gt;dip;
        break;
    case DDI_INFO_DEVT2INSTANCE:
        *result = (void *)inst;
        break;
    default:
        break;
    }

    return (DDI_SUCCESS);
}

static int
lyr_attach(dev_info_t *dip, ddi_attach_cmd_t cmd)
{
    int inst;
    lyr_state_t *statep;
    char *myname = "lyr_attach";

    switch (cmd) {
    case DDI_ATTACH:
        inst = ddi_get_instance(dip);

        if (ddi_soft_state_zalloc(lyr_statep, inst) != DDI_SUCCESS) {
            cmn_err(CE_WARN, "%s: ddi_soft_state_zallac failed "
                "on inst %d\n", myname, inst);
            goto FAIL;
        }
        statep = (lyr_state_t *)ddi_get_soft_state(lyr_statep, inst);
        if (statep == NULL) {
            cmn_err(CE_WARN, "%s: ddi_get_soft_state failed on "
                "inst %d\n", myname, inst);
            goto FAIL;
        }
        statep-&gt;dip = dip;
        statep-&gt;minor = inst;
        if (ddi_create_minor_node(dip, "node", S_IFCHR, statep-&gt;minor,
            DDI_PSEUDO, 0) != DDI_SUCCESS) {
            cmn_err(CE_WARN, "%s: ddi_create_minor_node failed on "
                "inst %d\n", myname, inst);
            goto FAIL;
        }
        mutex_init(&amp;statep-&gt;lock, NULL, MUTEX_DRIVER, NULL);
        return (DDI_SUCCESS);
    case DDI_RESUME:
    case DDI_PM_RESUME:
    default:
        break;
    }
    return (DDI_FAILURE);
    /*NOTREACHED*/
FAIL:
    ddi_soft_state_free(lyr_statep, inst);
    ddi_remove_minor_node(dip, NULL);
    return (DDI_FAILURE);
}

static int
lyr_detach(dev_info_t *dip, ddi_detach_cmd_t cmd)
{
    int inst;
    lyr_state_t *statep;
    char *myname = "lyr_detach";

    inst = ddi_get_instance(dip);
    statep = ddi_get_soft_state(lyr_statep, inst);
    if (statep == NULL) {
        cmn_err(CE_WARN, "%s: get soft state failed on "
            "inst %d\n", myname, inst);
        return (DDI_FAILURE);
    }
    if (statep-&gt;dip != dip) {
        cmn_err(CE_WARN, "%s: soft state does not match devinfo "
            "on inst %d\n", myname, inst);
        return (DDI_FAILURE);
    }
    switch (cmd) {
    case DDI_DETACH:
        mutex_destroy(&amp;statep-&gt;lock);
        ddi_soft_state_free(lyr_statep, inst);
        ddi_remove_minor_node(dip, NULL);
        return (DDI_SUCCESS);
    case DDI_SUSPEND:
    case DDI_PM_SUSPEND:
    default:
        break;
    }
    return (DDI_FAILURE);
}
/*
 * on this driver's open, we open the target specified by a property and store
 * the layered handle and ident in our soft state.  a good target would be
 * "/dev/console" or more interestingly, a pseudo terminal as specified by the
 * tty command
 */
/*ARGSUSED*/
static int
lyr_open(dev_t *devtp, int oflag, int otyp, cred_t *credp)
{
    int rv, inst = getminor(*devtp);
    lyr_state_t *statep;
    char *myname = "lyr_open";
    dev_info_t *dip;
    char *lyr_targ = NULL;

    statep = (lyr_state_t *)ddi_get_soft_state(lyr_statep, inst);
    if (statep == NULL) {
        cmn_err(CE_WARN, "%s: ddi_get_soft_state failed on "
            "inst %d\n", myname, inst);
        return (EIO);
    }
    dip = statep-&gt;dip;
    /*
     * our target device to open should be specified by the "lyr_targ"
     * string property, which should be set in this driver's .conf file
     */
    if (ddi_prop_lookup_string(DDI_DEV_T_ANY, dip, DDI_PROP_NOTPROM,
        "lyr_targ", &amp;lyr_targ) != DDI_PROP_SUCCESS) {
        cmn_err(CE_WARN, "%s: ddi_prop_lookup_string failed on "
            "inst %d\n", myname, inst);
        return (EIO);
    }
    /*
     * since we only have one pair of lh's and li's available, we don't
     * allow multiple on the same instance
     */
    mutex_enter(&amp;statep-&gt;lock);
    if (statep-&gt;flags &amp; (LYR_OPENED | LYR_IDENTED)) {
        cmn_err(CE_WARN, "%s: multiple layered opens or idents "
            "from inst %d not allowed\n", myname, inst);
        mutex_exit(&amp;statep-&gt;lock);
        ddi_prop_free(lyr_targ);
        return (EIO);
    }
    rv = ldi_ident_from_dev(*devtp, &amp;statep-&gt;li);
    if (rv != 0) {
        cmn_err(CE_WARN, "%s: ldi_ident_from_dev failed on inst %d\n",
            myname, inst);
        goto FAIL;
    }
    statep-&gt;flags |= LYR_IDENTED;
    rv = ldi_open_by_name(lyr_targ, FREAD | FWRITE, credp, &amp;statep-&gt;lh,
        statep-&gt;li);
    if (rv != 0) {
        cmn_err(CE_WARN, "%s: ldi_open_by_name failed on inst %d\n",
            myname, inst);
        goto FAIL;
    }
    statep-&gt;flags |= LYR_OPENED;
    cmn_err(CE_CONT, "\n%s: opened target '%s' successfully on inst %d\n",
        myname, lyr_targ, inst);
    rv = 0;

FAIL:
    /* cleanup on error */
    if (rv != 0) {
        if (statep-&gt;flags &amp; LYR_OPENED)
            (void)ldi_close(statep-&gt;lh, FREAD | FWRITE, credp);
        if (statep-&gt;flags &amp; LYR_IDENTED)
            ldi_ident_release(statep-&gt;li);
        statep-&gt;flags &amp;= ~(LYR_OPENED | LYR_IDENTED);
    }
    mutex_exit(&amp;statep-&gt;lock);
    if (lyr_targ != NULL)
        ddi_prop_free(lyr_targ);
    return (rv);
}
/*
 * on this driver's close, we close the target indicated by the lh member
 * in our soft state and release the ident, li as well.  in fact, we MUST do
 * both of these at all times even if close yields an error because the
 * device framework effectively closes the device, releasing all data
 * associated with it and simply returning whatever value the target's
 * close(9E) returned.  therefore, we must as well.
 */
/*ARGSUSED*/
static int
lyr_close(dev_t devt, int oflag, int otyp, cred_t *credp)
{
    int rv, inst = getminor(devt);
    lyr_state_t *statep;
    char *myname = "lyr_close";
    statep = (lyr_state_t *)ddi_get_soft_state(lyr_statep, inst);
    if (statep == NULL) {
        cmn_err(CE_WARN, "%s: ddi_get_soft_state failed on "
            "inst %d\n", myname, inst);
        return (EIO);
    }
    mutex_enter(&amp;statep-&gt;lock);
    rv = ldi_close(statep-&gt;lh, FREAD | FWRITE, credp);
    if (rv != 0) {
        cmn_err(CE_WARN, "%s: ldi_close failed on inst %d, but will ",
            "continue to release ident\n", myname, inst);
    }
    ldi_ident_release(statep-&gt;li);
    if (rv == 0) {
        cmn_err(CE_CONT, "\n%s: closed target successfully on "
            "inst %d\n", myname, inst);
    }
    statep-&gt;flags &amp;= ~(LYR_OPENED | LYR_IDENTED);
    mutex_exit(&amp;statep-&gt;lock);
    return (rv);
}
/*
 * echo the data we receive to the target
 */
/*ARGSUSED*/
static int
lyr_write(dev_t devt, struct uio *uiop, cred_t *credp)
{
    int rv, inst = getminor(devt);
    lyr_state_t *statep;
    char *myname = "lyr_write";

    statep = (lyr_state_t *)ddi_get_soft_state(lyr_statep, inst);
    if (statep == NULL) {
        cmn_err(CE_WARN, "%s: ddi_get_soft_state failed on "
            "inst %d\n", myname, inst);
        return (EIO);
    }
    return (ldi_write(statep-&gt;lh, uiop, credp));
}</pre>

<a name="ewpri"></a><h5>How to Build and Load the Layered Driver</h5>
<ol>
<li><b>Compile the driver.</b><p>Use the <tt>-D_KERNEL</tt> option to indicate that this is a kernel module.</p>
<ul><li><p>If you are compiling for a SPARC architecture, use the <tt>-xarch=v9</tt> option:</p><pre>% <tt><b>cc -c -D_KERNEL -xarch=v9 lyr.c</b></tt></pre></li>
<li><p>If you are compiling for a 32-bit x86 architecture, use the following command:</p><pre>% <tt><b>cc -c -D_KERNEL lyr.c</b></tt></pre></li></ul>
</li>
<li><b>Link the driver.</b><pre>% <tt><b>ld -r -o lyr lyr.o</b></tt></pre></li>
<li><b>Install the configuration file.</b><p>As user <tt>root</tt>, copy the configuration file to the kernel driver area of
the machine:</p><pre># <tt><b>cp lyr.conf /usr/kernel/drv</b></tt></pre></li>
<li><b>Install the driver binary.</b>
<ul><li><p>As user <tt>root</tt>, copy the driver binary to the <tt>sparcv9</tt> driver area on a SPARC architecture:</p><pre># <tt><b>cp lyr /usr/kernel/drv/sparcv9</b></tt></pre></li>
<li><p>As user <tt>root</tt>, copy the driver binary to the <tt>drv</tt> driver area on a 32-bit x86 architecture:</p><pre># <tt><b>cp lyr /usr/kernel/drv</b></tt></pre></li></ul>
</li>
<li><b><a name="indexterm-531"></a>Load the driver.</b><p>As user <tt>root</tt>, use the <a href="http://docs.sun.com/doc/819-2240/add-drv-1m?a=view"><tt>add_drv</tt>(1M)</a> command to load the driver.</p><pre># <tt><b>add_drv lyr</b></tt></pre><p>List the pseudo devices to confirm that the <tt>lyr</tt> device now exists:</p><pre># <tt><b>ls /devices/pseudo | grep lyr</b></tt>
lyr@1
lyr@1:node</pre></li></ol>

<a name="euihe"></a><h5>Test the Layered Driver</h5>
<p>To test the <tt>lyr</tt> driver, write a message to the <tt>lyr</tt> device
and verify that the message displays on the <tt>lyr_targ</tt> device.</p><a name="exegr"></a><h6>Example&nbsp;14-3 Write a Short Message to the Layered Device</h6><p>In this example, the <tt>lyr_targ</tt> device is the console of the system where
the <tt>lyr</tt> device is installed.</p><p>If the display you are viewing is also the display for the
console device of the system where the <tt>lyr</tt> device is installed, note that writing
to the console will corrupt your display. The console messages will appear outside
your window system. You will need to redraw or refresh your display after
testing the <tt>lyr</tt> driver.</p><p>If the display you are viewing is not the display for the
console device of the system where the <tt>lyr</tt> device is installed, log into or
otherwise gain a view of the display of the target console device.</p><p>The following command writes a very brief message to the <tt>lyr</tt> device:</p><pre># <tt><b>echo "\n\n\t===&gt; Hello World!! &lt;===\n" &gt; /devices/pseudo/lyr@1:node</b></tt></pre><p>You should see the following messages displayed on the target console:</p><pre>console login:

    ===&gt; Hello World!! &lt;===

lyr: 
lyr_open: opened target '/dev/console' successfully on inst 1
lyr: 
lyr_close: closed target successfully on inst 1</pre><p><a name="indexterm-532"></a>The messages from <tt>lyr_open()</tt> and <tt>lyr_close()</tt> come from the <a href="http://docs.sun.com/doc/819-2256/cmn-err-9f?a=view"><tt>cmn_err</tt>(9F)</a> calls in the
<tt>lyr_open()</tt> and <tt>lyr_close()</tt> entry points.</p><a name="exegt"></a><h6>Example&nbsp;14-4 Write a Longer Message to the Layered Device</h6><p>The following command writes a longer message to the <tt>lyr</tt> device:</p><pre># <tt><b>cat lyr.conf &gt; /devices/pseudo/lyr@1:node</b></tt></pre><p>You should see the following messages displayed on the target console:</p><pre>lyr: 
lyr_open: opened target '/dev/console' successfully on inst 1
#
# Copyright 2004 Sun Microsystems, Inc.  All rights reserved.
# Use is subject to license terms.
#
#pragma ident   "%Z%%M% %I%     %E% SMI"

name="lyr" parent="pseudo" instance=1;
lyr_targ="/dev/console";
lyr: 
lyr_close: closed target successfully on inst 1</pre><a name="exegu"></a><h6>Example&nbsp;14-5 Change the Target Device</h6><p><a name="indexterm-533"></a><a name="indexterm-534"></a>To change the target device, edit <tt>/usr/kernel/drv/lyr.conf</tt> and change the value of the
<tt>lyr_targ</tt> property to be a path to a different target device. For example,
the target device could be the output of a <tt>tty</tt> command in a
local terminal. An example of such a device path is <tt>/dev/pts/4</tt>.</p><p>Make sure the <tt>lyr</tt> device is not in use before you update the
driver to use the new target device.</p><pre># <tt><b>modinfo -c | grep lyr</b></tt>
174          3 lyr                              UNLOADED/UNINSTALLED</pre><p>Use the <a href="http://docs.sun.com/doc/819-2240/update-drv-1m?a=view"><tt>update_drv</tt>(1M)</a> command to reload the <tt>lyr.conf</tt> configuration file:</p><pre># <tt><b>update_drv lyr</b></tt></pre><p>Write a message to the <tt>lyr</tt> device again and verify that the message
displays on the new <tt>lyr_targ</tt> device.</p>
         </div>
      </td>
   </tr>

   <tr class="PageControls" valign="top">
      <td></td>
      <td>
         <table width="100%">
      	   <tr>
      	     <td>
                 <a href="ewpre.html">Previous</a>
             </td>
             <td align="right">
                 <a href="ldi-5.html">Next</a>
             </td>
           </tr>
         </table>
      </td>
   </tr>
</tbody>
</table>


</body>
</html>

