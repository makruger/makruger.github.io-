<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="en-US">
<head>
<meta http-equiv="Content-type" content="text/html; charset=iso-8859-1">
<title>Synchronous Data Transfers (Block Drivers) - Writing Device Drivers</title>
<meta name="robots" content="index,follow">
<meta name="robots" content="index,follow">
<meta name="date" content="2008-08-01">
<meta name="collection" content="reference">
<link rel="stylesheet" type="text/css" href="css/elements.css">
<link rel="stylesheet" type="text/css" href="css/indiana.css">
</head>

<body>


<div class="Masthead">
   <div class="MastheadLogo">
      <a href="http://www.opensolaris.org"><img border="0" src="graphics/header.png"></img></a>
   </div>
   <div class="Title">Writing Device Drivers</div>
</div>

<table class="Layout" border="0" cellspacing="0" width="100%">
<tbody>

   <tr valign="top" class="PageControls">
      <td></td>
      <td>
         <table width="100%">
      	   <tr>
      	     <td>
                 <a href="block-6.html">Previous</a>
             </td>
             <td align="right">
                 <a href="block-54698.html">Next</a>
             </td>
           </tr>
         </table>
      </td>
   </tr>
   
   <tr valign="top">
      <td class="Navigation" width="200px"><p class="toc level1"><a href="docinfo.html">Document Information</a></p>
<p class="toc level1 tocsp"><a href="preface-1.html">Preface</a></p>
<p class="toc level1 tocsp"><a href="eqbvu.html">Part&nbsp;I&nbsp;Designing Device Drivers for the Solaris Platform</a></p>
<p class="toc level2"><a href="eqbqn.html">1.&nbsp;&nbsp;Overview of Solaris Device Drivers</a></p>
<p class="toc level2"><a href="kernelovr-77198.html">2.&nbsp;&nbsp;Solaris Kernel and Device Tree</a></p>
<p class="toc level2"><a href="mt-17026.html">3.&nbsp;&nbsp;Multithreading</a></p>
<p class="toc level2"><a href="properties-1.html">4.&nbsp;&nbsp;Properties</a></p>
<p class="toc level2"><a href="events-1.html">5.&nbsp;&nbsp;Managing Events and Queueing Tasks</a></p>
<p class="toc level2"><a href="autoconf-17.html">6.&nbsp;&nbsp;Driver Autoconfiguration</a></p>
<p class="toc level2"><a href="devaccess-3.html">7.&nbsp;&nbsp;Device Access: Programmed I/O</a></p>
<p class="toc level2"><a href="interrupt-15678.html">8.&nbsp;&nbsp;Interrupt Handlers</a></p>
<p class="toc level2"><a href="dma-29901.html">9.&nbsp;&nbsp;Direct Memory Access (DMA)</a></p>
<p class="toc level2"><a href="devmap-24338.html">10.&nbsp;&nbsp;Mapping Device and Kernel Memory</a></p>
<p class="toc level2"><a href="devcnmgt-19679.html">11.&nbsp;&nbsp;Device Context Management</a></p>
<p class="toc level2"><a href="powermgt-37437.html">12.&nbsp;&nbsp;Power Management</a></p>
<p class="toc level2"><a href="gevsi.html">13.&nbsp;&nbsp;Hardening Solaris Drivers</a></p>
<p class="toc level2"><a href="ldi-1.html">14.&nbsp;&nbsp;Layered Driver Interface (LDI)</a></p>
<p class="toc level1 tocsp"><a href="eqbvb.html">Part&nbsp;II&nbsp;Designing Specific Kinds of Device Drivers</a></p>
<p class="toc level2"><a href="character-21002.html">15.&nbsp;&nbsp;Drivers for Character Devices</a></p>
<p class="toc level2"><a href="block-34861.html">16.&nbsp;&nbsp;Drivers for Block Devices</a></p>
<p class="toc level3"><a href="block-1.html">Block Driver Structure Overview</a></p>
<p class="toc level3"><a href="block-82249.html">File I/O</a></p>
<p class="toc level3"><a href="block-5.html">Block Device Autoconfiguration</a></p>
<p class="toc level3"><a href="block-6.html">Controlling Device Access</a></p>
<div class="onpage">
<p class="toc level3"><a href="">Synchronous Data Transfers (Block Drivers)</a></p>
</div>
<p class="toc level3"><a href="block-54698.html">Asynchronous Data Transfers (Block Drivers)</a></p>
<p class="toc level3"><a href="block-25.html"><tt>dump()</tt> and <tt>print()</tt> Entry Points</a></p>
<p class="toc level3"><a href="advanced-7.html">Disk Device Drivers</a></p>
<p class="toc level2 tocsp"><a href="scsi-36812.html">17.&nbsp;&nbsp;SCSI Target Drivers</a></p>
<p class="toc level2"><a href="scsihba-32898.html">18.&nbsp;&nbsp;SCSI Host Bus Adapter Drivers</a></p>
<p class="toc level2"><a href="gld-1.html">19.&nbsp;&nbsp;Drivers for Network Devices</a></p>
<p class="toc level2"><a href="usb-1.html">20.&nbsp;&nbsp;USB Drivers</a></p>
<p class="toc level1 tocsp"><a href="eqbvo.html">Part&nbsp;III&nbsp;Building a Device Driver</a></p>
<p class="toc level2"><a href="loading-15035.html">21.&nbsp;&nbsp;Compiling, Loading, Packaging, and Testing Drivers</a></p>
<p class="toc level2"><a href="debug-60.html">22.&nbsp;&nbsp;Debugging, Testing, and Tuning Device Drivers</a></p>
<p class="toc level2"><a href="coding-practices.html">23.&nbsp;&nbsp;Recommended Coding Practices</a></p>
<p class="toc level1 tocsp"><a href="eqbva.html">Part&nbsp;IV&nbsp;Appendixes</a></p>
<p class="toc level2"><a href="hwovr-18191.html">A.&nbsp;&nbsp;Hardware Overview</a></p>
<p class="toc level2"><a href="ddidkisvc-29227.html">B.&nbsp;&nbsp;Summary of Solaris DDI/DKI Services</a></p>
<p class="toc level2"><a href="lp64-35004.html">C.&nbsp;&nbsp;Making a Device Driver 64-Bit Ready</a></p>
<p class="toc level2"><a href="euazz.html">D.&nbsp;&nbsp;Console Frame Buffer Drivers</a></p>
<p class="toc level1 tocsp"><a href="idx-1.html">Index</a></p>
</td>
      <td class="ContentPane" width="705px">

	 <div class="MainContent">      	 
             

<a name="block-78892"></a><h3>Synchronous Data Transfers (Block Drivers)</h3>
<p><a name="block-ix437"></a><a name="indexterm-587"></a>This section presents a simple method for performing synchronous I/O transfers. This method assumes
that the hardware is a simple disk device that can transfer only
one data buffer at a time by using DMA. Another assumption is that
the disk can be spun up and spun down by software command. The
device driver's  <a href="http://docs.sun.com/doc/819-2255/strategy-9e?a=view"><tt>strategy</tt>(9E)</a> routine waits for the current request to be completed
before accepting a new request. The device interrupts when the transfer is complete.
The device also interrupts if an error occurs.</p><p>The steps for performing a synchronous data transfer for a block driver are
as follows:</p>
<ol><li><p>Check for invalid <a href="http://docs.sun.com/doc/819-2257/buf-9s?a=view"><tt>buf</tt>(9S)</a> requests.</p><p>Check the <a href="http://docs.sun.com/doc/819-2257/buf-9s?a=view"><tt>buf</tt>(9S)</a> structure that is passed to <a href="http://docs.sun.com/doc/819-2255/strategy-9e?a=view"><tt>strategy</tt>(9E)</a> for validity. All drivers should check the following conditions:</p>
<ul><li><p>The request begins at a valid block. The driver converts the <tt>b_blkno</tt> field to the correct device offset and then determines whether the offset is valid for the device.</p></li>
<li><p>The request does not go beyond the last block on the device.</p></li>
<li><p>Device-specific requirements are met.</p></li></ul>
<p><a name="block-ix438"></a>If an error is encountered, the driver should indicate the appropriate error with <a href="http://docs.sun.com/doc/819-2256/bioerror-9f?a=view"><tt>bioerror</tt>(9F)</a>. The driver should then complete the request by calling <a href="http://docs.sun.com/doc/819-2256/biodone-9f?a=view"><tt>biodone</tt>(9F)</a>. <tt>biodone()</tt> notifies the caller of <a href="http://docs.sun.com/doc/819-2255/strategy-9e?a=view"><tt>strategy</tt>(9E)</a> that the transfer is complete. In this case, the transfer has stopped because of an error.</p></li>
<li><p>Check whether the device is busy.</p><p>Synchronous data transfers allow single-threaded access to the device. The device driver enforces this access in two ways:</p>
<ul><li><p>The driver maintains a busy flag that is guarded by a mutex.</p></li>
<li><p>The driver waits on a condition variable with <a href="http://docs.sun.com/doc/819-2256/cv-wait-9f?a=view"><tt>cv_wait</tt>(9F)</a>, when the device is busy.</p></li></ul>
<p>If the device is busy, the thread waits until the interrupt handler indicates that the device is not longer busy. The available status can be indicated by either the <a href="http://docs.sun.com/doc/819-2256/cv-broadcast-9f?a=view"><tt>cv_broadcast</tt>(9F)</a> or the <a href="http://docs.sun.com/doc/819-2256/cv-signal-9f?a=view"><tt>cv_signal</tt>(9F)</a> function.  See <a href="mt-17026.html">Chapter&nbsp;3, Multithreading</a> for details on condition variables.</p><p>When the device is no longer busy, the <a href="http://docs.sun.com/doc/819-2255/strategy-9e?a=view"><tt>strategy</tt>(9E)</a> routine marks the device as available. <tt>strategy()</tt> then prepares the buffer and the device for the transfer.</p></li>
<li><p>Set up the buffer for DMA.</p><p>Prepare the data buffer for a DMA transfer by using <a href="http://docs.sun.com/doc/819-2256/ddi-dma-alloc-handle-9f?a=view"><tt>ddi_dma_alloc_handle</tt>(9F)</a> to allocate a DMA handle. Use <a href="http://docs.sun.com/doc/819-2256/ddi-dma-buf-bind-handle-9f?a=view"><tt>ddi_dma_buf_bind_handle</tt>(9F)</a> to bind the data buffer to the handle. For information on setting up DMA resources and related data structures, see <a href="dma-29901.html">Chapter&nbsp;9, Direct Memory Access (DMA)</a>.</p></li>
<li><p>Begin the transfer.</p><p>At this point, a pointer to the <a href="http://docs.sun.com/doc/819-2257/buf-9s?a=view"><tt>buf</tt>(9S)</a> structure is saved in the state structure of the device. The interrupt routine can then complete the transfer by calling <a href="http://docs.sun.com/doc/819-2256/biodone-9f?a=view"><tt>biodone</tt>(9F)</a>.</p><p>The device driver then accesses device registers to initiate a data transfer. In most cases, the driver should protect the device registers from other threads by using mutexes. In this case, because <a href="http://docs.sun.com/doc/819-2255/strategy-9e?a=view"><tt>strategy</tt>(9E)</a> is single-threaded, guarding the device registers is not necessary. See <a href="mt-17026.html">Chapter&nbsp;3, Multithreading</a> for details about data locks.</p><p>When the executing thread has started the device's DMA engine, the driver can return execution control to the calling routine, as follows:</p><pre>static int
xxstrategy(struct buf *bp)
{
    struct xxstate *xsp;
    struct device_reg *regp;
    minor_t instance;
    ddi_dma_cookie_t cookie;
    instance = getminor(bp-&gt;b_edev);
    xsp = ddi_get_soft_state(statep, instance);
    if (xsp == NULL) {
        bioerror(bp, ENXIO);
        biodone(bp);
        return (0);
    }
    /* validate the transfer request */
    if ((bp-&gt;b_blkno &gt;= xsp-&gt;Nblocks) || (bp-&gt;b_blkno &lt; 0)) {
        bioerror(bp, EINVAL);    
        biodone(bp);
        return (0);
    }
    /*
     * Hold off all threads until the device is not busy.
     */
    mutex_enter(&amp;xsp-&gt;mu);
    while (xsp-&gt;busy) {
        cv_wait(&amp;xsp-&gt;cv, &amp;xsp-&gt;mu);
    }
    xsp-&gt;busy = 1;
    mutex_exit(&amp;xsp-&gt;mu);
    /* 
     * If the device has power manageable components, 
     * mark the device busy with pm_busy_components(9F),
     * and then ensure that the device 
     * is powered up by calling pm_raise_power(9F).
     *
     * Set up DMA resources with ddi_dma_alloc_handle(9F) and
     * ddi_dma_buf_bind_handle(9F).
     */
    xsp-&gt;bp = bp;
    regp = xsp-&gt;regp;
    ddi_put32(xsp-&gt;data_access_handle, &amp;regp-&gt;dma_addr,
        cookie.dmac_address);
    ddi_put32(xsp-&gt;data_access_handle, &amp;regp-&gt;dma_size,
        (uint32_t)cookie.dmac_size);
    ddi_put8(xsp-&gt;data_access_handle, &amp;regp-&gt;csr,
        ENABLE_INTERRUPTS | START_TRANSFER);
    return (0);
}</pre></li>
<li><p>Handle the interrupting device.</p><p>When the device finishes the data transfer, the driver generates an interrupt, which eventually results in the driver's interrupt routine being called. Most drivers specify the state structure of the device as the argument to the interrupt routine when registering interrupts. See the <a href="http://docs.sun.com/doc/819-2256/ddi-add-intr-9f?a=view"><tt>ddi_add_intr</tt>(9F)</a> man page and <a href="interrupt-14.html">Registering Interrupts</a>. The interrupt routine can then access the <a href="http://docs.sun.com/doc/819-2257/buf-9s?a=view"><tt>buf</tt>(9S)</a> structure being transferred, plus any other information that is available from the state structure.</p><p>The interrupt handler should check the device's status register to determine whether the transfer completed without error. If an error occurred, the handler should indicate the appropriate error with <a href="http://docs.sun.com/doc/819-2256/bioerror-9f?a=view"><tt>bioerror</tt>(9F)</a>. The handler should also clear the pending interrupt for the device and then complete the transfer by calling <a href="http://docs.sun.com/doc/819-2256/biodone-9f?a=view"><tt>biodone</tt>(9F)</a>.</p><p>As the final task, the handler clears the busy flag. The handler then calls <a href="http://docs.sun.com/doc/819-2256/cv-signal-9f?a=view"><tt>cv_signal</tt>(9F)</a> or <a href="http://docs.sun.com/doc/819-2256/cv-broadcast-9f?a=view"><tt>cv_broadcast</tt>(9F)</a> on the condition variable, signaling that the device is no longer busy. This notification enables other threads waiting for the device in <a href="http://docs.sun.com/doc/819-2255/strategy-9e?a=view"><tt>strategy</tt>(9E)</a> to proceed with the next data transfer.</p><p>The following example shows a synchronous interrupt routine.</p></li></ol>
<a name="block-ex-19"></a><h6>Example&nbsp;16-4 Synchronous Interrupt Routine for Block Drivers</h6><pre>static u_int
xxintr(caddr_t arg)
{
    struct xxstate *xsp = (struct xxstate *)arg;
    struct buf *bp;
    uint8_t status;
    mutex_enter(&amp;xsp-&gt;mu);
    status = ddi_get8(xsp-&gt;data_access_handle, &amp;xsp-&gt;regp-&gt;csr);
    if (!(status &amp; INTERRUPTING)) {
        mutex_exit(&amp;xsp-&gt;mu);
        return (DDI_INTR_UNCLAIMED);
    }
    /* Get the buf responsible for this interrupt */
    bp = xsp-&gt;bp;
    xsp-&gt;bp = NULL;
    /*
     * This example is for a simple device which either
     * succeeds or fails the data transfer, indicated in the
     * command/status register.
     */
    if (status &amp; DEVICE_ERROR) {
        /* failure */
        bp-&gt;b_resid = bp-&gt;b_bcount;
        bioerror(bp, EIO);
    } else {
        /* success */
        bp-&gt;b_resid = 0;
    }
    ddi_put8(xsp-&gt;data_access_handle, &amp;xsp-&gt;regp-&gt;csr,
        CLEAR_INTERRUPT);
    /* The transfer has finished, successfully or not */
    biodone(bp);
    /*
     * If the device has power manageable components that were
     * marked busy in strategy(9F), mark them idle now with
     * pm_idle_component(9F)
     * Release any resources used in the transfer, such as DMA
     * resources ddi_dma_unbind_handle(9F) and
     * ddi_dma_free_handle(9F).
     *
     * Let the next I/O thread have access to the device.
     */
    xsp-&gt;busy = 0;
    cv_signal(&amp;xsp-&gt;cv);
    mutex_exit(&amp;xsp-&gt;mu);
    return (DDI_INTR_CLAIMED);
}</pre>
         </div>
      </td>
   </tr>

   <tr class="PageControls" valign="top">
      <td></td>
      <td>
         <table width="100%">
      	   <tr>
      	     <td>
                 <a href="block-6.html">Previous</a>
             </td>
             <td align="right">
                 <a href="block-54698.html">Next</a>
             </td>
           </tr>
         </table>
      </td>
   </tr>
</tbody>
</table>


</body>
</html>

