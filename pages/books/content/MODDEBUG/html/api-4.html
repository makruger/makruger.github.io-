<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="en-US">
<head>
<meta http-equiv="Content-type" content="text/html; charset=iso-8859-1">
<title>API Functions - Solaris Modular Debugger Guide</title>
<meta name="robots" content="index,follow">
<meta name="robots" content="index,follow">
<meta name="date" content="2008-10-01">
<meta name="collection" content="reference">
<link rel="stylesheet" type="text/css" href="css/elements.css">
<link rel="stylesheet" type="text/css" href="css/indiana.css">
</head>

<body>


<div class="Masthead">
   <div class="MastheadLogo">
      <a href="http://www.opensolaris.org"><img border="0" src="graphics/header.png"></img></a>
   </div>
   <div class="Title">Solaris Modular Debugger Guide</div>
</div>

<table class="Layout" border="0" cellspacing="0" width="100%">
<tbody>

   <tr valign="top" class="PageControls">
      <td></td>
      <td>
         <table width="100%">
      	   <tr>
      	     <td>
                 <a href="api-3.html">Previous</a>
             </td>
             <td align="right">
                 <a href="options-1.html">Next</a>
             </td>
           </tr>
         </table>
      </td>
   </tr>
   
   <tr valign="top">
      <td class="Navigation" width="200px"><p class="toc level1"><a href="docinfo.html">Document Information</a></p>
<p class="toc level1 tocsp"><a href="preface-1.html">Preface</a></p>
<p class="toc level1 tocsp"><a href="intro-1.html">1.&nbsp;&nbsp;Modular Debugger Overview</a></p>
<p class="toc level1 tocsp"><a href="concepts-1.html">2.&nbsp;&nbsp;Debugger Concepts</a></p>
<p class="toc level1 tocsp"><a href="syntax-7.html">3.&nbsp;&nbsp;MDB Language Syntax</a></p>
<p class="toc level1 tocsp"><a href="interaction-3.html">4.&nbsp;&nbsp;Using MDB Commands Interactively</a></p>
<p class="toc level1 tocsp"><a href="commands-1.html">5.&nbsp;&nbsp;Built-In Commands</a></p>
<p class="toc level1 tocsp"><a href="chp-exec.html">6.&nbsp;&nbsp;Execution Control</a></p>
<p class="toc level1 tocsp"><a href="chp-kmdb.html">7.&nbsp;&nbsp;Kernel Execution Control</a></p>
<p class="toc level1 tocsp"><a href="modules-1.html">8.&nbsp;&nbsp;Kernel Debugging Modules</a></p>
<p class="toc level1 tocsp"><a href="kmem-1.html">9.&nbsp;&nbsp;Debugging With the Kernel Memory Allocator</a></p>
<p class="toc level1 tocsp"><a href="api-5.html">10.&nbsp;&nbsp;Module Programming API</a></p>
<p class="toc level2"><a href="api-1.html">Debugger Module Linkage</a></p>
<p class="toc level2"><a href="api-2.html">Dcmd Definitions</a></p>
<p class="toc level2"><a href="api-3.html">Walker Definitions</a></p>
<div class="onpage">
<p class="toc level2"><a href="">API Functions</a></p>
</div>
<p class="toc level1 tocsp"><a href="options-1.html">A.&nbsp;&nbsp;Options</a></p>
<p class="toc level1 tocsp"><a href="notes-1.html">B.&nbsp;&nbsp;Notes</a></p>
<p class="toc level1 tocsp"><a href="adb-trans-1.html">C.&nbsp;&nbsp;Transition From <tt>adb</tt> and <tt>kadb</tt></a></p>
<p class="toc level1 tocsp"><a href="crash-4.html">D.&nbsp;&nbsp;Transition From <tt>crash</tt></a></p>
<p class="toc level1 tocsp"><a href="idx-1.html">Index</a></p>
</td>
      <td class="ContentPane" width="705px">

	 <div class="MainContent">      	 
             

<a name="api-4"></a><h3>API Functions</h3>


<a name="api-43"></a><h4><tt>mdb_pwalk()</tt></h4>
<pre>int mdb_pwalk(const char *name, mdb_walk_cb_t func, void *data,
              uintptr_t addr);</pre><p><a name="indexterm-508"></a>Initiate a local walk starting at <i>addr</i> using the walker specified by <i>name</i>, and
invoke the callback function <i>func</i> at each step.  If <i>addr</i> is
NULL, a global walk is performed (that is, the <tt>mdb_pwalk()</tt> invocation is equivalent to
the identical call to <tt>mdb_walk()</tt> without the trailing <i>addr</i> parameter).  This function
returns 0 for success, or -1 for error.  The <tt>mdb_pwalk()</tt> function fails if
the walker itself returns a fatal error, or if the specified walker name
is not known to the debugger. The walker name may be scoped
using the backquote (<tt>`</tt>) operator if there are naming conflicts. The <i>data</i> parameter
is an opaque argument that has meaning only to the caller; it is
passed back to <i>func</i> at each step of the walk.</p>

<a name="api-42"></a><h4><tt>mdb_walk()</tt></h4>
<pre>int mdb_walk(const char *name, mdb_walk_cb_t func, void *data);</pre><p><a name="indexterm-509"></a>Initiate a global walk starting at <i>addr</i> using the walker specified by <i>name</i>, and
invoke the callback function <i>func</i> at each step.  This function returns
0 for success, or -1 for error.  The <tt>mdb_walk()</tt> function fails if
the walker itself returns a fatal error, or if the specified walker name
is not known to the debugger. The walker name can be scoped using
the backquote (<tt>`</tt>) operator if there are naming conflicts. The data parameter is
an opaque argument that has meaning only to the caller; it is passed
back to <i>func</i> at each step of the walk.</p>

<a name="api-41"></a><h4><tt>mdb_pwalk_dcmd()</tt></h4>
<pre>int mdb_pwalk_dcmd(const char *wname, const char *dcname, int argc,
            const mdb_arg_t *argv, uintptr_t addr);</pre><p><a name="indexterm-510"></a>Initiate a local walk starting at <i>addr</i> using the walker specified by <i>wname</i>,
and invoke the dcmd specified by <i>dcname</i> with the specified <i>argc</i> and <i>argv</i>
at each step. This function returns 0 for success, or -1 for error.
 The function fails if the walker itself returns a fatal error, if
the specified walker name or dcmd name is not known to the debugger,
or if the dcmd itself returns <tt>DCMD_ABORT</tt> or <tt>DCMD_USAGE</tt> to the walker.
The walker name and dcmd name can each be scoped using the backquote
(<tt>`</tt>) operator if there are naming conflicts.  When invoked from <tt>mdb_pwalk_dcmd()</tt>, the dcmd
will have the <tt>DCMD_LOOP</tt> and <tt>DCMD_ADDRSPEC</tt> bits set in its flags parameter, and
the first call will have <tt>DCMD_LOOPFIRST</tt> set.</p>

<a name="api-44"></a><h4><tt>mdb_walk_dcmd()</tt></h4>
<pre>int mdb_walk_dcmd(const char *wname, const char *dcname, int argc,
            const mdb_arg_t *argv);</pre><p><a name="indexterm-511"></a>Initiate a global walk using the walker specified by <i>wname</i>, and invoke
the dcmd specified by <i>dcname</i> with the specified <i>argc</i> and <i>argv</i> at each step.
 This function returns 0 for success, or -1 for error. The
function fails if the walker itself returns a fatal error, if the specified
walker name or dcmd name is not known to the debugger, or if
the dcmd itself returns <tt>DCMD_ABORT</tt> or <tt>DCMD_USAGE</tt> to the walker. The walker name
and dcmd name can each be scoped using the backquote (<tt>`</tt>) operator if
there are naming conflicts.  When invoked from <tt>mdb_walk_dcmd()</tt>, the dcmd will
have the <tt>DCMD_LOOP</tt> and <tt>DCMD_ADDRSPEC</tt> bits set in its flags parameter, and
the first call will have <tt>DCMD_LOOPFIRST</tt> set.</p>

<a name="api-45"></a><h4><tt>mdb_call_dcmd()</tt></h4>
<pre>int mdb_call_dcmd(const char *name, uintptr_t addr, uint_t flags, 
            int argc, const mdb_arg_t *argv);</pre><p><a name="indexterm-512"></a>Invoke the specified dcmd name with the given parameters.  The dot variable
is reset to <i>addr</i>, and <i>addr</i>, <i>flags</i>, <i>argc</i>, and <i>argv</i> are passed to
the dcmd.  The function returns 0 for success, or -1 for
error. The function fails if the dcmd returns <tt>DCMD_ERR</tt>, <tt>DCMD_ABORT</tt>, or <tt>DCMD_USAGE</tt>, or
if the specified dcmd name is not known to the debugger.  The
dcmd name can be scoped using the backquote (<tt>`</tt>) operator if there are
naming conflicts.</p>

<a name="api-46"></a><h4><tt>mdb_layered_walk()</tt></h4>
<pre>int mdb_layered_walk(const char *name, mdb_walk_state_t *wsp);</pre><p><a name="indexterm-513"></a>Layer the walk denoted by <i>wsp</i> on top of a walk initiated using
the specified walker <i>name</i>. The name can be scoped using the backquote (<tt>`</tt>)
operator if there are naming conflicts. Layered walks can be used, for example,
to facilitate constructing walkers for data structures that are embedded in other data structures.
</p><p>For example, suppose that each CPU structure in the kernel contains a pointer
to an embedded structure. To write a walker for the embedded structure type,
you could replicate the code to iterate over CPU structures and dereference the
appropriate member of each CPU structure, or you could layer the embedded structure's
walker on top of the existing CPU walker.</p><p>The <tt>mdb_layered_walk()</tt> function is used from within a walker's init routine to add
a new layer to the current walk.  The underlying layer is initialized
as part of the call to <tt>mdb_layered_walk()</tt>. The calling walk routine passes in
a pointer to its current walk state; this state is used to construct
the layered walk. Each layered walk is cleaned up after the caller's walk
fini function is called.  If more than one layer is added to
a walk, the caller's walk step function will step through each element returned
by the first layer, then the second layer, and so forth.</p><p>The <tt>mdb_layered_walk()</tt> function returns 0 for success, or -1 for error. The function
fails if the specified walker name is not known to the debugger, if
the <i>wsp</i> pointer is not a valid, active walk state pointer, if the
layered walker itself fails to initialize, or if the caller attempts to layer
the walker on top of itself.</p>

<a name="api-37"></a><h4><tt>mdb_add_walker()</tt></h4>
<pre>int mdb_add_walker(const mdb_walker_t *w);</pre><p><a name="indexterm-514"></a>Register a new walker with the debugger. The walker is added to the
module's namespace, and to the debugger's global namespace according to the name resolution
rules described in <a href="syntax-13.html">Dcmd and Walker Name Resolution</a>. This function returns 0 for success, or -1 for
error if the given walker name is already registered by this module,
or if the walker structure <i>w</i> is improperly constructed. The information in the <tt>mdb_walker_t</tt>
<i>w</i> is copied to internal debugger structures, so the caller can reuse or
free this structure after the call to <tt>mdb_add_walker()</tt>.     
            </p>

<a name="api-36"></a><h4><tt>mdb_remove_walker()</tt></h4>
<pre>int mdb_remove_walker(const char *name);</pre><p><a name="indexterm-515"></a>Remove the walker with the specified <i>name</i>. This function returns 0 for success,
or -1 for error. The walker is removed from the current module's namespace.
The function fails if the walker name is unknown, or is registered only
in another module's namespace. The <tt>mdb_remove_walker()</tt> function can be used to remove
walkers that were added dynamically using <tt>mdb_add_walker()</tt>, or walkers that were added statically as
part of the module's linkage structure. The scoping operator cannot be used in
the walker name; it is not legal for the caller of <tt>mdb_remove_walker()</tt>
to attempt to remove a walker exported by a different module.</p>

<a name="api-35"></a><h4><tt>mdb_vread()</tt> and <tt>mdb_vwrite()</tt></h4>
<pre>ssize_t mdb_vread(void *buf, size_t nbytes, uintptr_t addr);
ssize_t mdb_vwrite(const void *buf, size_t nbytes, uintptr_t addr);</pre><p><a name="indexterm-516"></a><a name="indexterm-517"></a>These functions provide the ability to read and write data from a given
target virtual address, specified by the <i>addr</i> parameter. The <tt>mdb_vread()</tt> function returns <i>nbytes</i>
for success, or -1 for error; if a read is truncated because only
a portion of the data can be read from the specified address, -1
is returned. The <tt>mdb_vwrite()</tt> function returns the number of bytes actually written upon
success; -1 is returned upon error.</p>

<a name="api-59"></a><h4><tt>mdb_fread()</tt> and <tt>mdb_fwrite()</tt></h4>
<pre>ssize_t mdb_fread(void *buf, size_t nbytes, uintptr_t addr);
ssize_t mdb_fwrite(const void *buf, size_t nbytes, uintptr_t addr);</pre><p><a name="indexterm-518"></a><a name="indexterm-519"></a>These functions provide the ability to read and write data from the object
file location corresponding to the given target virtual address, specified by the <tt>addr</tt>
parameter.  The <tt>mdb_fread()</tt> function returns <tt>nbytes</tt> for success, or -1 for error; if
a read is truncated because only a portion of the data can be
read from the specified address, -1 is returned.  The <tt>mdb_fwrite()</tt> function
returns the number of bytes actually written upon success; -1 is returned upon
error.</p>

<a name="api-34"></a><h4><tt>mdb_pread()</tt> and <tt>mdb_pwrite()</tt></h4>
<pre>ssize_t mdb_pread(void *buf, size_t nbytes, uint64_t addr);
ssize_t mdb_pwrite(const void *buf, size_t nbytes, uint64_t addr);</pre><p><a name="indexterm-520"></a><a name="indexterm-521"></a>These functions provide the ability to read and write data from a given
target physical address, specified by the <i>addr</i> parameter. The <tt>mdb_pread()</tt> function returns <i>nbytes</i>
for success, or -1 for error; if a read is truncated because only
a portion of the data can be read from the specified address, -1
is returned. The <tt>mdb_pwrite()</tt> function returns the number of bytes actually written upon
success; -1 is returned upon error.</p>

<a name="api-33"></a><h4><tt>mdb_readstr()</tt></h4>
<pre>ssize_t mdb_readstr(char *s, size_t nbytes, uintptr_t addr);</pre><p><a name="indexterm-522"></a>The <tt>mdb_readstr()</tt> function reads a null-terminated C string beginning at the target virtual
address <i>addr</i> into the buffer addressed by <i>s</i>. The size of the buffer
is specified by <i>nbytes</i>. If the string is longer than can fit in the
buffer, the string is truncated to the buffer size and a null
byte is stored at <tt>s[nbytes - 1]</tt>. The length of the string stored in <i>s</i> (not
including the terminating null byte) is returned upon success; otherwise -1 is returned
to indicate an error.</p>

<a name="api-32"></a><h4><tt>mdb_writestr()</tt></h4>
<pre>ssize_t mdb_writestr(const char *s, uintptr_t addr);</pre><p><a name="indexterm-523"></a>The <tt>mdb_writestr()</tt> function writes a null-terminated C string from <i>s</i> (including the trailing
null byte) to the target's virtual address space at the address specified by
<i>addr</i>. The number of bytes written (not including the terminating null byte) is
returned upon success; otherwise, -1 is returned to indicate an error.</p>

<a name="api-47"></a><h4><tt>mdb_readsym()</tt></h4>
<pre>ssize_t mdb_readsym(void *buf, size_t nbytes, const char *name);</pre><p><a name="indexterm-524"></a><tt>mdb_readsym()</tt> is similar to <tt>mdb_vread()</tt>, except that the virtual address at which reading
begins is obtained from the value of the symbol specified by <i>name</i>. If
no symbol by that name is found or a read error occurs, -1
is returned; otherwise <i>nbytes</i> is returned for success. </p><p>The caller can first look up the symbol separately if it is
necessary to distinguish between symbol lookup failure and read failure. The primary executable's symbol
table is used for the symbol lookup; if the symbol resides in another
symbol table, you must first apply <tt>mdb_lookup_by_obj()</tt>, then <tt>mdb_vread()</tt>.</p>

<a name="api-30"></a><h4><tt>mdb_writesym()</tt></h4>
<pre>ssize_t mdb_writesym(const void *buf, size_t nbytes, const char *name);</pre><p><a name="indexterm-525"></a><tt>mdb_writesym()</tt> is identical to <tt>mdb_vwrite()</tt>, except that the virtual address at which
writing begins is obtained from the value of the symbol specified by name.
If no symbol by that name is found, -1 is returned. Otherwise, the
number of bytes successfully written is returned on success, and -1 is returned
on error. The primary executable's symbol table is used for the symbol lookup;
if the symbol resides in another symbol table, you must first apply <tt>mdb_lookup_by_obj()</tt>, then
<tt>mdb_vwrite()</tt>.</p>

<a name="api-29"></a><h4><tt>mdb_readvar()</tt> and <tt>mdb_writevar()</tt></h4>
<pre>ssize_t mdb_readvar(void *buf, const char *name);
ssize_t mdb_writevar(const void *buf, const char *name);</pre><p><a name="indexterm-526"></a><a name="indexterm-527"></a><tt>mdb_readvar()</tt> is similar to <tt>mdb_vread()</tt>, except that the virtual address at which reading
begins and the number of bytes to read are obtained from the value
and size of the symbol specified by <i>name</i>.  If no symbol by
that name is found, -1 is returned. The symbol size (the number of
bytes read) is returned on success; -1 is returned on error. This is
useful for reading well-known variables whose sizes are fixed. For example:</p><pre>                int hz;     /* system clock rate */
                mdb_readvar(&amp;hz, "hz");</pre><p>The caller can first look up the symbol separately if it is
necessary to distinguish between symbol lookup failure and read failure.  The caller must
also carefully check the definition of the symbol of interest in order to
make sure that the local declaration is the exact same type as
the target's definition. For example, if the caller declares an <tt>int</tt>, and the symbol
of interest is actually a <tt>long</tt>, and the debugger is examining a 64-bit
kernel target, <tt>mdb_readvar()</tt> copies back 8 bytes to the caller's buffer, corrupting the
4 bytes following the storage for the <tt>int</tt>.</p><p><tt>mdb_writevar()</tt> is identical to <tt>mdb_vwrite()</tt>, except that the virtual address at which writing
begins and the number of bytes to write are obtained from the value
and size of the symbol specified by name.  If no symbol by
that name is found, -1 is returned. Otherwise, the number of bytes successfully
written is returned on success, and -1 is returned on error.</p><p>For both functions, the primary executable's symbol table is used for the symbol
lookup; if the symbol resides in another symbol table, you must first apply
<tt>mdb_lookup_by_obj()</tt>, then <tt>mdb_vread()</tt> or <tt>mdb_vwrite()</tt>.</p>

<a name="api-28"></a><h4><tt>mdb_lookup_by_name()</tt> and <tt>mdb_lookup_by_obj()</tt></h4>
<pre>int mdb_lookup_by_name(const char *name, GElf_Sym *sym);
int mdb_lookup_by_obj(const char *object, const char *name, GElf_Sym *sym);</pre><p><a name="indexterm-528"></a><a name="indexterm-529"></a>Look up the specified symbol name and copy the ELF symbol information into
the <tt>GElf_Sym</tt> pointed to by <i>sym</i>. If the symbol is found, the function
returns 0; otherwise, -1 is returned. The <i>name</i> parameter specifies the symbol name.
The <i>object</i> parameter tells the debugger where to look for the symbol. For
the <tt>mdb_lookup_by_name()</tt> function, the object file defaults to <tt>MDB_OBJ_EXEC</tt>. For <tt>mdb_lookup_by_obj()</tt>, the object name
should be one of the following:</p><dl><dt><tt>MDB_OBJ_EXEC</tt></dt>
<dd><p><a name="indexterm-530"></a>Look in the executable's symbol table (<tt>.symtab</tt> section). For kernel crash dumps, this corresponds to the symbol table from the <tt>unix.X</tt> file or from <tt>/dev/ksyms</tt>.</p></dd>
<dt><tt>MDB_OBJ_RTLD</tt></dt>
<dd><p><a name="indexterm-531"></a>Look in the runtime link-editor's symbol table. For kernel crash dumps, this corresponds to the symbol table for the <tt>krtld</tt> module.</p></dd>
<dt><tt>MDB_OBJ_EVERY</tt></dt>
<dd><p><a name="indexterm-532"></a>Look in all known symbol tables. For kernel crash dumps, this includes the <tt>.symtab</tt> and <tt>.dynsym</tt> sections from the <tt>unix.X</tt> file or <tt>/dev/ksyms</tt>, as well as per-module symbol tables if these have been processed.</p></dd>
<dt><tt>object</tt></dt>
<dd><p>If the name of a particular load object is explicitly specified, the search is restricted to the symbol table of this object. The object can be named according to the naming convention for load objects described in <a href="syntax-16.html">Symbol Name Resolution</a>. </p></dd>
</dl>


<a name="api-48"></a><h4><tt>mdb_lookup_by_addr()</tt></h4>
<pre>int mdb_lookup_by_addr(uintptr_t addr, uint_t flag, char *buf,
                size_t len, GElf_Sym *sym);</pre><p><a name="indexterm-533"></a>Locate the symbol corresponding to the specified address and copy the ELF symbol
information into the <tt>GElf_Sym</tt> pointed to by <i>sym</i> and the symbol name into
the character array addressed by <i>buf</i>. If a corresponding symbol is found, the function
returns 0; otherwise -1 is returned.</p><p>The flag parameter specifies the lookup mode and should be one of
the following:</p><dl><dt><tt>MDB_SYM_FUZZY</tt></dt>
<dd><p><a name="indexterm-534"></a>Allow fuzzy matching to take place, based on the current symbol distance setting. The symbol distance can be controlled using the <tt>::set</tt> <tt>-s</tt> built-in. If an explicit symbol distance has been set (absolute mode), the address can match a symbol if the distance from the symbol's value to the address does not exceed the absolute symbol distance. If smart mode is enabled (symbol distance = 0), then the address can match the symbol if it is in the range [symbol value, symbol value + symbol size). </p></dd>
<dt><tt>MDB_SYM_EXACT</tt></dt>
<dd><p><a name="indexterm-535"></a>Disallow fuzzy matching. The symbol can match only the address if the symbol value exactly equals the specified address.</p></dd>
</dl>
<p>If a symbol match occurs, the name of the symbol is copied
into the <i>buf</i> supplied by the caller. The <i>len</i> parameter specifies the length
of this buffer in bytes. The caller's <i>buf</i> should be at least of
size <tt>MDB_SYM_NAMLEN</tt> bytes. The debugger copies the name to this buffer and appends
a trailing null byte. If the name length exceeds the length of the
buffer, the name is truncated but always includes a trailing null byte.</p>

<a name="api-26"></a><h4><tt>mdb_getopts()</tt></h4>
<pre>int mdb_getopts(int argc, const mdb_arg_t *argv, ...);</pre><p><a name="indexterm-536"></a>Parse and process options and option arguments from the specified argument array (<i>argv</i>). The
<i>argc</i> parameter denotes the length of the argument array. This function processes each
argument in order, and stops and returns the array index of the first
argument that could not be processed. If all arguments are processed successfully, <i>argc</i> is
returned.</p><p>Following the <i>argc</i> and <i>argv</i> parameters, the <tt>mdb_getopts()</tt> function accepts a variable list of
arguments describing the options that are expected to appear in the <i>argv</i> array. 
Each option is described by an option letter (<tt>char</tt> argument), an option type
(<tt>uint_t</tt> argument), and one or two additional arguments, as shown in the table
below. The list of option arguments is terminated with a NULL argument. 
The type should be one of one of the following:</p><dl><dt><tt>MDB_OPT_SETBITS</tt></dt>
<dd><p>The option will <tt>OR</tt> the specified bits into a flag word. The option is described by these parameters:</p><p><tt>char c, uint_t type, uint_t bits, uint_t *p</tt></p><p><a name="indexterm-537"></a>If type is <tt>MDB_OPT_SETBITS</tt> and option <i>c</i> is detected in the <i>argv</i> list, the debugger will <tt>OR</tt> bits into the integer referenced by pointer <i>p</i>.</p></dd>
<dt><tt>MDB_OPT_CLRBITS</tt></dt>
<dd><p>The option clears the specified bits from a flag word. The option is described by these parameters:</p><p><tt>char c, uint_t type, uint_t bits, uint_t *p</tt></p><p><a name="indexterm-538"></a>If type is <tt>MDB_OPT_CLRBITS</tt> and option <i>c</i> is detected in the <i>argv</i> list, the debugger clears bits from the integer referenced by pointer <i>p</i>.</p></dd>
<dt><tt>MDB_OPT_STR</tt></dt>
<dd><p>The option accepts a string argument. The option is described by these parameters:</p><p><tt>char c, uint_t type, const char **p</tt></p><p><a name="indexterm-539"></a>If type is <tt>MDB_OPT_STR</tt> and option <i>c</i> is detected in the <i>argv</i> list, the debugger stores a pointer to the string argument following <i>c</i> in the pointer referenced by <i>p</i>.</p></dd>
<dt><tt>MDB_OPT_UINTPTR</tt></dt>
<dd><p>The option accepts a <tt>uintptr_t</tt> argument. The option is described by these parameters:</p><p><tt>char c, uint_t type, uintptr_t *p</tt></p><p><a name="indexterm-540"></a>If type is <tt>MDB_OPT_UINTPTR</tt> and option c is detected in the <i>argv</i> list, the debugger stores the integer argument following <i>c</i> in the <tt>uintptr_t</tt> referenced by <i>p</i>.</p></dd>
<dt><tt>MDB_OPT_UINTPTR_SET</tt></dt>
<dd><p>The option accepts a <tt>uintptr_t</tt> argument.  The option is described by these parameters:</p><p><tt>char c, uint_t type, boolean_t *flag, uintptr_t *p</tt></p><p>If type is <tt>MDB_OPT_UINTPTR_SET</tt> and option <i>c</i> is detected in the <i>argv</i> list, the debugger stores the value '1' (TRUE) into the <tt>boolean_t</tt> referenced by <i>flag</i>, and the integer argument following <i>c</i> in the <tt>uintptr_t</tt> referenced by <i>p</i>.</p></dd>
<dt><tt>MDB_OPT_UINT64</tt></dt>
<dd><p>The option accepts a <tt>uint64_t</tt> argument. The option is described by these parameters:</p><p><tt>char c, uint_t type, uint64_t *p</tt></p><p><a name="indexterm-541"></a>If type is <tt>MDB_OPT_UINT64</tt> and option <i>c</i> is detected in the <i>argv</i> list, the debugger stores the integer argument following <i>c</i> in the <tt>uint64_t</tt> referenced by <i>p</i>.</p></dd>
</dl>
<p>For example, the following source code:</p><pre>int
dcmd(uintptr_t addr, uint_t flags, int argc, const mdb_arg_t *argv)
{
        uint_t opt_v = FALSE;
        const char *opt_s = NULL;

        if (mdb_getopts(argc, argv,
            'v', MDB_OPT_SETBITS, TRUE, &amp;opt_v,
            's', MDB_OPT_STR, &amp;opt_s, NULL) != argc)
                return (DCMD_USAGE);

        /* ... */
}</pre><p>demonstrates how <tt>mdb_getopts()</tt> might be used in a dcmd to accept a boolean
option &ldquo;<tt>-v</tt>&rdquo; that sets the <i>opt_v</i> variable to TRUE, and an option &ldquo;<tt>-s</tt>&rdquo;
that accepts a string argument that is stored in the <i>opt_s</i> variable. The
<tt>mdb_getopts()</tt> function also automatically issues warning messages if it detects an invalid option letter
or missing option argument before returning to the caller. The storage for argument
strings and the <i>argv</i> array is automatically garbage-collected by the debugger upon completion
of the dcmd.</p>

<a name="api-25"></a><h4><tt>mdb_strtoull()</tt></h4>
<pre>u_longlong_t mdb_strtoull(const char *s);</pre><p><a name="indexterm-542"></a>Convert the specified string <i>s</i> to an <tt>unsigned long long</tt> representation. This function is
intended for use in processing and converting string arguments in situations where <tt>mdb_getopts()</tt>
is not appropriate. If the string argument cannot be converted to a valid
integer representation, the function fails by printing an appropriate error message and aborting
the dcmd. Therefore, error checking code is not required. The string can be
prefixed with any of the valid base specifiers (0i, 0I, 0o, 0O, 0t,
0T, 0x, or 0X); otherwise, it is interpreted using the default base. The
function will fail and abort the dcmd if any of the characters in
<i>s</i> are not appropriate for the base, or if integer overflow occurs.</p>

<a name="api-24"></a><h4><tt>mdb_alloc()</tt>, <tt>mdb_zalloc()</tt> and <tt>mdb_free()</tt></h4>
<pre>void *mdb_alloc(size_t size, uint_t flags);
void *mdb_zalloc(size_t size, uint_t flags);
void mdb_free(void *buf, size_t size);</pre><p><a name="indexterm-543"></a><a name="indexterm-544"></a><a name="indexterm-545"></a><tt>mdb_alloc()</tt> allocates <i>size</i> bytes of debugger memory and returns a pointer to the
allocated memory. The allocated memory is at least double-word aligned, so it can
hold any C data structure.  No greater alignment can be assumed. The <i>flags</i>
parameter should be the bitwise <tt>OR</tt> of one or more of the following
values:</p><dl><dt><tt>UM_NOSLEEP</tt></dt>
<dd><p><a name="indexterm-546"></a>If sufficient memory to fulfill the request is not immediately available, return NULL to indicate failure. The caller must check for NULL and handle this case appropriately.</p></dd>
<dt><tt>UM_SLEEP</tt></dt>
<dd><p><a name="indexterm-547"></a>If sufficient memory to fulfill the request is not immediately available, sleep until such time as the request can be fulfilled. As a result, <tt>UM_SLEEP</tt> allocations are guaranteed to succeed. The caller need not check for a NULL return value.</p></dd>
<dt><tt>UM_GC</tt></dt>
<dd><p><a name="indexterm-548"></a>Garbage-collect allocation automatically at the end of this debugger command. The caller should not subsequently call <tt>mdb_free()</tt> on this block, as the debugger will take care of deallocation automatically.  All memory allocation from within a dcmd must use <tt>UM_GC</tt> so that if the dcmd is interrupted by the user, the debugger can garbage-collect the memory.</p></dd>
</dl>
<p><tt>mdb_zalloc()</tt> is like <tt>mdb_alloc()</tt>, but the allocated memory is filled with zeroes before
returning it to the caller. No guarantees are made about the initial contents
of memory returned by <tt>mdb_alloc()</tt>.  <tt>mdb_free()</tt> is used to free previously allocated memory
(unless it was allocated <tt>UM_GC</tt>).  The buffer address and size must exactly
match the original allocation. It is not legal to free only a portion
of an allocation with <tt>mdb_free()</tt>. It is not legal to free an allocation
more than once. An allocation of zero bytes always returns NULL; freeing a
NULL pointer with size zero always succeeds.</p>

<a name="api-18"></a><h4><tt>mdb_printf()</tt></h4>
<pre>void mdb_printf(const char *format, ...);</pre><p><a name="indexterm-549"></a>Print formatted output using the specified format string and arguments. Module writers should use
<tt>mdb_printf()</tt> for all output, except for warning and error messages. This function automatically
triggers the built-in output pager when appropriate. The <tt>mdb_printf()</tt> function is similar to <a href="http://docs.sun.com/doc/819-2243/printf-3c?a=view"><tt>printf</tt>(3C)</a>, with
certain exceptions: the <tt>%C</tt>, <tt>%S</tt>, and <tt>%ws</tt> specifiers for wide character strings are
not supported, the <tt>%f</tt> floating-point format is not supported, the <tt>%e</tt>, <tt>%E</tt>, <tt>%g</tt>,
and <tt>%G</tt> specifiers for alternative double formats produce only a single style of
output, and precision specifications of the form <tt>%.n</tt> are not supported. The list of
specifiers that are supported follows:</p>

<a name="api-23"></a><h5>Flag Specifiers</h5>
<a name="indexterm-550"></a><dl><dt><tt>%#</tt></dt>
<dd><p>If the <tt>#</tt> sign is found in the format string, this selects the alternate form of the given format. Not all formats have an alternate form; the alternate form is different depending on the format. Refer to the format descriptions below for details on the alternate format.</p></dd>
<dt><tt>%+</tt></dt>
<dd><p>When printing signed values, always display the sign (prefix with either '+' or '-'). Without <tt>%+</tt>, positive values have no sign prefix, and negative values have a '-' prefix prepended to them.</p></dd>
<dt><tt>%-</tt></dt>
<dd><p>Left-justify the output within the specified field width. If the width of the output is less than the specified field width, the output will be padded with blanks on the right-hand side. Without <tt>%-</tt>, values are right-justified by default.</p></dd>
<dt><tt>%0</tt></dt>
<dd><p>Zero-fill the output field if the output is right-justified and the width of the output is less than the specified field width. Without <tt>%0</tt>, right-justified values are prepended with blanks in order to fill the field.</p></dd>
</dl>


<a name="api-19"></a><h5>Field Width Specifiers</h5>
<a name="indexterm-551"></a><dl><dt><tt>%n</tt></dt>
<dd><p>Field width is set to the specified decimal value.</p></dd>
<dt><tt>%?</tt></dt>
<dd><p>Field width is set to the maximum width of a hexadecimal pointer value. This is 8 in an ILP32 environment, and 16 in an LP64 environment.</p></dd>
<dt><tt>%*</tt></dt>
<dd><p>Field width is set to the value specified at the current position in the argument list. This value is assumed to be an <tt>int</tt>. Note that in the 64-bit compilation environment, it may be necessary to cast <tt>long</tt> values to <tt>int</tt>.</p></dd>
</dl>


<a name="api-20"></a><h5>Integer Specifiers</h5>
<a name="indexterm-552"></a><dl><dt><tt>%h</tt></dt>
<dd><p>Integer value to be printed is a <tt>short</tt>.</p></dd>
<dt><tt>%l</tt></dt>
<dd><p>Integer value to be printed is a <tt>long</tt>.</p></dd>
<dt><tt>%ll</tt></dt>
<dd><p>Integer value to be printed is a <tt>long long</tt>.</p></dd>
</dl>


<a name="api-22"></a><h5>Terminal Attribute Specifiers</h5>
<a name="indexterm-553"></a><p>If standard output for the debugger is a terminal, and terminal attributes can
be obtained by the terminfo database, the following terminal escape constructs can be
used:</p><dl><dt><tt>%&lt;n&gt;</tt></dt>
<dd><p>Enable the terminal attribute corresponding to <i>n</i>. Only a single attribute can be enabled with each instance of <tt>%&lt;&gt;</tt>.</p></dd>
<dt><tt>%&lt;/n&gt;</tt></dt>
<dd><p>Disable the terminal attribute corresponding to <i>n</i>. Note that in the case of reverse video, dim text, and bold text, the terminal codes to disable these attributes might be identical. Therefore, it might not be possible to disable these attributes independently of one another.</p></dd>
</dl>
<p>If no terminal information is available, each terminal attribute construct is ignored by
<tt>mdb_printf()</tt>. For more information on terminal attributes, see <a href="http://docs.sun.com/doc/819-2251/terminfo-4?a=view"><tt>terminfo</tt>(4)</a>. The available terminfo attributes are:</p><dl><dt><tt>a</tt></dt>
<dd><p>Alternate character set</p></dd>
<dt><tt>b</tt></dt>
<dd><p>Bold text</p></dd>
<dt><tt>d</tt></dt>
<dd><p>Dim text</p></dd>
<dt><tt>r</tt></dt>
<dd><p>Reverse video</p></dd>
<dt><tt>s</tt></dt>
<dd><p>Best standout capability</p></dd>
<dt><tt>u</tt></dt>
<dd><p>Underlining</p></dd>
</dl>


<a name="api-21"></a><h5>Format Specifiers</h5>
<a name="indexterm-554"></a><dl><dt><tt>%%</tt></dt>
<dd><p>The '<tt>%</tt>' symbol is printed.</p></dd>
<dt><tt>%a</tt></dt>
<dd><p>Prints an address in symbolic form. The minimum size of the value associated with <tt>%a</tt> is a <tt>uintptr_t</tt>; specifying <tt>%la</tt> is not necessary. If address-to-symbol conversion is on, the debugger will attempt to convert the address to a symbol name followed by an offset in the current output radix and print this string; otherwise, the value is printed in the default output radix. If <tt>%#a</tt> is used, the alternate format adds a '<tt>:</tt>' suffix to the output.</p></dd>
<dt><tt>%A</tt></dt>
<dd><p>This format is identical to <tt>%a</tt>, except when an address cannot be converted to a symbol name plus an offset, nothing is printed. If <tt>%#A</tt> is used, the alternate format prints a '<tt>?</tt>' when address conversion fails.</p></dd>
<dt><tt>%b</tt></dt>
<dd><p><a name="indexterm-555"></a>Decode and print a bit field in symbolic form. This specifier expects two consecutive arguments: the bit field value (<tt>int</tt> for <tt>%b</tt>, <tt>long</tt> for <tt>%lb</tt>, and so forth), and a pointer to an array of <tt>mdb_bitmask_t</tt> structures:</p><pre>typedef struct mdb_bitmask {
        const char *bm_name;       /* String name to print */
        u_longlong_t bm_mask;      /* Mask for bits */
        u_longlong_t bm_bits;      /* Result for value &amp; mask */
} mdb_bitmask_t;</pre><p>The array should be terminated by a structure whose <tt>bm_name</tt> field is set to NULL. When <tt>%b</tt> is used, the debugger reads the value argument, then iterates through each <tt>mdb_bitmask</tt> structure checking to see if:</p><p><tt>(value &amp; bitmask-&gt;bm_mask) == bitmask-&gt;bm_bits</tt></p><p>If this expression is true, the <tt>bm_name</tt> string is printed. Each string printed is separated by a comma. The following example shows how <tt>%b</tt> can be used to decode the <tt>t_flag</tt> field in a <tt>kthread_t</tt>:</p><pre>const mdb_bitmask_t t_flag_bits[] = {
        { "T_INTR_THREAD", T_INTR_THREAD, T_INTR_THREAD },
        { "T_WAKEABLE", T_WAKEABLE, T_WAKEABLE },
        { "T_TOMASK", T_TOMASK, T_TOMASK },
        { "T_TALLOCSTK", T_TALLOCSTK, T_TALLOCSTK },
            ...
        { NULL, 0, 0 }
};

void
thr_dump(kthread_t *t)
{
        mdb_printf("t_flag = &lt;%hb&gt;\n", t-&gt;t_flag, t_flag_bits);

        ...
}</pre><p>If <tt>t_flag</tt> was set to 0x000a, the function would print:</p><pre>t_flag = &lt;T_WAKEABLE,T_TALLOCSTK&gt;</pre><p>If <tt>%#b</tt> is specified, the union of all bits that were not matched by an element in the bitmask array is printed as a hexadecimal value following the decoded names. </p></dd>
<dt><tt>%c</tt></dt>
<dd><p>Print the specified integer as an ASCII character.</p></dd>
<dt><tt>%d</tt></dt>
<dd><p>Print the specified integer as a signed decimal value. Same as <tt>%i</tt>. If <tt>%#d</tt> is specified, the alternate format prefixes the value with '<tt>0t</tt>'.</p></dd>
<dt><tt>%e</tt></dt>
<dd><p>Print the specified double in the floating-point format <tt>[+/-]d.ddddddde[+/-]dd</tt>, where there is one digit before the radix character, seven digits of precision, and at least two digits following the exponent.</p></dd>
<dt><tt>%E</tt></dt>
<dd><p>Print the specified double using the same rules as <tt>%e</tt>, except that the exponent character will be '<tt>E</tt>' instead of '<tt>e</tt>'.</p></dd>
<dt><tt>%g</tt></dt>
<dd><p>Print the specified double in the same floating-point format as <tt>%e</tt>, but with sixteen digits of precision. If <tt>%llg</tt> is specified, the argument is expected to be of type <tt>long double</tt> (quad-precision floating-point value).</p></dd>
<dt><tt>%G</tt></dt>
<dd><p>Print the specified double using the same rules as <tt>%g</tt>, except that the exponent character will be '<tt>E</tt>' instead of '<tt>e</tt>'.</p></dd>
<dt><tt>%i</tt></dt>
<dd><p>Print the specified integer as a signed decimal value. Same as <tt>%d</tt>. If <tt>%#i</tt> is specified, the alternate format prefixes the value with '<tt>0t</tt>'. </p></dd>
<dt><tt>%I</tt></dt>
<dd><p>Print the specified 32-bit unsigned integer as an Internet IPv4 address in dotted-decimal format (for example, the hexadecimal value <tt>0xffffffff</tt> would print as <tt>255.255.255.255</tt>).</p></dd>
<dt><tt>%m</tt></dt>
<dd><p>Print a margin of whitespace. If no field is specified, the default output margin width is used; otherwise, the field width determines the number of characters of white space that are printed.</p></dd>
<dt><tt>%o</tt></dt>
<dd><p>Print the specified integer as an unsigned octal value. If <tt>%#o</tt> is used, the alternate format prefixes the output with '<tt>0</tt>'.</p></dd>
<dt><tt>%p</tt></dt>
<dd><p>Print the specified pointer (<tt>void *</tt>) as a hexadecimal value.</p></dd>
<dt><tt>%q</tt></dt>
<dd><p>Print the specified integer as a signed octal value. If <tt>%#o</tt> is used, the alternate format prefixes the output with '<tt>0</tt>'.</p></dd>
<dt><tt>%r</tt></dt>
<dd><p>Print the specified integer as an unsigned value in the current output radix. The user can change the output radix using the <tt>$d</tt> dcmd. If <tt>%#r</tt> is specified, the alternate format prefixes the value with the appropriate base prefix: '<tt>0i</tt>' for binary, '<tt>0o</tt>' for octal, '<tt>0t</tt>' for decimal, or '<tt>0x</tt>' for hexadecimal.</p></dd>
<dt><tt>%R</tt></dt>
<dd><p>Print the specified integer as a signed value in the current output radix. If <tt>%#R</tt> is specified, the alternate format prefixes the value with the appropriate base prefix.</p></dd>
<dt><tt>%s</tt></dt>
<dd><p>Print the specified string (<tt>char *</tt>). If the string pointer is NULL, the string '<tt>&lt;NULL&gt;</tt>' is printed.</p></dd>
<dt><tt>%t</tt></dt>
<dd><p>Advance one or more tab stops. If no width is specified, output advances to the next tab stop; otherwise the field width determines how many tab stops are advanced.</p></dd>
<dt><tt>%T</tt></dt>
<dd><p>Advance the output column to the next multiple of the field width. If no field width is specified, no action is taken. If the current output column is not a multiple of the field width, white space is added to advance the output column.</p></dd>
<dt><tt>%u</tt></dt>
<dd><p>Print the specified integer as an unsigned decimal value. If <tt>%#u</tt> is specified, the alternate format prefixes the value with '<tt>0t</tt>'.</p></dd>
<dt><tt>%x</tt></dt>
<dd><p>Print the specified integer as a hexadecimal value. The characters a-f are used as the digits for the values 10-15. If <tt>%#x</tt> is specified, the alternate format prefixes the value with '<tt>0x</tt>'.</p></dd>
<dt><tt>%X</tt></dt>
<dd><p>Print the specified integer as a hexadecimal value. The characters A-F are used as the digits for the values 10-15. If <tt>%#X</tt> is specified, the alternate format prefixes the value with '<tt>0X</tt>'.</p></dd>
<dt><tt>%Y</tt></dt>
<dd><p>The specified <tt>time_t</tt> is printed as the string '<tt>year month day HH:MM:SS</tt>'.</p></dd>
</dl>


<a name="api-17"></a><h4><tt>mdb_snprintf()</tt></h4>
<pre>size_t mdb_snprintf(char *buf, size_t len, const char *format, ...);</pre><p><a name="indexterm-556"></a>Construct a formatted string based on the specified format string and arguments, and
store the resulting string into the specified <i>buf</i>. The <tt>mdb_snprintf()</tt> function accepts the same
format specifiers and arguments as the <tt>mdb_printf()</tt> function. The <i>len</i> parameter specifies the
size of <i>buf</i> in bytes.  No more than <i>len</i> - 1 formatted bytes
are placed in <i>buf</i>; <tt>mdb_snprintf()</tt>  always terminates <i>buf</i> with a null byte.
The function returns the number of bytes required for the complete formatted string,
not including the terminating null byte. If the <i>buf</i> parameter is NULL and
<i>len</i> is set to zero, the function will not store any characters to
<i>buf</i> and returns the number of bytes required for the complete formatted string;
this technique can be used to determine the appropriate size of a buffer
for dynamic memory allocation.</p>

<a name="api-16"></a><h4><tt>mdb_warn()</tt></h4>
<pre>void mdb_warn(const char *format, ...);</pre><p><a name="indexterm-557"></a>Print an error or warning message to standard error. The <tt>mdb_warn()</tt> function accepts a
format string and variable argument list that can contain any of the specifiers
documented for <tt>mdb_printf()</tt>. However, the output of <tt>mdb_warn()</tt> is sent to standard error,
which is not buffered and is not sent through the output pager or
processed as part of a dcmd pipeline.  All error messages are automatically
prefixed with the string &ldquo;<tt>mdb:</tt>&rdquo;.  </p><p>In addition, if the <i>format</i> parameter does not contain a newline (<tt>\n</tt>) character,
the format string is implicitly suffixed with the string &ldquo;<tt>: %s\n</tt>&rdquo;, where <tt>%s</tt> is replaced
by the error message string corresponding to the last error recorded by a
module API function. For example, the following source code:</p><pre>if (mdb_lookup_by_name("no_such_symbol", &amp;sym) == -1)
       mdb_warn("lookup_by_name failed");</pre><p>produces this output:</p><pre>mdb: lookup_by_name failed: unknown symbol name</pre>

<a name="api-56"></a><h4><tt>mdb_flush()</tt></h4>
<pre>void mdb_flush(void);</pre><p><a name="indexterm-558"></a>Flush all currently buffered output. Normally, <tt>mdb</tt>'s standard output is line-buffered; output generated using
<tt>mdb_printf()</tt> is not flushed to the terminal (or other standard output destination) until
a newline is encountered, or at the end of the current dcmd. However,
in some situations you might want to explicitly flush standard output prior to
printing a newline; <tt>mdb_flush()</tt> can be used for this purpose.</p>

<a name="api-60"></a><h4><tt>mdb_nhconvert()</tt></h4>
<pre>void mdb_nhconvert(void *dst, const void *src, size_t nbytes);</pre><p><a name="indexterm-559"></a>Convert a sequence of <tt>nbytes</tt> bytes stored at the address specified by <tt>src</tt>
from network byte order to host byte order and store the result at
the address specified by <tt>dst</tt>.  The <tt>src</tt> and <tt>dst</tt> parameters may be
the same, in which case the object is converted in place.  This
function may be used to convert from host order to network order or
from network order to host order, since the conversion is the same in
either case.</p>

<a name="api-61"></a><h4><tt>mdb_dumpptr()</tt> and <tt>mdb_dump64()</tt></h4>
<pre>int mdb_dumpptr(uintptr_t addr, size_t nbytes, uint_t flags,
                     mdb_dumpptr_cb_t func, void *data);
int mdb_dump64(uint64_t addr, uint64_t nbytes, uint_t flags,
                     mdb_dump64_cb_t func, void *data);</pre><p><a name="indexterm-560"></a><a name="indexterm-561"></a>These functions can be used to generate formatted hexadecimal and ASCII  
    data dumps that are printed to standard output. 
Each function accepts an <tt>addr</tt> parameter specifying the starting location, a <tt>nbytes</tt> parameter
specifying the number of bytes to display, a set of flags described below,
a func callback function to use to read the data to display, and
a data parameter that is passed to each invocation of the callback func
as its last argument.  The functions are identical in every regard except
that <tt>mdb_dumpptr</tt> uses <tt>uintptr_t</tt> for its address parameters and <tt>mdb_dump64</tt> uses <tt>uint64_t</tt>.
 This distinction is useful when combining <tt>mdb_dump64</tt> with <tt>mdb_pread</tt>, for example.
 The built-in <tt>::dump</tt> dcmd uses these functions to perform its data
display.</p><p>The flags parameter should be the bitwise OR of one or more
of the following values:</p><dl><dt><tt>MDB_DUMP_RELATIVE</tt></dt>
<dd><p><a name="indexterm-562"></a>Number lines relative to the start address instead of with the explicit address of each line.</p></dd>
<dt><tt>MDB_DUMP_ALIGN</tt></dt>
<dd><p><a name="indexterm-563"></a>Align the output at a paragraph boundary.</p></dd>
<dt><tt>MDB_DUMP_PEDANT</tt></dt>
<dd><p><a name="indexterm-564"></a>Display full-width addresses instead of truncating the address to fit the output in 80 columns.</p></dd>
<dt><tt>MDB_DUMP_ASCII</tt></dt>
<dd><p><a name="indexterm-565"></a>Display ASCII values next to the hexadecimal data.</p></dd>
<dt><tt>MDB_DUMP_HEADER</tt></dt>
<dd><p><a name="indexterm-566"></a>Display a header line about the data.</p></dd>
<dt><tt>MDB_DUMP_TRIM</tt></dt>
<dd><p><a name="indexterm-567"></a>Only read from and display the contents of the specified addresses, instead of reading and printing entire lines.</p></dd>
<dt><tt>MDB_DUMP_SQUISH</tt></dt>
<dd><p><a name="indexterm-568"></a>Elide repeated lines by placing a &ldquo;*&rdquo; on a line that is a repeat of the previous line.</p></dd>
<dt><tt>MDB_DUMP_NEWDOT</tt></dt>
<dd><p><a name="indexterm-569"></a>Update the value of dot to the address beyond the last address read by the function.</p></dd>
<dt><tt>MDB_DUMP_ENDIAN</tt></dt>
<dd><p><a name="indexterm-570"></a>Adjust for endianness. This option assumes that the word size is equal to the current group size, specified by <tt>MDB_DUMP_GROUP()</tt>.  This option will always turn off alignment, headers, and ASCII display to avoid confusing output. If <tt>MDB_DUMP_TRIM</tt> is set with <tt>MDB_DUMP_ENDIAN</tt>, the number of bytes dumped will be rounded down to the nearest word size bytes.</p></dd>
<dt><tt>MDB_DUMP_WIDTH(</tt><i>width</i><tt>)</tt></dt>
<dd><p><a name="indexterm-571"></a>Increase the number of 16-byte paragraphs per line that are displayed.  The default value of <i>width</i> is one, and the maximum value is 16.</p></dd>
<dt><tt>MDB_DUMP_GROUP(</tt><i>group</i><tt>)</tt></dt>
<dd><p><a name="indexterm-572"></a>Set the byte group size to <i>group</i>. The default <i>group</i> size is four bytes. The <i>group</i> size must be a power of two that divides the line width.</p></dd>
</dl>


<a name="api-15"></a><h4><tt>mdb_one_bit()</tt></h4>
<pre>const char *mdb_one_bit(int width, int bit, int on);</pre><p><a name="indexterm-573"></a>The <tt>mdb_one_bit()</tt> function can be used to print a graphical representation of a
bit field in which a single bit of interest is turned on
or off. This function is useful for creating verbose displays of bit fields
similar to the output from <tt>snoop(1M) -v</tt>.  For example, the following source code:</p><pre>#define FLAG_BUSY       0x1

uint_t flags;

/* ... */

mdb_printf("%s = BUSY\n", mdb_one_bit(8, 0, flags &amp; FLAG_BUSY));</pre><p>produces this output:</p><pre>.... ...1 = BUSY</pre><p>Each bit in the bit field is printed as a period (<tt>.</tt>), with
each 4-bit sequence separated by a white space. The bit of interest
is printed as 1 or 0, depending on the setting of the <i>on</i>
parameter. The total <i>width</i> of the bit field in bits is specified by the
width parameter, and the bit position of the bit of interest is
specified by the <i>bit</i> parameter. Bits are numbered starting from zero. The function returns
a pointer to an appropriately sized, null-terminated string containing the formatted bit representation.
 The string is automatically garbage-collected upon completion of the current dcmd.</p>

<a name="api-14"></a><h4><tt>mdb_inval_bits()</tt></h4>
<pre>const char *mdb_inval_bits(int width, int start, int stop);</pre><p><a name="indexterm-574"></a>The <tt>mdb_inval_bits()</tt> function is used, along with <tt>mdb_one_bit()</tt>, to print a graphical representation of
a bit field. This function marks a sequence of bits as invalid
or reserved by displaying an '<tt>x</tt>' at the appropriate bit location. Each bit in
the bit field is represented as a period (<tt>.</tt>), except for those bits
in the range of bit positions specified by the start and stop parameters.
Bits are numbered starting from zero. For example, the following source code:</p><pre>mdb_printf("%s = reserved\n", mdb_inval_bits(8, 7, 7));</pre><p>produces this output:</p><pre>x... .... = reserved</pre><p>The function returns a pointer to an appropriately sized, null-terminated string containing the
formatted bit representation. The string is automatically garbage-collected upon completion of the current
dcmd.</p>

<a name="api-13"></a><h4><tt>mdb_inc_indent()</tt> and <tt>mdb_dec_indent()</tt></h4>
<pre>ulong_t mdb_inc_indent(ulong_t n);
ulong_t mdb_dec_indent(ulong_t n);</pre><p><a name="indexterm-575"></a><a name="indexterm-576"></a>These functions increment and decrement the numbers of columns that MDB will auto-indent
with white space before printing a line of output. The size of the
delta is specified by <i>n</i>, a number of columns. Each function returns the
previous absolute value of the indent. Attempts to decrement the indent below zero
have no effect. Following a call to either function, subsequent calls to <tt>mdb_printf()</tt>
are indented appropriately. If the dcmd completes or is forcibly terminated by the user,
the indent is restored automatically to its default setting by the debugger.</p>

<a name="api-12"></a><h4><tt>mdb_eval()</tt></h4>
<pre>int mdb_eval(const char *s);</pre><p><a name="indexterm-577"></a>Evaluate and execute the specified command string <i>s</i>, as if it had been read
from standard input by the debugger. This function returns 0 for success, or
-1 for error.  <tt>mdb_eval()</tt> fails if the command string contains a syntax
error, or if the command string executed by <tt>mdb_eval()</tt> is forcibly aborted by
the user using the pager or by issuing an interrupt.</p>

<a name="api-49"></a><h4><tt>mdb_set_dot()</tt> and <tt>mdb_get_dot()</tt></h4>
<pre>void mdb_set_dot(uintmax_t dot);
uintmax_t mdb_get_dot(void);</pre><p><a name="indexterm-578"></a><a name="indexterm-579"></a>Set or get the current value of dot (the &ldquo;<tt>.</tt>&rdquo; variable).  Module developers
might want to reposition dot so that, for example, it refers to the
address following the last address read by the dcmd.</p>

<a name="api-50"></a><h4><tt>mdb_get_pipe()</tt></h4>
<pre>void mdb_get_pipe(mdb_pipe_t *p);</pre><p><a name="indexterm-580"></a>Retrieve the contents of the pipeline input buffer for the current dcmd. The
<tt>mdb_get_pipe()</tt> function is intended to be used by dcmds that want to consume
the complete set of pipe input and execute only once, instead of being
invoked repeatedly by the debugger for each pipe input element. Once <tt>mdb_get_pipe()</tt> is
invoked, the dcmd will not be invoked again by the debugger as part
of the current command. This can be used, for example, to construct a
dcmd that sorts a set of input values. </p><p>The pipe contents are placed in an array that is garbage-collected upon termination
of the dcmd, and the array pointer is stored in <tt>p-&gt;pipe_data</tt>. 
The length of the array is placed in <tt>p-&gt;pipe_len</tt>.  If the dcmd
was not executed on the right-hand side of a pipeline (that is, the
<tt>DCMD_PIPE</tt> flag was not set in its <tt>flags</tt> parameter), <tt>p-&gt;pipe_data</tt> is set
to NULL and <tt>p-&gt;pipe_len</tt> is set to zero.</p>

<a name="api-51"></a><h4><tt>mdb_set_pipe()</tt></h4>
<pre>void mdb_set_pipe(const mdb_pipe_t *p);</pre><p>Set the pipeline output buffer to the contents described by the pipe structure
<i>p</i>. The pipe values are placed in the array <tt>p-&gt;pipe_data</tt>, and the length
of the array is stored in <tt>p-&gt;pipe_len</tt>.  The debugger makes its own
copy of this information, so the caller must remember to free <tt>p-&gt;pipe_data</tt> if necessary.
If the pipeline output buffer was previously non-empty, its contents are replaced by
the new array. If the dcmd was not executed on the left
side of a pipeline (that is, the <tt>DCMD_PIPE_OUT</tt> flag was not set in its
flags parameter), this function has no effect.</p>

<a name="api-52"></a><h4><tt>mdb_get_xdata()</tt></h4>
<pre>ssize_t mdb_get_xdata(const char *name, void *buf, size_t nbytes);</pre><p><a name="indexterm-581"></a><a name="indexterm-582"></a>Read the contents of the target external data buffer specified by name into
the buffer specified by <i>buf</i>. The size of <i>buf</i> is specified by the <i>nbytes</i>
parameter; no more than <i>nbytes</i> will be copied to the caller's buffer. The
total number of bytes read will be returned upon success; -1 will be
returned upon error. If the caller wants to determine the size of a
particular named buffer, <i>buf</i> should be specified as NULL and <i>nbytes</i> should be
specified as zero. In this case, <tt>mdb_get_xdata()</tt> will return the total size of the
buffer in bytes but no data will be read. External data buffers provide
module writers access to target data that is not otherwise accessible through the
module API. The set of named buffers exported by the current target can
be viewed using the <tt>::xdata</tt> built-in dcmd.</p>

<a name="api-57"></a><h4>Additional Functions</h4>
<p><a name="indexterm-583"></a>Additionally, module writers can use the following <a href="http://docs.sun.com/doc/819-2243/string-3c?a=view"><tt>string</tt>(3C)</a> and <a href="http://docs.sun.com/doc/819-2243/bstring-3c?a=view"><tt>bstring</tt>(3C)</a> functions.  They
are guaranteed to have the same semantics as the functions described in the
corresponding Solaris man page.</p><pre>strcat()           strcpy()                strncpy()
strchr()           strrchr()               strcmp()
strncmp()          strcasecmp()            strncasecmp()
strlen()           bcmp()                  bcopy()
bzero()            bsearch()               qsort()</pre>
         </div>
      </td>
   </tr>

   <tr class="PageControls" valign="top">
      <td></td>
      <td>
         <table width="100%">
      	   <tr>
      	     <td>
                 <a href="api-3.html">Previous</a>
             </td>
             <td align="right">
                 <a href="options-1.html">Next</a>
             </td>
           </tr>
         </table>
      </td>
   </tr>
</tbody>
</table>


</body>
</html>

